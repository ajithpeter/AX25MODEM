
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4825      	ldr	r0, [pc, #148]	; (8000258 <endfiniloop+0x4>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	2002      	movs	r0, #2
 80001ca:	f380 8814 	msr	CONTROL, r0
 80001ce:	f3bf 8f6f 	isb	sy
 80001d2:	f003 fd15 	bl	8003c00 <__core_init>
 80001d6:	f002 fc93 	bl	8002b00 <__early_init>
 80001da:	4820      	ldr	r0, [pc, #128]	; (800025c <endfiniloop+0x8>)
 80001dc:	4920      	ldr	r1, [pc, #128]	; (8000260 <endfiniloop+0xc>)
 80001de:	4a21      	ldr	r2, [pc, #132]	; (8000264 <endfiniloop+0x10>)

080001e0 <msloop>:
 80001e0:	4291      	cmp	r1, r2
 80001e2:	bf3c      	itt	cc
 80001e4:	f841 0b04 	strcc.w	r0, [r1], #4
 80001e8:	f7ff bffa 	bcc.w	80001e0 <msloop>
 80001ec:	491e      	ldr	r1, [pc, #120]	; (8000268 <endfiniloop+0x14>)
 80001ee:	4a1a      	ldr	r2, [pc, #104]	; (8000258 <endfiniloop+0x4>)

080001f0 <psloop>:
 80001f0:	4291      	cmp	r1, r2
 80001f2:	bf3c      	itt	cc
 80001f4:	f841 0b04 	strcc.w	r0, [r1], #4
 80001f8:	f7ff bffa 	bcc.w	80001f0 <psloop>
 80001fc:	491b      	ldr	r1, [pc, #108]	; (800026c <endfiniloop+0x18>)
 80001fe:	4a1c      	ldr	r2, [pc, #112]	; (8000270 <endfiniloop+0x1c>)
 8000200:	4b1c      	ldr	r3, [pc, #112]	; (8000274 <endfiniloop+0x20>)

08000202 <dloop>:
 8000202:	429a      	cmp	r2, r3
 8000204:	bf3e      	ittt	cc
 8000206:	f851 0b04 	ldrcc.w	r0, [r1], #4
 800020a:	f842 0b04 	strcc.w	r0, [r2], #4
 800020e:	f7ff bff8 	bcc.w	8000202 <dloop>
 8000212:	2000      	movs	r0, #0
 8000214:	4918      	ldr	r1, [pc, #96]	; (8000278 <endfiniloop+0x24>)
 8000216:	4a19      	ldr	r2, [pc, #100]	; (800027c <endfiniloop+0x28>)

08000218 <bloop>:
 8000218:	4291      	cmp	r1, r2
 800021a:	bf3c      	itt	cc
 800021c:	f841 0b04 	strcc.w	r0, [r1], #4
 8000220:	f7ff bffa 	bcc.w	8000218 <bloop>
 8000224:	f003 fcf4 	bl	8003c10 <__late_init>
 8000228:	4c15      	ldr	r4, [pc, #84]	; (8000280 <endfiniloop+0x2c>)
 800022a:	4d16      	ldr	r5, [pc, #88]	; (8000284 <endfiniloop+0x30>)

0800022c <initloop>:
 800022c:	42ac      	cmp	r4, r5
 800022e:	f280 8005 	bge.w	800023c <endinitloop>
 8000232:	f854 1b04 	ldr.w	r1, [r4], #4
 8000236:	4788      	blx	r1
 8000238:	f7ff bff8 	b.w	800022c <initloop>

0800023c <endinitloop>:
 800023c:	f001 f840 	bl	80012c0 <main>
 8000240:	4c11      	ldr	r4, [pc, #68]	; (8000288 <endfiniloop+0x34>)
 8000242:	4d12      	ldr	r5, [pc, #72]	; (800028c <endfiniloop+0x38>)

08000244 <finiloop>:
 8000244:	42ac      	cmp	r4, r5
 8000246:	f280 8005 	bge.w	8000254 <endfiniloop>
 800024a:	f854 1b04 	ldr.w	r1, [r4], #4
 800024e:	4788      	blx	r1
 8000250:	f7ff bff8 	b.w	8000244 <finiloop>

08000254 <endfiniloop>:
 8000254:	f003 bce4 	b.w	8003c20 <__default_exit>
 8000258:	200036b0 	.word	0x200036b0
 800025c:	55555555 	.word	0x55555555
 8000260:	20000000 	.word	0x20000000
 8000264:	20001b58 	.word	0x20001b58
 8000268:	20001b58 	.word	0x20001b58
 800026c:	080059a0 	.word	0x080059a0
 8000270:	200036b0 	.word	0x200036b0
 8000274:	200036b0 	.word	0x200036b0
 8000278:	200036b0 	.word	0x200036b0
 800027c:	20004bec 	.word	0x20004bec
 8000280:	080001c0 	.word	0x080001c0
 8000284:	080001c0 	.word	0x080001c0
 8000288:	080001c0 	.word	0x080001c0
 800028c:	080001c0 	.word	0x080001c0

08000290 <_port_switch>:
 8000290:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000294:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000298:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 800029c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002a0 <_port_thread_start>:
 80002a0:	f003 ff96 	bl	80041d0 <_dbg_check_unlock>
 80002a4:	f002 fd34 	bl	8002d10 <_stats_stop_measure_crit_thd>
 80002a8:	2300      	movs	r3, #0
 80002aa:	f383 8811 	msr	BASEPRI, r3
 80002ae:	4628      	mov	r0, r5
 80002b0:	47a0      	blx	r4
 80002b2:	2000      	movs	r0, #0
 80002b4:	f004 ff24 	bl	8005100 <chThdExit>

080002b8 <_port_switch_from_isr>:
 80002b8:	f002 fd22 	bl	8002d00 <_stats_start_measure_crit_thd>
 80002bc:	f003 ff68 	bl	8004190 <_dbg_check_lock>
 80002c0:	f004 fd06 	bl	8004cd0 <chSchDoReschedule>
 80002c4:	f003 ff84 	bl	80041d0 <_dbg_check_unlock>
 80002c8:	f002 fd22 	bl	8002d10 <_stats_stop_measure_crit_thd>

080002cc <_port_exit_from_isr>:
 80002cc:	df00      	svc	0
 80002ce:	e7fe      	b.n	80002ce <_port_exit_from_isr+0x2>

080002d0 <memcpy>:
 80002d0:	2a0f      	cmp	r2, #15
 80002d2:	b4f0      	push	{r4, r5, r6, r7}
 80002d4:	d940      	bls.n	8000358 <memcpy+0x88>
 80002d6:	ea41 0300 	orr.w	r3, r1, r0
 80002da:	079b      	lsls	r3, r3, #30
 80002dc:	d13e      	bne.n	800035c <memcpy+0x8c>
 80002de:	460c      	mov	r4, r1
 80002e0:	4603      	mov	r3, r0
 80002e2:	4615      	mov	r5, r2
 80002e4:	6826      	ldr	r6, [r4, #0]
 80002e6:	3d10      	subs	r5, #16
 80002e8:	601e      	str	r6, [r3, #0]
 80002ea:	6866      	ldr	r6, [r4, #4]
 80002ec:	605e      	str	r6, [r3, #4]
 80002ee:	68a6      	ldr	r6, [r4, #8]
 80002f0:	609e      	str	r6, [r3, #8]
 80002f2:	68e6      	ldr	r6, [r4, #12]
 80002f4:	3410      	adds	r4, #16
 80002f6:	60de      	str	r6, [r3, #12]
 80002f8:	3310      	adds	r3, #16
 80002fa:	2d0f      	cmp	r5, #15
 80002fc:	d8f2      	bhi.n	80002e4 <memcpy+0x14>
 80002fe:	f1a2 0510 	sub.w	r5, r2, #16
 8000302:	f002 040f 	and.w	r4, r2, #15
 8000306:	f025 050f 	bic.w	r5, r5, #15
 800030a:	3510      	adds	r5, #16
 800030c:	2c03      	cmp	r4, #3
 800030e:	eb00 0305 	add.w	r3, r0, r5
 8000312:	4429      	add	r1, r5
 8000314:	d924      	bls.n	8000360 <memcpy+0x90>
 8000316:	f1a4 0c04 	sub.w	ip, r4, #4
 800031a:	461d      	mov	r5, r3
 800031c:	460c      	mov	r4, r1
 800031e:	ea4f 0c9c 	mov.w	ip, ip, lsr #2
 8000322:	eb01 078c 	add.w	r7, r1, ip, lsl #2
 8000326:	3704      	adds	r7, #4
 8000328:	f854 6b04 	ldr.w	r6, [r4], #4
 800032c:	42bc      	cmp	r4, r7
 800032e:	f845 6b04 	str.w	r6, [r5], #4
 8000332:	d1f9      	bne.n	8000328 <memcpy+0x58>
 8000334:	f10c 0401 	add.w	r4, ip, #1
 8000338:	f002 0203 	and.w	r2, r2, #3
 800033c:	00a4      	lsls	r4, r4, #2
 800033e:	1909      	adds	r1, r1, r4
 8000340:	191b      	adds	r3, r3, r4
 8000342:	b13a      	cbz	r2, 8000354 <memcpy+0x84>
 8000344:	3901      	subs	r1, #1
 8000346:	189a      	adds	r2, r3, r2
 8000348:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800034c:	f803 4b01 	strb.w	r4, [r3], #1
 8000350:	4293      	cmp	r3, r2
 8000352:	d1f9      	bne.n	8000348 <memcpy+0x78>
 8000354:	bcf0      	pop	{r4, r5, r6, r7}
 8000356:	4770      	bx	lr
 8000358:	4603      	mov	r3, r0
 800035a:	e7f2      	b.n	8000342 <memcpy+0x72>
 800035c:	4603      	mov	r3, r0
 800035e:	e7f1      	b.n	8000344 <memcpy+0x74>
 8000360:	4622      	mov	r2, r4
 8000362:	e7ee      	b.n	8000342 <memcpy+0x72>
	...

08000370 <memset>:
 8000370:	b470      	push	{r4, r5, r6}
 8000372:	0784      	lsls	r4, r0, #30
 8000374:	4603      	mov	r3, r0
 8000376:	d044      	beq.n	8000402 <memset+0x92>
 8000378:	1e54      	subs	r4, r2, #1
 800037a:	2a00      	cmp	r2, #0
 800037c:	d03f      	beq.n	80003fe <memset+0x8e>
 800037e:	b2ce      	uxtb	r6, r1
 8000380:	e002      	b.n	8000388 <memset+0x18>
 8000382:	2c00      	cmp	r4, #0
 8000384:	d03b      	beq.n	80003fe <memset+0x8e>
 8000386:	4614      	mov	r4, r2
 8000388:	f803 6b01 	strb.w	r6, [r3], #1
 800038c:	f013 0f03 	tst.w	r3, #3
 8000390:	461d      	mov	r5, r3
 8000392:	f104 32ff 	add.w	r2, r4, #4294967295
 8000396:	d1f4      	bne.n	8000382 <memset+0x12>
 8000398:	2c03      	cmp	r4, #3
 800039a:	d929      	bls.n	80003f0 <memset+0x80>
 800039c:	b2ca      	uxtb	r2, r1
 800039e:	2c0f      	cmp	r4, #15
 80003a0:	bf84      	itt	hi
 80003a2:	462b      	movhi	r3, r5
 80003a4:	4626      	movhi	r6, r4
 80003a6:	ea42 2202 	orr.w	r2, r2, r2, lsl #8
 80003aa:	ea42 4202 	orr.w	r2, r2, r2, lsl #16
 80003ae:	d911      	bls.n	80003d4 <memset+0x64>
 80003b0:	3e10      	subs	r6, #16
 80003b2:	601a      	str	r2, [r3, #0]
 80003b4:	605a      	str	r2, [r3, #4]
 80003b6:	609a      	str	r2, [r3, #8]
 80003b8:	60da      	str	r2, [r3, #12]
 80003ba:	3310      	adds	r3, #16
 80003bc:	2e0f      	cmp	r6, #15
 80003be:	d8f7      	bhi.n	80003b0 <memset+0x40>
 80003c0:	f1a4 0310 	sub.w	r3, r4, #16
 80003c4:	f004 040f 	and.w	r4, r4, #15
 80003c8:	f023 030f 	bic.w	r3, r3, #15
 80003cc:	3310      	adds	r3, #16
 80003ce:	2c03      	cmp	r4, #3
 80003d0:	441d      	add	r5, r3
 80003d2:	d90d      	bls.n	80003f0 <memset+0x80>
 80003d4:	462e      	mov	r6, r5
 80003d6:	4623      	mov	r3, r4
 80003d8:	3b04      	subs	r3, #4
 80003da:	f846 2b04 	str.w	r2, [r6], #4
 80003de:	2b03      	cmp	r3, #3
 80003e0:	d8fa      	bhi.n	80003d8 <memset+0x68>
 80003e2:	1f23      	subs	r3, r4, #4
 80003e4:	f004 0403 	and.w	r4, r4, #3
 80003e8:	f023 0303 	bic.w	r3, r3, #3
 80003ec:	3304      	adds	r3, #4
 80003ee:	18ed      	adds	r5, r5, r3
 80003f0:	b12c      	cbz	r4, 80003fe <memset+0x8e>
 80003f2:	b2c9      	uxtb	r1, r1
 80003f4:	192c      	adds	r4, r5, r4
 80003f6:	f805 1b01 	strb.w	r1, [r5], #1
 80003fa:	42a5      	cmp	r5, r4
 80003fc:	d1fb      	bne.n	80003f6 <memset+0x86>
 80003fe:	bc70      	pop	{r4, r5, r6}
 8000400:	4770      	bx	lr
 8000402:	4605      	mov	r5, r0
 8000404:	4614      	mov	r4, r2
 8000406:	e7c7      	b.n	8000398 <memset+0x28>
	...

08000410 <strlen>:
 8000410:	f020 0103 	bic.w	r1, r0, #3
 8000414:	f010 0003 	ands.w	r0, r0, #3
 8000418:	f1c0 0000 	rsb	r0, r0, #0
 800041c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000420:	f100 0c04 	add.w	ip, r0, #4
 8000424:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8000428:	f06f 0200 	mvn.w	r2, #0
 800042c:	bf1c      	itt	ne
 800042e:	fa22 f20c 	lsrne.w	r2, r2, ip
 8000432:	4313      	orrne	r3, r2
 8000434:	f04f 0c01 	mov.w	ip, #1
 8000438:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 800043c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8000440:	eba3 020c 	sub.w	r2, r3, ip
 8000444:	ea22 0203 	bic.w	r2, r2, r3
 8000448:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 800044c:	bf04      	itt	eq
 800044e:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000452:	3004      	addeq	r0, #4
 8000454:	d0f4      	beq.n	8000440 <strlen+0x30>
 8000456:	f013 0fff 	tst.w	r3, #255	; 0xff
 800045a:	bf1f      	itttt	ne
 800045c:	3001      	addne	r0, #1
 800045e:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 8000462:	3001      	addne	r0, #1
 8000464:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 8000468:	bf18      	it	ne
 800046a:	3001      	addne	r0, #1
 800046c:	4770      	bx	lr
 800046e:	bf00      	nop

08000470 <strncpy>:
 8000470:	ea41 0300 	orr.w	r3, r1, r0
 8000474:	f013 0f03 	tst.w	r3, #3
 8000478:	4603      	mov	r3, r0
 800047a:	b470      	push	{r4, r5, r6}
 800047c:	d025      	beq.n	80004ca <strncpy+0x5a>
 800047e:	b1aa      	cbz	r2, 80004ac <strncpy+0x3c>
 8000480:	780c      	ldrb	r4, [r1, #0]
 8000482:	3a01      	subs	r2, #1
 8000484:	f803 4b01 	strb.w	r4, [r3], #1
 8000488:	b14c      	cbz	r4, 800049e <strncpy+0x2e>
 800048a:	461c      	mov	r4, r3
 800048c:	b172      	cbz	r2, 80004ac <strncpy+0x3c>
 800048e:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 8000492:	3a01      	subs	r2, #1
 8000494:	f804 5b01 	strb.w	r5, [r4], #1
 8000498:	4623      	mov	r3, r4
 800049a:	2d00      	cmp	r5, #0
 800049c:	d1f6      	bne.n	800048c <strncpy+0x1c>
 800049e:	b12a      	cbz	r2, 80004ac <strncpy+0x3c>
 80004a0:	189a      	adds	r2, r3, r2
 80004a2:	2100      	movs	r1, #0
 80004a4:	f803 1b01 	strb.w	r1, [r3], #1
 80004a8:	4293      	cmp	r3, r2
 80004aa:	d1fb      	bne.n	80004a4 <strncpy+0x34>
 80004ac:	bc70      	pop	{r4, r5, r6}
 80004ae:	4770      	bx	lr
 80004b0:	460e      	mov	r6, r1
 80004b2:	f851 4b04 	ldr.w	r4, [r1], #4
 80004b6:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 80004ba:	ea25 0504 	bic.w	r5, r5, r4
 80004be:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 80004c2:	d105      	bne.n	80004d0 <strncpy+0x60>
 80004c4:	3a04      	subs	r2, #4
 80004c6:	f843 4b04 	str.w	r4, [r3], #4
 80004ca:	2a03      	cmp	r2, #3
 80004cc:	d8f0      	bhi.n	80004b0 <strncpy+0x40>
 80004ce:	e7d6      	b.n	800047e <strncpy+0xe>
 80004d0:	4631      	mov	r1, r6
 80004d2:	e7d4      	b.n	800047e <strncpy+0xe>
	...

080004e0 <ch_ltoa.10659.4111>:
  while (--i);

  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {
 80004e0:	b500      	push	{lr}
 80004e2:	b085      	sub	sp, #20
 80004e4:	9003      	str	r0, [sp, #12]
 80004e6:	9102      	str	r1, [sp, #8]
 80004e8:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 80004ea:	9803      	ldr	r0, [sp, #12]
 80004ec:	9902      	ldr	r1, [sp, #8]
 80004ee:	9a01      	ldr	r2, [sp, #4]
 80004f0:	f04f 0300 	mov.w	r3, #0
 80004f4:	f002 fb14 	bl	8002b20 <long_to_string_with_divisor.10651>
 80004f8:	4603      	mov	r3, r0
}
 80004fa:	4618      	mov	r0, r3
 80004fc:	b005      	add	sp, #20
 80004fe:	bd00      	pop	{pc}

08000500 <chvprintf.4103>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8000500:	b500      	push	{lr}
 8000502:	b091      	sub	sp, #68	; 0x44
 8000504:	9003      	str	r0, [sp, #12]
 8000506:	9102      	str	r1, [sp, #8]
 8000508:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 800050a:	f04f 0300 	mov.w	r3, #0
 800050e:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8000510:	9b02      	ldr	r3, [sp, #8]
 8000512:	781b      	ldrb	r3, [r3, #0]
 8000514:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8000518:	9b02      	ldr	r3, [sp, #8]
 800051a:	f103 0301 	add.w	r3, r3, #1
 800051e:	9302      	str	r3, [sp, #8]
    if (c == 0)
 8000520:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000524:	2b00      	cmp	r3, #0
 8000526:	d101      	bne.n	800052c <chvprintf.4103+0x2c>
      return n;
 8000528:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800052a:	e24f      	b.n	80009cc <chvprintf.4103+0x4cc>
    if (c != '%') {
 800052c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000530:	2b25      	cmp	r3, #37	; 0x25
 8000532:	d00c      	beq.n	800054e <chvprintf.4103+0x4e>
      chSequentialStreamPut(chp, (uint8_t)c);
 8000534:	9b03      	ldr	r3, [sp, #12]
 8000536:	681b      	ldr	r3, [r3, #0]
 8000538:	689b      	ldr	r3, [r3, #8]
 800053a:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 800053e:	9803      	ldr	r0, [sp, #12]
 8000540:	4611      	mov	r1, r2
 8000542:	4798      	blx	r3
      n++;
 8000544:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000546:	f103 0301 	add.w	r3, r3, #1
 800054a:	9309      	str	r3, [sp, #36]	; 0x24
    while (--i >= 0) {
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800054c:	e7e0      	b.n	8000510 <chvprintf.4103+0x10>
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 800054e:	ab04      	add	r3, sp, #16
 8000550:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 8000552:	ab04      	add	r3, sp, #16
 8000554:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 8000556:	f04f 0300 	mov.w	r3, #0
 800055a:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 800055e:	9b02      	ldr	r3, [sp, #8]
 8000560:	781b      	ldrb	r3, [r3, #0]
 8000562:	2b2d      	cmp	r3, #45	; 0x2d
 8000564:	d107      	bne.n	8000576 <chvprintf.4103+0x76>
      fmt++;
 8000566:	9b02      	ldr	r3, [sp, #8]
 8000568:	f103 0301 	add.w	r3, r3, #1
 800056c:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 800056e:	f04f 0301 	mov.w	r3, #1
 8000572:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
 8000576:	f04f 0320 	mov.w	r3, #32
 800057a:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 800057e:	9b02      	ldr	r3, [sp, #8]
 8000580:	781b      	ldrb	r3, [r3, #0]
 8000582:	2b30      	cmp	r3, #48	; 0x30
 8000584:	d107      	bne.n	8000596 <chvprintf.4103+0x96>
      fmt++;
 8000586:	9b02      	ldr	r3, [sp, #8]
 8000588:	f103 0301 	add.w	r3, r3, #1
 800058c:	9302      	str	r3, [sp, #8]
      filler = '0';
 800058e:	f04f 0330 	mov.w	r3, #48	; 0x30
 8000592:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    width = 0;
 8000596:	f04f 0300 	mov.w	r3, #0
 800059a:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 800059c:	9b02      	ldr	r3, [sp, #8]
 800059e:	781b      	ldrb	r3, [r3, #0]
 80005a0:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80005a4:	9b02      	ldr	r3, [sp, #8]
 80005a6:	f103 0301 	add.w	r3, r3, #1
 80005aa:	9302      	str	r3, [sp, #8]
      if (c >= '0' && c <= '9')
 80005ac:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005b0:	2b2f      	cmp	r3, #47	; 0x2f
 80005b2:	d90a      	bls.n	80005ca <chvprintf.4103+0xca>
 80005b4:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005b8:	2b39      	cmp	r3, #57	; 0x39
 80005ba:	d806      	bhi.n	80005ca <chvprintf.4103+0xca>
        c -= '0';
 80005bc:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005c0:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 80005c4:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80005c8:	e00a      	b.n	80005e0 <chvprintf.4103+0xe0>
      else if (c == '*')
 80005ca:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005ce:	2b2a      	cmp	r3, #42	; 0x2a
 80005d0:	d113      	bne.n	80005fa <chvprintf.4103+0xfa>
        c = va_arg(ap, int);
 80005d2:	9b01      	ldr	r3, [sp, #4]
 80005d4:	f103 0204 	add.w	r2, r3, #4
 80005d8:	9201      	str	r2, [sp, #4]
 80005da:	681b      	ldr	r3, [r3, #0]
 80005dc:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      else
        break;
      width = width * 10 + c;
 80005e0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80005e2:	4613      	mov	r3, r2
 80005e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80005e8:	189b      	adds	r3, r3, r2
 80005ea:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80005ee:	461a      	mov	r2, r3
 80005f0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005f4:	18d3      	adds	r3, r2, r3
 80005f6:	930a      	str	r3, [sp, #40]	; 0x28
 80005f8:	e7d0      	b.n	800059c <chvprintf.4103+0x9c>
    }
    precision = 0;
 80005fa:	f04f 0300 	mov.w	r3, #0
 80005fe:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 8000600:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000604:	2b2e      	cmp	r3, #46	; 0x2e
 8000606:	d12f      	bne.n	8000668 <chvprintf.4103+0x168>
      while (TRUE) {
        c = *fmt++;
 8000608:	9b02      	ldr	r3, [sp, #8]
 800060a:	781b      	ldrb	r3, [r3, #0]
 800060c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8000610:	9b02      	ldr	r3, [sp, #8]
 8000612:	f103 0301 	add.w	r3, r3, #1
 8000616:	9302      	str	r3, [sp, #8]
        if (c >= '0' && c <= '9')
 8000618:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800061c:	2b2f      	cmp	r3, #47	; 0x2f
 800061e:	d90a      	bls.n	8000636 <chvprintf.4103+0x136>
 8000620:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000624:	2b39      	cmp	r3, #57	; 0x39
 8000626:	d806      	bhi.n	8000636 <chvprintf.4103+0x136>
          c -= '0';
 8000628:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800062c:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 8000630:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8000634:	e00a      	b.n	800064c <chvprintf.4103+0x14c>
        else if (c == '*')
 8000636:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800063a:	2b2a      	cmp	r3, #42	; 0x2a
 800063c:	d114      	bne.n	8000668 <chvprintf.4103+0x168>
          c = va_arg(ap, int);
 800063e:	9b01      	ldr	r3, [sp, #4]
 8000640:	f103 0204 	add.w	r2, r3, #4
 8000644:	9201      	str	r2, [sp, #4]
 8000646:	681b      	ldr	r3, [r3, #0]
 8000648:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        else
          break;
        precision *= 10;
 800064c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800064e:	4613      	mov	r3, r2
 8000650:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000654:	189b      	adds	r3, r3, r2
 8000656:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800065a:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 800065c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000660:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8000662:	18d3      	adds	r3, r2, r3
 8000664:	930b      	str	r3, [sp, #44]	; 0x2c
 8000666:	e7cf      	b.n	8000608 <chvprintf.4103+0x108>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8000668:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800066c:	2b6c      	cmp	r3, #108	; 0x6c
 800066e:	d003      	beq.n	8000678 <chvprintf.4103+0x178>
 8000670:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000674:	2b4c      	cmp	r3, #76	; 0x4c
 8000676:	d110      	bne.n	800069a <chvprintf.4103+0x19a>
      is_long = TRUE;
 8000678:	f04f 0301 	mov.w	r3, #1
 800067c:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      if (*fmt)
 8000680:	9b02      	ldr	r3, [sp, #8]
 8000682:	781b      	ldrb	r3, [r3, #0]
 8000684:	2b00      	cmp	r3, #0
 8000686:	d01e      	beq.n	80006c6 <chvprintf.4103+0x1c6>
        c = *fmt++;
 8000688:	9b02      	ldr	r3, [sp, #8]
 800068a:	781b      	ldrb	r3, [r3, #0]
 800068c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8000690:	9b02      	ldr	r3, [sp, #8]
 8000692:	f103 0301 	add.w	r3, r3, #1
 8000696:	9302      	str	r3, [sp, #8]
 8000698:	e016      	b.n	80006c8 <chvprintf.4103+0x1c8>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 800069a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800069e:	2b40      	cmp	r3, #64	; 0x40
 80006a0:	d906      	bls.n	80006b0 <chvprintf.4103+0x1b0>
 80006a2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80006a6:	2b5a      	cmp	r3, #90	; 0x5a
 80006a8:	d802      	bhi.n	80006b0 <chvprintf.4103+0x1b0>
 80006aa:	f04f 0301 	mov.w	r3, #1
 80006ae:	e001      	b.n	80006b4 <chvprintf.4103+0x1b4>
 80006b0:	f04f 0300 	mov.w	r3, #0
 80006b4:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 80006b8:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80006bc:	f003 0301 	and.w	r3, r3, #1
 80006c0:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 80006c4:	e000      	b.n	80006c8 <chvprintf.4103+0x1c8>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 80006c6:	bf00      	nop
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80006c8:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80006cc:	f1a3 0344 	sub.w	r3, r3, #68	; 0x44
 80006d0:	2b34      	cmp	r3, #52	; 0x34
 80006d2:	f200 80f9 	bhi.w	80008c8 <chvprintf.4103+0x3c8>
 80006d6:	a201      	add	r2, pc, #4	; (adr r2, 80006dc <chvprintf.4103+0x1dc>)
 80006d8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80006dc:	08000829 	.word	0x08000829
 80006e0:	080008c9 	.word	0x080008c9
 80006e4:	080008c9 	.word	0x080008c9
 80006e8:	080008c9 	.word	0x080008c9
 80006ec:	080008c9 	.word	0x080008c9
 80006f0:	08000829 	.word	0x08000829
 80006f4:	080008c9 	.word	0x080008c9
 80006f8:	080008c9 	.word	0x080008c9
 80006fc:	080008c9 	.word	0x080008c9
 8000700:	080008c9 	.word	0x080008c9
 8000704:	080008c9 	.word	0x080008c9
 8000708:	0800088d 	.word	0x0800088d
 800070c:	080008c9 	.word	0x080008c9
 8000710:	080008c9 	.word	0x080008c9
 8000714:	080008c9 	.word	0x080008c9
 8000718:	080008c9 	.word	0x080008c9
 800071c:	080008c9 	.word	0x080008c9
 8000720:	08000883 	.word	0x08000883
 8000724:	080008c9 	.word	0x080008c9
 8000728:	080008c9 	.word	0x080008c9
 800072c:	08000879 	.word	0x08000879
 8000730:	080008c9 	.word	0x080008c9
 8000734:	080008c9 	.word	0x080008c9
 8000738:	080008c9 	.word	0x080008c9
 800073c:	080008c9 	.word	0x080008c9
 8000740:	080008c9 	.word	0x080008c9
 8000744:	080008c9 	.word	0x080008c9
 8000748:	080008c9 	.word	0x080008c9
 800074c:	080008c9 	.word	0x080008c9
 8000750:	080008c9 	.word	0x080008c9
 8000754:	080008c9 	.word	0x080008c9
 8000758:	080007b1 	.word	0x080007b1
 800075c:	08000829 	.word	0x08000829
 8000760:	080008c9 	.word	0x080008c9
 8000764:	080008c9 	.word	0x080008c9
 8000768:	080008c9 	.word	0x080008c9
 800076c:	080008c9 	.word	0x080008c9
 8000770:	08000829 	.word	0x08000829
 8000774:	080008c9 	.word	0x080008c9
 8000778:	080008c9 	.word	0x080008c9
 800077c:	080008c9 	.word	0x080008c9
 8000780:	080008c9 	.word	0x080008c9
 8000784:	080008c9 	.word	0x080008c9
 8000788:	0800088d 	.word	0x0800088d
 800078c:	080008c9 	.word	0x080008c9
 8000790:	080008c9 	.word	0x080008c9
 8000794:	080008c9 	.word	0x080008c9
 8000798:	080007d3 	.word	0x080007d3
 800079c:	080008c9 	.word	0x080008c9
 80007a0:	08000883 	.word	0x08000883
 80007a4:	080008c9 	.word	0x080008c9
 80007a8:	080008c9 	.word	0x080008c9
 80007ac:	08000879 	.word	0x08000879
    case 'c':
      filler = ' ';
 80007b0:	f04f 0320 	mov.w	r3, #32
 80007b4:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 80007b8:	9b01      	ldr	r3, [sp, #4]
 80007ba:	f103 0204 	add.w	r2, r3, #4
 80007be:	9201      	str	r2, [sp, #4]
 80007c0:	681b      	ldr	r3, [r3, #0]
 80007c2:	b2da      	uxtb	r2, r3
 80007c4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80007c6:	701a      	strb	r2, [r3, #0]
 80007c8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80007ca:	f103 0301 	add.w	r3, r3, #1
 80007ce:	930f      	str	r3, [sp, #60]	; 0x3c
 80007d0:	e082      	b.n	80008d8 <chvprintf.4103+0x3d8>
      break;
    case 's':
      filler = ' ';
 80007d2:	f04f 0320 	mov.w	r3, #32
 80007d6:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 80007da:	9b01      	ldr	r3, [sp, #4]
 80007dc:	f103 0204 	add.w	r2, r3, #4
 80007e0:	9201      	str	r2, [sp, #4]
 80007e2:	681b      	ldr	r3, [r3, #0]
 80007e4:	930e      	str	r3, [sp, #56]	; 0x38
 80007e6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80007e8:	2b00      	cmp	r3, #0
 80007ea:	d104      	bne.n	80007f6 <chvprintf.4103+0x2f6>
        s = "(null)";
 80007ec:	f245 3310 	movw	r3, #21264	; 0x5310
 80007f0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80007f4:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 80007f6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80007f8:	2b00      	cmp	r3, #0
 80007fa:	d102      	bne.n	8000802 <chvprintf.4103+0x302>
        precision = 32767;
 80007fc:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8000800:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 8000802:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000804:	930f      	str	r3, [sp, #60]	; 0x3c
 8000806:	e003      	b.n	8000810 <chvprintf.4103+0x310>
 8000808:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800080a:	f103 0301 	add.w	r3, r3, #1
 800080e:	930f      	str	r3, [sp, #60]	; 0x3c
 8000810:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000812:	781b      	ldrb	r3, [r3, #0]
 8000814:	2b00      	cmp	r3, #0
 8000816:	d05f      	beq.n	80008d8 <chvprintf.4103+0x3d8>
 8000818:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800081a:	f103 33ff 	add.w	r3, r3, #4294967295
 800081e:	930b      	str	r3, [sp, #44]	; 0x2c
 8000820:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8000822:	2b00      	cmp	r3, #0
 8000824:	daf0      	bge.n	8000808 <chvprintf.4103+0x308>
 8000826:	e057      	b.n	80008d8 <chvprintf.4103+0x3d8>
      break;
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 8000828:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 800082c:	2b00      	cmp	r3, #0
 800082e:	d006      	beq.n	800083e <chvprintf.4103+0x33e>
        l = va_arg(ap, long);
 8000830:	9b01      	ldr	r3, [sp, #4]
 8000832:	f103 0204 	add.w	r2, r3, #4
 8000836:	9201      	str	r2, [sp, #4]
 8000838:	681b      	ldr	r3, [r3, #0]
 800083a:	9307      	str	r3, [sp, #28]
 800083c:	e005      	b.n	800084a <chvprintf.4103+0x34a>
      else
        l = va_arg(ap, int);
 800083e:	9b01      	ldr	r3, [sp, #4]
 8000840:	f103 0204 	add.w	r2, r3, #4
 8000844:	9201      	str	r2, [sp, #4]
 8000846:	681b      	ldr	r3, [r3, #0]
 8000848:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 800084a:	9b07      	ldr	r3, [sp, #28]
 800084c:	2b00      	cmp	r3, #0
 800084e:	da0b      	bge.n	8000868 <chvprintf.4103+0x368>
        *p++ = '-';
 8000850:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000852:	f04f 022d 	mov.w	r2, #45	; 0x2d
 8000856:	701a      	strb	r2, [r3, #0]
 8000858:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800085a:	f103 0301 	add.w	r3, r3, #1
 800085e:	930f      	str	r3, [sp, #60]	; 0x3c
        l = -l;
 8000860:	9b07      	ldr	r3, [sp, #28]
 8000862:	f1c3 0300 	rsb	r3, r3, #0
 8000866:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 8000868:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800086a:	9907      	ldr	r1, [sp, #28]
 800086c:	f04f 020a 	mov.w	r2, #10
 8000870:	f7ff fe36 	bl	80004e0 <ch_ltoa.10659.4111>
 8000874:	900f      	str	r0, [sp, #60]	; 0x3c
 8000876:	e02f      	b.n	80008d8 <chvprintf.4103+0x3d8>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 8000878:	f04f 0310 	mov.w	r3, #16
 800087c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8000880:	e008      	b.n	8000894 <chvprintf.4103+0x394>
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
 8000882:	f04f 030a 	mov.w	r3, #10
 8000886:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800088a:	e003      	b.n	8000894 <chvprintf.4103+0x394>
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 800088c:	f04f 0308 	mov.w	r3, #8
 8000890:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
 8000894:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8000898:	2b00      	cmp	r3, #0
 800089a:	d006      	beq.n	80008aa <chvprintf.4103+0x3aa>
        l = va_arg(ap, unsigned long);
 800089c:	9b01      	ldr	r3, [sp, #4]
 800089e:	f103 0204 	add.w	r2, r3, #4
 80008a2:	9201      	str	r2, [sp, #4]
 80008a4:	681b      	ldr	r3, [r3, #0]
 80008a6:	9307      	str	r3, [sp, #28]
 80008a8:	e005      	b.n	80008b6 <chvprintf.4103+0x3b6>
      else
        l = va_arg(ap, unsigned int);
 80008aa:	9b01      	ldr	r3, [sp, #4]
 80008ac:	f103 0204 	add.w	r2, r3, #4
 80008b0:	9201      	str	r2, [sp, #4]
 80008b2:	681b      	ldr	r3, [r3, #0]
 80008b4:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 80008b6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80008ba:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80008bc:	9907      	ldr	r1, [sp, #28]
 80008be:	461a      	mov	r2, r3
 80008c0:	f7ff fe0e 	bl	80004e0 <ch_ltoa.10659.4111>
 80008c4:	900f      	str	r0, [sp, #60]	; 0x3c
 80008c6:	e007      	b.n	80008d8 <chvprintf.4103+0x3d8>
      break;
    default:
      *p++ = c;
 80008c8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80008ca:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 80008ce:	701a      	strb	r2, [r3, #0]
 80008d0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80008d2:	f103 0301 	add.w	r3, r3, #1
 80008d6:	930f      	str	r3, [sp, #60]	; 0x3c
      break;
    }
    i = (int)(p - s);
 80008d8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80008da:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80008dc:	1ad3      	subs	r3, r2, r3
 80008de:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 80008e0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80008e2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80008e4:	1ad3      	subs	r3, r2, r3
 80008e6:	930a      	str	r3, [sp, #40]	; 0x28
 80008e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80008ea:	2b00      	cmp	r3, #0
 80008ec:	da02      	bge.n	80008f4 <chvprintf.4103+0x3f4>
      width = 0;
 80008ee:	f04f 0300 	mov.w	r3, #0
 80008f2:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 80008f4:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 80008f8:	f083 0301 	eor.w	r3, r3, #1
 80008fc:	b2db      	uxtb	r3, r3
 80008fe:	2b00      	cmp	r3, #0
 8000900:	d003      	beq.n	800090a <chvprintf.4103+0x40a>
      width = -width;
 8000902:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000904:	f1c3 0300 	rsb	r3, r3, #0
 8000908:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 800090a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800090c:	2b00      	cmp	r3, #0
 800090e:	da40      	bge.n	8000992 <chvprintf.4103+0x492>
      if (*s == '-' && filler == '0') {
 8000910:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000912:	781b      	ldrb	r3, [r3, #0]
 8000914:	2b2d      	cmp	r3, #45	; 0x2d
 8000916:	d117      	bne.n	8000948 <chvprintf.4103+0x448>
 8000918:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 800091c:	2b30      	cmp	r3, #48	; 0x30
 800091e:	d113      	bne.n	8000948 <chvprintf.4103+0x448>
        chSequentialStreamPut(chp, (uint8_t)*s++);
 8000920:	9b03      	ldr	r3, [sp, #12]
 8000922:	681b      	ldr	r3, [r3, #0]
 8000924:	689b      	ldr	r3, [r3, #8]
 8000926:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8000928:	7812      	ldrb	r2, [r2, #0]
 800092a:	990e      	ldr	r1, [sp, #56]	; 0x38
 800092c:	f101 0101 	add.w	r1, r1, #1
 8000930:	910e      	str	r1, [sp, #56]	; 0x38
 8000932:	9803      	ldr	r0, [sp, #12]
 8000934:	4611      	mov	r1, r2
 8000936:	4798      	blx	r3
        n++;
 8000938:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800093a:	f103 0301 	add.w	r3, r3, #1
 800093e:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 8000940:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000942:	f103 33ff 	add.w	r3, r3, #4294967295
 8000946:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
 8000948:	9b03      	ldr	r3, [sp, #12]
 800094a:	681b      	ldr	r3, [r3, #0]
 800094c:	689b      	ldr	r3, [r3, #8]
 800094e:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 8000952:	9803      	ldr	r0, [sp, #12]
 8000954:	4611      	mov	r1, r2
 8000956:	4798      	blx	r3
        n++;
 8000958:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800095a:	f103 0301 	add.w	r3, r3, #1
 800095e:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 8000960:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000962:	f103 0301 	add.w	r3, r3, #1
 8000966:	930a      	str	r3, [sp, #40]	; 0x28
 8000968:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800096a:	2b00      	cmp	r3, #0
 800096c:	d1ec      	bne.n	8000948 <chvprintf.4103+0x448>
 800096e:	e010      	b.n	8000992 <chvprintf.4103+0x492>
    }
    while (--i >= 0) {
      chSequentialStreamPut(chp, (uint8_t)*s++);
 8000970:	9b03      	ldr	r3, [sp, #12]
 8000972:	681b      	ldr	r3, [r3, #0]
 8000974:	689b      	ldr	r3, [r3, #8]
 8000976:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8000978:	7812      	ldrb	r2, [r2, #0]
 800097a:	990e      	ldr	r1, [sp, #56]	; 0x38
 800097c:	f101 0101 	add.w	r1, r1, #1
 8000980:	910e      	str	r1, [sp, #56]	; 0x38
 8000982:	9803      	ldr	r0, [sp, #12]
 8000984:	4611      	mov	r1, r2
 8000986:	4798      	blx	r3
      n++;
 8000988:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800098a:	f103 0301 	add.w	r3, r3, #1
 800098e:	9309      	str	r3, [sp, #36]	; 0x24
 8000990:	e000      	b.n	8000994 <chvprintf.4103+0x494>
        i--;
      }
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
 8000992:	bf00      	nop
    }
    while (--i >= 0) {
 8000994:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000996:	f103 33ff 	add.w	r3, r3, #4294967295
 800099a:	930c      	str	r3, [sp, #48]	; 0x30
 800099c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800099e:	2b00      	cmp	r3, #0
 80009a0:	dae6      	bge.n	8000970 <chvprintf.4103+0x470>
 80009a2:	e00f      	b.n	80009c4 <chvprintf.4103+0x4c4>
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      chSequentialStreamPut(chp, (uint8_t)filler);
 80009a4:	9b03      	ldr	r3, [sp, #12]
 80009a6:	681b      	ldr	r3, [r3, #0]
 80009a8:	689b      	ldr	r3, [r3, #8]
 80009aa:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 80009ae:	9803      	ldr	r0, [sp, #12]
 80009b0:	4611      	mov	r1, r2
 80009b2:	4798      	blx	r3
      n++;
 80009b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80009b6:	f103 0301 	add.w	r3, r3, #1
 80009ba:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 80009bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80009be:	f103 33ff 	add.w	r3, r3, #4294967295
 80009c2:	930a      	str	r3, [sp, #40]	; 0x28
    while (--i >= 0) {
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80009c4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80009c6:	2b00      	cmp	r3, #0
 80009c8:	d1ec      	bne.n	80009a4 <chvprintf.4103+0x4a4>
 80009ca:	e5a1      	b.n	8000510 <chvprintf.4103+0x10>
      chSequentialStreamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 80009cc:	4618      	mov	r0, r3
 80009ce:	b011      	add	sp, #68	; 0x44
 80009d0:	bd00      	pop	{pc}
 80009d2:	bf00      	nop
 80009d4:	f3af 8000 	nop.w
 80009d8:	f3af 8000 	nop.w
 80009dc:	f3af 8000 	nop.w

080009e0 <chprintf.10715.4099>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80009e0:	b40e      	push	{r1, r2, r3}
 80009e2:	b500      	push	{lr}
 80009e4:	b084      	sub	sp, #16
 80009e6:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80009e8:	ab06      	add	r3, sp, #24
 80009ea:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80009ec:	9801      	ldr	r0, [sp, #4]
 80009ee:	9905      	ldr	r1, [sp, #20]
 80009f0:	9a02      	ldr	r2, [sp, #8]
 80009f2:	f7ff fd85 	bl	8000500 <chvprintf.4103>
 80009f6:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 80009f8:	9b03      	ldr	r3, [sp, #12]
}
 80009fa:	4618      	mov	r0, r3
 80009fc:	b004      	add	sp, #16
 80009fe:	f85d eb04 	ldr.w	lr, [sp], #4
 8000a02:	b003      	add	sp, #12
 8000a04:	4770      	bx	lr
 8000a06:	bf00      	nop
 8000a08:	f3af 8000 	nop.w
 8000a0c:	f3af 8000 	nop.w

08000a10 <init_packet.4096>:
 *  init_packet(Packet* pkt)
 *  
 *  Initializes a packet datastructure in the address pointed by pkt.
 */
void init_packet(Packet* pkt)
{
 8000a10:	b500      	push	{lr}
 8000a12:	b085      	sub	sp, #20
 8000a14:	9001      	str	r0, [sp, #4]
  int i;

  memset(pkt->source_address, 32, (ADDRESS_LENGTH - 1) * sizeof(char));
 8000a16:	9b01      	ldr	r3, [sp, #4]
 8000a18:	4618      	mov	r0, r3
 8000a1a:	f04f 0120 	mov.w	r1, #32
 8000a1e:	f04f 0206 	mov.w	r2, #6
 8000a22:	f7ff fca5 	bl	8000370 <memset>
  pkt->source_address[(ADDRESS_LENGTH - 1)] = 0x00;
 8000a26:	9b01      	ldr	r3, [sp, #4]
 8000a28:	f04f 0200 	mov.w	r2, #0
 8000a2c:	719a      	strb	r2, [r3, #6]

  memset(pkt->destination_address, 32, (ADDRESS_LENGTH - 1) * sizeof(char));
 8000a2e:	9b01      	ldr	r3, [sp, #4]
 8000a30:	f103 0307 	add.w	r3, r3, #7
 8000a34:	4618      	mov	r0, r3
 8000a36:	f04f 0120 	mov.w	r1, #32
 8000a3a:	f04f 0206 	mov.w	r2, #6
 8000a3e:	f7ff fc97 	bl	8000370 <memset>
  pkt->destination_address[(ADDRESS_LENGTH - 1)] = 0x00;
 8000a42:	9b01      	ldr	r3, [sp, #4]
 8000a44:	f04f 0200 	mov.w	r2, #0
 8000a48:	735a      	strb	r2, [r3, #13]
  
  for (i = 0; i < MAX_DIGIPEATERS; i++)
 8000a4a:	f04f 0300 	mov.w	r3, #0
 8000a4e:	9303      	str	r3, [sp, #12]
 8000a50:	e021      	b.n	8000a96 <init_packet.4096+0x86>
  {  
    memset(pkt->digipeaters[i], 32, (ADDRESS_LENGTH - 1) * sizeof(char));
 8000a52:	9a03      	ldr	r2, [sp, #12]
 8000a54:	4613      	mov	r3, r2
 8000a56:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000a5a:	1a9b      	subs	r3, r3, r2
 8000a5c:	f103 0308 	add.w	r3, r3, #8
 8000a60:	9a01      	ldr	r2, [sp, #4]
 8000a62:	18d3      	adds	r3, r2, r3
 8000a64:	f103 0306 	add.w	r3, r3, #6
 8000a68:	4618      	mov	r0, r3
 8000a6a:	f04f 0120 	mov.w	r1, #32
 8000a6e:	f04f 0206 	mov.w	r2, #6
 8000a72:	f7ff fc7d 	bl	8000370 <memset>
    pkt->digipeaters[i][(ADDRESS_LENGTH - 1)] = 0x00;
 8000a76:	9901      	ldr	r1, [sp, #4]
 8000a78:	9a03      	ldr	r2, [sp, #12]
 8000a7a:	4613      	mov	r3, r2
 8000a7c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000a80:	1a9b      	subs	r3, r3, r2
 8000a82:	18cb      	adds	r3, r1, r3
 8000a84:	f103 030e 	add.w	r3, r3, #14
 8000a88:	f04f 0200 	mov.w	r2, #0
 8000a8c:	719a      	strb	r2, [r3, #6]
  pkt->source_address[(ADDRESS_LENGTH - 1)] = 0x00;

  memset(pkt->destination_address, 32, (ADDRESS_LENGTH - 1) * sizeof(char));
  pkt->destination_address[(ADDRESS_LENGTH - 1)] = 0x00;
  
  for (i = 0; i < MAX_DIGIPEATERS; i++)
 8000a8e:	9b03      	ldr	r3, [sp, #12]
 8000a90:	f103 0301 	add.w	r3, r3, #1
 8000a94:	9303      	str	r3, [sp, #12]
 8000a96:	9b03      	ldr	r3, [sp, #12]
 8000a98:	2b07      	cmp	r3, #7
 8000a9a:	ddda      	ble.n	8000a52 <init_packet.4096+0x42>
  {  
    memset(pkt->digipeaters[i], 32, (ADDRESS_LENGTH - 1) * sizeof(char));
    pkt->digipeaters[i][(ADDRESS_LENGTH - 1)] = 0x00;
  }
  pkt->num_digipeaters = 0;
 8000a9c:	9b01      	ldr	r3, [sp, #4]
 8000a9e:	f04f 0200 	mov.w	r2, #0
 8000aa2:	649a      	str	r2, [r3, #72]	; 0x48

  pkt->control_field = 0x30;
 8000aa4:	9b01      	ldr	r3, [sp, #4]
 8000aa6:	f04f 0230 	mov.w	r2, #48	; 0x30
 8000aaa:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  pkt->pid = 0xF0;
 8000aae:	9b01      	ldr	r3, [sp, #4]
 8000ab0:	f04f 02f0 	mov.w	r2, #240	; 0xf0
 8000ab4:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
  
  memset(pkt->payload, 0, PAYLOAD_LENGTH * sizeof(char));
 8000ab8:	9b01      	ldr	r3, [sp, #4]
 8000aba:	f103 034e 	add.w	r3, r3, #78	; 0x4e
 8000abe:	4618      	mov	r0, r3
 8000ac0:	f04f 0100 	mov.w	r1, #0
 8000ac4:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000ac8:	f7ff fc52 	bl	8000370 <memset>
  pkt->payload_length = 0;
 8000acc:	9b01      	ldr	r3, [sp, #4]
 8000ace:	f04f 0200 	mov.w	r2, #0
 8000ad2:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
}
 8000ad6:	b005      	add	sp, #20
 8000ad8:	bd00      	pop	{pc}
 8000ada:	bf00      	nop
 8000adc:	f3af 8000 	nop.w

08000ae0 <init_queue.4093>:
 *  init_queue(Queue* queue)
 *  
 *  Initializes a packet queue data structure in the address pointed by queue.
 */
void init_queue(Queue* queue)
{
 8000ae0:	b500      	push	{lr}
 8000ae2:	b083      	sub	sp, #12
 8000ae4:	9001      	str	r0, [sp, #4]
  queue->front = -1;
 8000ae6:	9b01      	ldr	r3, [sp, #4]
 8000ae8:	f04f 32ff 	mov.w	r2, #4294967295
 8000aec:	601a      	str	r2, [r3, #0]
  queue->rear = -1;
 8000aee:	9b01      	ldr	r3, [sp, #4]
 8000af0:	f04f 32ff 	mov.w	r2, #4294967295
 8000af4:	605a      	str	r2, [r3, #4]
  memset(queue->packet_queue, 0, MAX_QUEUE_LENGTH * sizeof(Packet));  
 8000af6:	9b01      	ldr	r3, [sp, #4]
 8000af8:	f103 0308 	add.w	r3, r3, #8
 8000afc:	4618      	mov	r0, r3
 8000afe:	f04f 0100 	mov.w	r1, #0
 8000b02:	f640 5248 	movw	r2, #3400	; 0xd48
 8000b06:	f7ff fc33 	bl	8000370 <memset>
}
 8000b0a:	b003      	add	sp, #12
 8000b0c:	bd00      	pop	{pc}
 8000b0e:	bf00      	nop

08000b10 <get_packet_source.4088>:
 *  get_packet_source(Packet* pkt, char* callsign, char* ssid)
 *  
 *  Get the address of the source for the given packet.
 */
void get_packet_source(Packet* pkt, char* callsign, char* ssid)
{
 8000b10:	b086      	sub	sp, #24
 8000b12:	9003      	str	r0, [sp, #12]
 8000b14:	9102      	str	r1, [sp, #8]
 8000b16:	9201      	str	r2, [sp, #4]
  int i;

  for (i = 0; i < (ADDRESS_LENGTH - 1); i++)
 8000b18:	f04f 0300 	mov.w	r3, #0
 8000b1c:	9305      	str	r3, [sp, #20]
 8000b1e:	e00e      	b.n	8000b3e <get_packet_source.4088+0x2e>
    callsign[i] = (pkt->source_address[i] >> 1) & 0x7f;
 8000b20:	9b05      	ldr	r3, [sp, #20]
 8000b22:	9a02      	ldr	r2, [sp, #8]
 8000b24:	18d3      	adds	r3, r2, r3
 8000b26:	9903      	ldr	r1, [sp, #12]
 8000b28:	9a05      	ldr	r2, [sp, #20]
 8000b2a:	188a      	adds	r2, r1, r2
 8000b2c:	7812      	ldrb	r2, [r2, #0]
 8000b2e:	ea4f 0252 	mov.w	r2, r2, lsr #1
 8000b32:	b2d2      	uxtb	r2, r2
 8000b34:	701a      	strb	r2, [r3, #0]
 */
void get_packet_source(Packet* pkt, char* callsign, char* ssid)
{
  int i;

  for (i = 0; i < (ADDRESS_LENGTH - 1); i++)
 8000b36:	9b05      	ldr	r3, [sp, #20]
 8000b38:	f103 0301 	add.w	r3, r3, #1
 8000b3c:	9305      	str	r3, [sp, #20]
 8000b3e:	9b05      	ldr	r3, [sp, #20]
 8000b40:	2b05      	cmp	r3, #5
 8000b42:	dded      	ble.n	8000b20 <get_packet_source.4088+0x10>
    callsign[i] = (pkt->source_address[i] >> 1) & 0x7f;

  *ssid = (pkt->source_address[ADDRESS_LENGTH - 1] >> 1) & 0x0f;
 8000b44:	9b03      	ldr	r3, [sp, #12]
 8000b46:	799b      	ldrb	r3, [r3, #6]
 8000b48:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8000b4c:	b2db      	uxtb	r3, r3
 8000b4e:	f003 030f 	and.w	r3, r3, #15
 8000b52:	b2da      	uxtb	r2, r3
 8000b54:	9b01      	ldr	r3, [sp, #4]
 8000b56:	701a      	strb	r2, [r3, #0]
}
 8000b58:	b006      	add	sp, #24
 8000b5a:	4770      	bx	lr
 8000b5c:	f3af 8000 	nop.w

08000b60 <get_packet_destination.4083>:
 *  get_packet_destination(Packet* pkt, char* callsign, char* ssid)
 *  
 *  Get the address of the destination for the given packet.
 */
void get_packet_destination(Packet* pkt, char* callsign, char* ssid)
{
 8000b60:	b086      	sub	sp, #24
 8000b62:	9003      	str	r0, [sp, #12]
 8000b64:	9102      	str	r1, [sp, #8]
 8000b66:	9201      	str	r2, [sp, #4]
  int i;

  for (i = 0; i < (ADDRESS_LENGTH - 1); i++)
 8000b68:	f04f 0300 	mov.w	r3, #0
 8000b6c:	9305      	str	r3, [sp, #20]
 8000b6e:	e00e      	b.n	8000b8e <get_packet_destination.4083+0x2e>
    callsign[i] = (pkt->destination_address[i] >> 1) & 0x7f;
 8000b70:	9b05      	ldr	r3, [sp, #20]
 8000b72:	9a02      	ldr	r2, [sp, #8]
 8000b74:	18d3      	adds	r3, r2, r3
 8000b76:	9903      	ldr	r1, [sp, #12]
 8000b78:	9a05      	ldr	r2, [sp, #20]
 8000b7a:	188a      	adds	r2, r1, r2
 8000b7c:	79d2      	ldrb	r2, [r2, #7]
 8000b7e:	ea4f 0252 	mov.w	r2, r2, lsr #1
 8000b82:	b2d2      	uxtb	r2, r2
 8000b84:	701a      	strb	r2, [r3, #0]
 */
void get_packet_destination(Packet* pkt, char* callsign, char* ssid)
{
  int i;

  for (i = 0; i < (ADDRESS_LENGTH - 1); i++)
 8000b86:	9b05      	ldr	r3, [sp, #20]
 8000b88:	f103 0301 	add.w	r3, r3, #1
 8000b8c:	9305      	str	r3, [sp, #20]
 8000b8e:	9b05      	ldr	r3, [sp, #20]
 8000b90:	2b05      	cmp	r3, #5
 8000b92:	dded      	ble.n	8000b70 <get_packet_destination.4083+0x10>
    callsign[i] = (pkt->destination_address[i] >> 1) & 0x7f;

  *ssid = (pkt->destination_address[ADDRESS_LENGTH - 1] >> 1) & 0x0f;
 8000b94:	9b03      	ldr	r3, [sp, #12]
 8000b96:	7b5b      	ldrb	r3, [r3, #13]
 8000b98:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8000b9c:	b2db      	uxtb	r3, r3
 8000b9e:	f003 030f 	and.w	r3, r3, #15
 8000ba2:	b2da      	uxtb	r2, r3
 8000ba4:	9b01      	ldr	r3, [sp, #4]
 8000ba6:	701a      	strb	r2, [r3, #0]
}
 8000ba8:	b006      	add	sp, #24
 8000baa:	4770      	bx	lr
 8000bac:	f3af 8000 	nop.w

08000bb0 <get_packet_digipeater.4077>:
 *  
 *  Returns 1 for the last digipeater, 0 for all others.
 *  If n is greater than the number of digipeaters available -1 is returned.
 */
int get_packet_digipeater(Packet* pkt, int n, char* callsign, char* ssid)
{
 8000bb0:	b086      	sub	sp, #24
 8000bb2:	9003      	str	r0, [sp, #12]
 8000bb4:	9102      	str	r1, [sp, #8]
 8000bb6:	9201      	str	r2, [sp, #4]
 8000bb8:	9300      	str	r3, [sp, #0]
  int i;

  if (n > pkt->num_digipeaters) return -1;
 8000bba:	9b03      	ldr	r3, [sp, #12]
 8000bbc:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8000bbe:	9b02      	ldr	r3, [sp, #8]
 8000bc0:	429a      	cmp	r2, r3
 8000bc2:	da02      	bge.n	8000bca <get_packet_digipeater.4077+0x1a>
 8000bc4:	f04f 33ff 	mov.w	r3, #4294967295
 8000bc8:	e03b      	b.n	8000c42 <get_packet_digipeater.4077+0x92>

  for (i = 0; i < (ADDRESS_LENGTH - 1); i++)
 8000bca:	f04f 0300 	mov.w	r3, #0
 8000bce:	9305      	str	r3, [sp, #20]
 8000bd0:	e016      	b.n	8000c00 <get_packet_digipeater.4077+0x50>
    callsign[i] = (pkt->digipeaters[n][i] >> 1) & 0x7f;
 8000bd2:	9b05      	ldr	r3, [sp, #20]
 8000bd4:	9a01      	ldr	r2, [sp, #4]
 8000bd6:	18d1      	adds	r1, r2, r3
 8000bd8:	9803      	ldr	r0, [sp, #12]
 8000bda:	9a02      	ldr	r2, [sp, #8]
 8000bdc:	4613      	mov	r3, r2
 8000bde:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000be2:	1a9b      	subs	r3, r3, r2
 8000be4:	18c2      	adds	r2, r0, r3
 8000be6:	9b05      	ldr	r3, [sp, #20]
 8000be8:	18d3      	adds	r3, r2, r3
 8000bea:	f103 0308 	add.w	r3, r3, #8
 8000bee:	799b      	ldrb	r3, [r3, #6]
 8000bf0:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8000bf4:	b2db      	uxtb	r3, r3
 8000bf6:	700b      	strb	r3, [r1, #0]
{
  int i;

  if (n > pkt->num_digipeaters) return -1;

  for (i = 0; i < (ADDRESS_LENGTH - 1); i++)
 8000bf8:	9b05      	ldr	r3, [sp, #20]
 8000bfa:	f103 0301 	add.w	r3, r3, #1
 8000bfe:	9305      	str	r3, [sp, #20]
 8000c00:	9b05      	ldr	r3, [sp, #20]
 8000c02:	2b05      	cmp	r3, #5
 8000c04:	dde5      	ble.n	8000bd2 <get_packet_digipeater.4077+0x22>
    callsign[i] = (pkt->digipeaters[n][i] >> 1) & 0x7f;

  *ssid = (pkt->digipeaters[n][ADDRESS_LENGTH - 1] >> 1) & 0x0f;
 8000c06:	9903      	ldr	r1, [sp, #12]
 8000c08:	9a02      	ldr	r2, [sp, #8]
 8000c0a:	4613      	mov	r3, r2
 8000c0c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000c10:	1a9b      	subs	r3, r3, r2
 8000c12:	18cb      	adds	r3, r1, r3
 8000c14:	f103 030e 	add.w	r3, r3, #14
 8000c18:	799b      	ldrb	r3, [r3, #6]
 8000c1a:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8000c1e:	b2db      	uxtb	r3, r3
 8000c20:	f003 030f 	and.w	r3, r3, #15
 8000c24:	b2da      	uxtb	r2, r3
 8000c26:	9b00      	ldr	r3, [sp, #0]
 8000c28:	701a      	strb	r2, [r3, #0]

  return (pkt->digipeaters[n][ADDRESS_LENGTH - 1] & 0x01);
 8000c2a:	9903      	ldr	r1, [sp, #12]
 8000c2c:	9a02      	ldr	r2, [sp, #8]
 8000c2e:	4613      	mov	r3, r2
 8000c30:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000c34:	1a9b      	subs	r3, r3, r2
 8000c36:	18cb      	adds	r3, r1, r3
 8000c38:	f103 030e 	add.w	r3, r3, #14
 8000c3c:	799b      	ldrb	r3, [r3, #6]
 8000c3e:	f003 0301 	and.w	r3, r3, #1
}
 8000c42:	4618      	mov	r0, r3
 8000c44:	b006      	add	sp, #24
 8000c46:	4770      	bx	lr
 8000c48:	f3af 8000 	nop.w
 8000c4c:	f3af 8000 	nop.w

08000c50 <set_packet_source.4072>:
 *  set_packet_source(Packet* pkt, char* callsign, char ssid)
 *
 *  Set the packet source address to the callsign and ssid
 */
void set_packet_source(Packet* pkt, char* callsign, char ssid)
{
 8000c50:	b500      	push	{lr}
 8000c52:	b087      	sub	sp, #28
 8000c54:	9003      	str	r0, [sp, #12]
 8000c56:	9102      	str	r1, [sp, #8]
 8000c58:	4613      	mov	r3, r2
 8000c5a:	f88d 3007 	strb.w	r3, [sp, #7]
  int n; 
  int i;

  if (callsign == NULL) return;
 8000c5e:	9b02      	ldr	r3, [sp, #8]
 8000c60:	2b00      	cmp	r3, #0
 8000c62:	d02e      	beq.n	8000cc2 <set_packet_source.4072+0x72>

  n = strlen(callsign);
 8000c64:	9802      	ldr	r0, [sp, #8]
 8000c66:	f7ff fbd3 	bl	8000410 <strlen>
 8000c6a:	4603      	mov	r3, r0
 8000c6c:	9304      	str	r3, [sp, #16]
  for (i = 0; i < ADDRESS_LENGTH - 1; i++)
 8000c6e:	f04f 0300 	mov.w	r3, #0
 8000c72:	9305      	str	r3, [sp, #20]
 8000c74:	e015      	b.n	8000ca2 <set_packet_source.4072+0x52>
    pkt->source_address[i] = (((i < n) ? callsign[i] : 32) << 1) & 0xFE;
 8000c76:	9a05      	ldr	r2, [sp, #20]
 8000c78:	9b04      	ldr	r3, [sp, #16]
 8000c7a:	429a      	cmp	r2, r3
 8000c7c:	da07      	bge.n	8000c8e <set_packet_source.4072+0x3e>
 8000c7e:	9b05      	ldr	r3, [sp, #20]
 8000c80:	9a02      	ldr	r2, [sp, #8]
 8000c82:	18d3      	adds	r3, r2, r3
 8000c84:	781b      	ldrb	r3, [r3, #0]
 8000c86:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000c8a:	b2db      	uxtb	r3, r3
 8000c8c:	e001      	b.n	8000c92 <set_packet_source.4072+0x42>
 8000c8e:	f04f 0340 	mov.w	r3, #64	; 0x40
 8000c92:	9903      	ldr	r1, [sp, #12]
 8000c94:	9a05      	ldr	r2, [sp, #20]
 8000c96:	188a      	adds	r2, r1, r2
 8000c98:	7013      	strb	r3, [r2, #0]
  int i;

  if (callsign == NULL) return;

  n = strlen(callsign);
  for (i = 0; i < ADDRESS_LENGTH - 1; i++)
 8000c9a:	9b05      	ldr	r3, [sp, #20]
 8000c9c:	f103 0301 	add.w	r3, r3, #1
 8000ca0:	9305      	str	r3, [sp, #20]
 8000ca2:	9b05      	ldr	r3, [sp, #20]
 8000ca4:	2b05      	cmp	r3, #5
 8000ca6:	dde6      	ble.n	8000c76 <set_packet_source.4072+0x26>
    pkt->source_address[i] = (((i < n) ? callsign[i] : 32) << 1) & 0xFE;
  pkt->source_address[ADDRESS_LENGTH - 1] = (0x60 | ((ssid & 0x0F) << 1)) \
 8000ca8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000cac:	f003 030f 	and.w	r3, r3, #15
 8000cb0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000cb4:	b2db      	uxtb	r3, r3
 8000cb6:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 8000cba:	b2db      	uxtb	r3, r3
 8000cbc:	b2da      	uxtb	r2, r3
 8000cbe:	9b03      	ldr	r3, [sp, #12]
 8000cc0:	719a      	strb	r2, [r3, #6]
                                                  & 0xFE;
}
 8000cc2:	b007      	add	sp, #28
 8000cc4:	bd00      	pop	{pc}
 8000cc6:	bf00      	nop
 8000cc8:	f3af 8000 	nop.w
 8000ccc:	f3af 8000 	nop.w

08000cd0 <set_packet_destination.4067>:
 *  set_packet_destination(Packet* pkt, char* callsign, char ssid)
 *
 *  Set the packet destination address to the callsign and ssid
 */
void set_packet_destination(Packet* pkt, char* callsign, char ssid)
{
 8000cd0:	b500      	push	{lr}
 8000cd2:	b087      	sub	sp, #28
 8000cd4:	9003      	str	r0, [sp, #12]
 8000cd6:	9102      	str	r1, [sp, #8]
 8000cd8:	4613      	mov	r3, r2
 8000cda:	f88d 3007 	strb.w	r3, [sp, #7]
  int n; 
  int i;

  if (callsign == NULL) return;
 8000cde:	9b02      	ldr	r3, [sp, #8]
 8000ce0:	2b00      	cmp	r3, #0
 8000ce2:	d02e      	beq.n	8000d42 <set_packet_destination.4067+0x72>

  n = strlen(callsign);
 8000ce4:	9802      	ldr	r0, [sp, #8]
 8000ce6:	f7ff fb93 	bl	8000410 <strlen>
 8000cea:	4603      	mov	r3, r0
 8000cec:	9304      	str	r3, [sp, #16]
  for (i = 0; i < ADDRESS_LENGTH - 1; i++)
 8000cee:	f04f 0300 	mov.w	r3, #0
 8000cf2:	9305      	str	r3, [sp, #20]
 8000cf4:	e015      	b.n	8000d22 <set_packet_destination.4067+0x52>
    pkt->destination_address[i] = (((i < n) ? callsign[i] : 32) << 1) & 0xFE;
 8000cf6:	9a05      	ldr	r2, [sp, #20]
 8000cf8:	9b04      	ldr	r3, [sp, #16]
 8000cfa:	429a      	cmp	r2, r3
 8000cfc:	da07      	bge.n	8000d0e <set_packet_destination.4067+0x3e>
 8000cfe:	9b05      	ldr	r3, [sp, #20]
 8000d00:	9a02      	ldr	r2, [sp, #8]
 8000d02:	18d3      	adds	r3, r2, r3
 8000d04:	781b      	ldrb	r3, [r3, #0]
 8000d06:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000d0a:	b2db      	uxtb	r3, r3
 8000d0c:	e001      	b.n	8000d12 <set_packet_destination.4067+0x42>
 8000d0e:	f04f 0340 	mov.w	r3, #64	; 0x40
 8000d12:	9903      	ldr	r1, [sp, #12]
 8000d14:	9a05      	ldr	r2, [sp, #20]
 8000d16:	188a      	adds	r2, r1, r2
 8000d18:	71d3      	strb	r3, [r2, #7]
  int i;

  if (callsign == NULL) return;

  n = strlen(callsign);
  for (i = 0; i < ADDRESS_LENGTH - 1; i++)
 8000d1a:	9b05      	ldr	r3, [sp, #20]
 8000d1c:	f103 0301 	add.w	r3, r3, #1
 8000d20:	9305      	str	r3, [sp, #20]
 8000d22:	9b05      	ldr	r3, [sp, #20]
 8000d24:	2b05      	cmp	r3, #5
 8000d26:	dde6      	ble.n	8000cf6 <set_packet_destination.4067+0x26>
    pkt->destination_address[i] = (((i < n) ? callsign[i] : 32) << 1) & 0xFE;
  pkt->destination_address[ADDRESS_LENGTH - 1] = (0x60 | ((ssid & 0x0F) << 1)) \
 8000d28:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000d2c:	f003 030f 	and.w	r3, r3, #15
 8000d30:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000d34:	b2db      	uxtb	r3, r3
 8000d36:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 8000d3a:	b2db      	uxtb	r3, r3
 8000d3c:	b2da      	uxtb	r2, r3
 8000d3e:	9b03      	ldr	r3, [sp, #12]
 8000d40:	735a      	strb	r2, [r3, #13]
                                                       & 0xFE;
}
 8000d42:	b007      	add	sp, #28
 8000d44:	bd00      	pop	{pc}
 8000d46:	bf00      	nop
 8000d48:	f3af 8000 	nop.w
 8000d4c:	f3af 8000 	nop.w

08000d50 <add_packet_digipeater.4062>:
 *
 *  Function Returns a positive number equal to the number of digipeaters
 *  including the added one, assigned for the packet.
 */
int add_packet_digipeater(Packet* pkt, char* callsign, char ssid)
{
 8000d50:	b500      	push	{lr}
 8000d52:	b087      	sub	sp, #28
 8000d54:	9003      	str	r0, [sp, #12]
 8000d56:	9102      	str	r1, [sp, #8]
 8000d58:	4613      	mov	r3, r2
 8000d5a:	f88d 3007 	strb.w	r3, [sp, #7]
  int n; 
  int i;

  if (callsign == NULL) return -1;
 8000d5e:	9b02      	ldr	r3, [sp, #8]
 8000d60:	2b00      	cmp	r3, #0
 8000d62:	d102      	bne.n	8000d6a <add_packet_digipeater.4062+0x1a>
 8000d64:	f04f 33ff 	mov.w	r3, #4294967295
 8000d68:	e06f      	b.n	8000e4a <add_packet_digipeater.4062+0xfa>
  if (pkt->num_digipeaters >= MAX_DIGIPEATERS) return -2;
 8000d6a:	9b03      	ldr	r3, [sp, #12]
 8000d6c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000d6e:	2b07      	cmp	r3, #7
 8000d70:	dd02      	ble.n	8000d78 <add_packet_digipeater.4062+0x28>
 8000d72:	f06f 0301 	mvn.w	r3, #1
 8000d76:	e068      	b.n	8000e4a <add_packet_digipeater.4062+0xfa>

  /* The previous digipeater entry is not the last one - Turn last bit to 0 */
  if (pkt->num_digipeaters > 0 )
 8000d78:	9b03      	ldr	r3, [sp, #12]
 8000d7a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000d7c:	2b00      	cmp	r3, #0
 8000d7e:	dd1d      	ble.n	8000dbc <add_packet_digipeater.4062+0x6c>
    pkt->digipeaters[pkt->num_digipeaters - 1][ADDRESS_LENGTH - 1] &= 0xFE;
 8000d80:	9b03      	ldr	r3, [sp, #12]
 8000d82:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000d84:	f103 32ff 	add.w	r2, r3, #4294967295
 8000d88:	9b03      	ldr	r3, [sp, #12]
 8000d8a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000d8c:	f103 31ff 	add.w	r1, r3, #4294967295
 8000d90:	9803      	ldr	r0, [sp, #12]
 8000d92:	460b      	mov	r3, r1
 8000d94:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000d98:	1a5b      	subs	r3, r3, r1
 8000d9a:	18c3      	adds	r3, r0, r3
 8000d9c:	f103 030e 	add.w	r3, r3, #14
 8000da0:	799b      	ldrb	r3, [r3, #6]
 8000da2:	f023 0301 	bic.w	r3, r3, #1
 8000da6:	b2d9      	uxtb	r1, r3
 8000da8:	9803      	ldr	r0, [sp, #12]
 8000daa:	4613      	mov	r3, r2
 8000dac:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000db0:	1a9b      	subs	r3, r3, r2
 8000db2:	18c3      	adds	r3, r0, r3
 8000db4:	f103 030e 	add.w	r3, r3, #14
 8000db8:	460a      	mov	r2, r1
 8000dba:	719a      	strb	r2, [r3, #6]

  n = strlen(callsign);
 8000dbc:	9802      	ldr	r0, [sp, #8]
 8000dbe:	f7ff fb27 	bl	8000410 <strlen>
 8000dc2:	4603      	mov	r3, r0
 8000dc4:	9304      	str	r3, [sp, #16]
  for (i = 0; i < ADDRESS_LENGTH - 1; i++)
 8000dc6:	f04f 0300 	mov.w	r3, #0
 8000dca:	9305      	str	r3, [sp, #20]
 8000dcc:	e01e      	b.n	8000e0c <add_packet_digipeater.4062+0xbc>
    pkt->digipeaters[pkt->num_digipeaters][i] = (((i < n) ? callsign[i] : 32) \
 8000dce:	9b03      	ldr	r3, [sp, #12]
 8000dd0:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8000dd2:	9a05      	ldr	r2, [sp, #20]
 8000dd4:	9b04      	ldr	r3, [sp, #16]
 8000dd6:	429a      	cmp	r2, r3
 8000dd8:	da07      	bge.n	8000dea <add_packet_digipeater.4062+0x9a>
 8000dda:	9b05      	ldr	r3, [sp, #20]
 8000ddc:	9a02      	ldr	r2, [sp, #8]
 8000dde:	18d3      	adds	r3, r2, r3
 8000de0:	781b      	ldrb	r3, [r3, #0]
                                                          << 1) & 0xFE;
 8000de2:	ea4f 0343 	mov.w	r3, r3, lsl #1
  if (pkt->num_digipeaters > 0 )
    pkt->digipeaters[pkt->num_digipeaters - 1][ADDRESS_LENGTH - 1] &= 0xFE;

  n = strlen(callsign);
  for (i = 0; i < ADDRESS_LENGTH - 1; i++)
    pkt->digipeaters[pkt->num_digipeaters][i] = (((i < n) ? callsign[i] : 32) \
 8000de6:	b2da      	uxtb	r2, r3
 8000de8:	e001      	b.n	8000dee <add_packet_digipeater.4062+0x9e>
 8000dea:	f04f 0240 	mov.w	r2, #64	; 0x40
 8000dee:	9803      	ldr	r0, [sp, #12]
 8000df0:	460b      	mov	r3, r1
 8000df2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000df6:	1a5b      	subs	r3, r3, r1
 8000df8:	18c1      	adds	r1, r0, r3
 8000dfa:	9b05      	ldr	r3, [sp, #20]
 8000dfc:	18cb      	adds	r3, r1, r3
 8000dfe:	f103 0308 	add.w	r3, r3, #8
 8000e02:	719a      	strb	r2, [r3, #6]
  /* The previous digipeater entry is not the last one - Turn last bit to 0 */
  if (pkt->num_digipeaters > 0 )
    pkt->digipeaters[pkt->num_digipeaters - 1][ADDRESS_LENGTH - 1] &= 0xFE;

  n = strlen(callsign);
  for (i = 0; i < ADDRESS_LENGTH - 1; i++)
 8000e04:	9b05      	ldr	r3, [sp, #20]
 8000e06:	f103 0301 	add.w	r3, r3, #1
 8000e0a:	9305      	str	r3, [sp, #20]
 8000e0c:	9b05      	ldr	r3, [sp, #20]
 8000e0e:	2b05      	cmp	r3, #5
 8000e10:	dddd      	ble.n	8000dce <add_packet_digipeater.4062+0x7e>
    pkt->digipeaters[pkt->num_digipeaters][i] = (((i < n) ? callsign[i] : 32) \
                                                          << 1) & 0xFE;

  pkt->digipeaters[pkt->num_digipeaters++][ADDRESS_LENGTH - 1] = \
 8000e12:	9b03      	ldr	r3, [sp, #12]
 8000e14:	6c9a      	ldr	r2, [r3, #72]	; 0x48
                        (0x60 | ((ssid & 0x0F) << 1)) | 0x01;
 8000e16:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000e1a:	f003 030f 	and.w	r3, r3, #15
 8000e1e:	ea4f 0343 	mov.w	r3, r3, lsl #1
  n = strlen(callsign);
  for (i = 0; i < ADDRESS_LENGTH - 1; i++)
    pkt->digipeaters[pkt->num_digipeaters][i] = (((i < n) ? callsign[i] : 32) \
                                                          << 1) & 0xFE;

  pkt->digipeaters[pkt->num_digipeaters++][ADDRESS_LENGTH - 1] = \
 8000e22:	b2db      	uxtb	r3, r3
 8000e24:	f043 0361 	orr.w	r3, r3, #97	; 0x61
 8000e28:	b2db      	uxtb	r3, r3
 8000e2a:	b2d9      	uxtb	r1, r3
 8000e2c:	9803      	ldr	r0, [sp, #12]
 8000e2e:	4613      	mov	r3, r2
 8000e30:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000e34:	1a9b      	subs	r3, r3, r2
 8000e36:	18c3      	adds	r3, r0, r3
 8000e38:	f103 030e 	add.w	r3, r3, #14
 8000e3c:	7199      	strb	r1, [r3, #6]
 8000e3e:	f102 0201 	add.w	r2, r2, #1
 8000e42:	9b03      	ldr	r3, [sp, #12]
 8000e44:	649a      	str	r2, [r3, #72]	; 0x48
                        (0x60 | ((ssid & 0x0F) << 1)) | 0x01;

  return pkt->num_digipeaters;
 8000e46:	9b03      	ldr	r3, [sp, #12]
 8000e48:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
 8000e4a:	4618      	mov	r0, r3
 8000e4c:	b007      	add	sp, #28
 8000e4e:	bd00      	pop	{pc}

08000e50 <set_packet_payload.4058>:
 *  void set_packet_payload(Packet* pkt, char* payload)
 *
 *  Set the packet's payload to the string in payload
 */
void set_packet_payload(Packet* pkt, char* payload)
{   
 8000e50:	b500      	push	{lr}
 8000e52:	b085      	sub	sp, #20
 8000e54:	9001      	str	r0, [sp, #4]
 8000e56:	9100      	str	r1, [sp, #0]
  int n;

  n = strlen(payload);
 8000e58:	9800      	ldr	r0, [sp, #0]
 8000e5a:	f7ff fad9 	bl	8000410 <strlen>
 8000e5e:	4603      	mov	r3, r0
 8000e60:	9303      	str	r3, [sp, #12]
  n = (n > 256) ? 256 : n;
 8000e62:	9b03      	ldr	r3, [sp, #12]
 8000e64:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8000e68:	bfa8      	it	ge
 8000e6a:	f44f 7380 	movge.w	r3, #256	; 0x100
 8000e6e:	9303      	str	r3, [sp, #12]
  strncpy(pkt->payload, payload, n * sizeof(char));
 8000e70:	9b01      	ldr	r3, [sp, #4]
 8000e72:	f103 024e 	add.w	r2, r3, #78	; 0x4e
 8000e76:	9b03      	ldr	r3, [sp, #12]
 8000e78:	4610      	mov	r0, r2
 8000e7a:	9900      	ldr	r1, [sp, #0]
 8000e7c:	461a      	mov	r2, r3
 8000e7e:	f7ff faf7 	bl	8000470 <strncpy>
  pkt->payload_length = n;
 8000e82:	9b01      	ldr	r3, [sp, #4]
 8000e84:	9a03      	ldr	r2, [sp, #12]
 8000e86:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
}
 8000e8a:	b005      	add	sp, #20
 8000e8c:	bd00      	pop	{pc}
 8000e8e:	bf00      	nop

08000e90 <push_packet_to_queue.4054>:
 *  Returns 0 if the packet is successfully added to the queue, -1 if the queue
 *  was full and the add failed.
 *
 */
int push_packet_to_queue(Queue* queue, Packet* pkt)
{
 8000e90:	b500      	push	{lr}
 8000e92:	b083      	sub	sp, #12
 8000e94:	9001      	str	r0, [sp, #4]
 8000e96:	9100      	str	r1, [sp, #0]
    if ((queue->front == queue->rear + 1) || \
 8000e98:	9b01      	ldr	r3, [sp, #4]
 8000e9a:	681a      	ldr	r2, [r3, #0]
 8000e9c:	9b01      	ldr	r3, [sp, #4]
 8000e9e:	685b      	ldr	r3, [r3, #4]
 8000ea0:	f103 0301 	add.w	r3, r3, #1
 8000ea4:	429a      	cmp	r2, r3
 8000ea6:	d007      	beq.n	8000eb8 <push_packet_to_queue.4054+0x28>
       ((queue->front == 0) && (queue->rear == (MAX_QUEUE_LENGTH - 1))))
 8000ea8:	9b01      	ldr	r3, [sp, #4]
 8000eaa:	681b      	ldr	r3, [r3, #0]
 *  was full and the add failed.
 *
 */
int push_packet_to_queue(Queue* queue, Packet* pkt)
{
    if ((queue->front == queue->rear + 1) || \
 8000eac:	2b00      	cmp	r3, #0
 8000eae:	d106      	bne.n	8000ebe <push_packet_to_queue.4054+0x2e>
       ((queue->front == 0) && (queue->rear == (MAX_QUEUE_LENGTH - 1))))
 8000eb0:	9b01      	ldr	r3, [sp, #4]
 8000eb2:	685b      	ldr	r3, [r3, #4]
 8000eb4:	2b09      	cmp	r3, #9
 8000eb6:	d102      	bne.n	8000ebe <push_packet_to_queue.4054+0x2e>
    {
      return -1;
 8000eb8:	f04f 33ff 	mov.w	r3, #4294967295
 8000ebc:	e035      	b.n	8000f2a <push_packet_to_queue.4054+0x9a>
    }
    else
    {
      queue->front = (queue->front == -1) ? 0 : queue->front;
 8000ebe:	9b01      	ldr	r3, [sp, #4]
 8000ec0:	681b      	ldr	r3, [r3, #0]
 8000ec2:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000ec6:	d002      	beq.n	8000ece <push_packet_to_queue.4054+0x3e>
 8000ec8:	9b01      	ldr	r3, [sp, #4]
 8000eca:	681b      	ldr	r3, [r3, #0]
 8000ecc:	e001      	b.n	8000ed2 <push_packet_to_queue.4054+0x42>
 8000ece:	f04f 0300 	mov.w	r3, #0
 8000ed2:	9a01      	ldr	r2, [sp, #4]
 8000ed4:	6013      	str	r3, [r2, #0]
      (queue->rear) = ((queue->rear) + 1) % MAX_QUEUE_LENGTH;
 8000ed6:	9b01      	ldr	r3, [sp, #4]
 8000ed8:	685b      	ldr	r3, [r3, #4]
 8000eda:	f103 0101 	add.w	r1, r3, #1
 8000ede:	f246 6367 	movw	r3, #26215	; 0x6667
 8000ee2:	f2c6 6366 	movt	r3, #26214	; 0x6666
 8000ee6:	fb83 2301 	smull	r2, r3, r3, r1
 8000eea:	ea4f 02a3 	mov.w	r2, r3, asr #2
 8000eee:	ea4f 73e1 	mov.w	r3, r1, asr #31
 8000ef2:	1ad2      	subs	r2, r2, r3
 8000ef4:	4613      	mov	r3, r2
 8000ef6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000efa:	189b      	adds	r3, r3, r2
 8000efc:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000f00:	1aca      	subs	r2, r1, r3
 8000f02:	9b01      	ldr	r3, [sp, #4]
 8000f04:	605a      	str	r2, [r3, #4]
      memcpy(&(queue->packet_queue[(queue->rear)]), pkt, 1 * sizeof(Packet));
 8000f06:	9b01      	ldr	r3, [sp, #4]
 8000f08:	685b      	ldr	r3, [r3, #4]
 8000f0a:	f44f 72aa 	mov.w	r2, #340	; 0x154
 8000f0e:	fb02 f303 	mul.w	r3, r2, r3
 8000f12:	f103 0308 	add.w	r3, r3, #8
 8000f16:	9a01      	ldr	r2, [sp, #4]
 8000f18:	18d3      	adds	r3, r2, r3
 8000f1a:	4618      	mov	r0, r3
 8000f1c:	9900      	ldr	r1, [sp, #0]
 8000f1e:	f44f 72aa 	mov.w	r2, #340	; 0x154
 8000f22:	f7ff f9d5 	bl	80002d0 <memcpy>
    }
    return 0;
 8000f26:	f04f 0300 	mov.w	r3, #0
}
 8000f2a:	4618      	mov	r0, r3
 8000f2c:	b003      	add	sp, #12
 8000f2e:	bd00      	pop	{pc}

08000f30 <pop_packet_from_queue.4050>:
 *  Pop a packet from the packet queue and store in pkt
 *
 *  Return -1 if the queue is empty, 0 if the pop was successful.
 */
int pop_packet_from_queue(Queue* queue, Packet* pkt)
{
 8000f30:	b500      	push	{lr}
 8000f32:	b083      	sub	sp, #12
 8000f34:	9001      	str	r0, [sp, #4]
 8000f36:	9100      	str	r1, [sp, #0]
  if (queue->front == -1)
 8000f38:	9b01      	ldr	r3, [sp, #4]
 8000f3a:	681b      	ldr	r3, [r3, #0]
 8000f3c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000f40:	d102      	bne.n	8000f48 <pop_packet_from_queue.4050+0x18>
  {
    return -1;
 8000f42:	f04f 33ff 	mov.w	r3, #4294967295
 8000f46:	e048      	b.n	8000fda <pop_packet_from_queue.4050+0xaa>
  }
  else
  {
    memset(pkt, 0, 1 * sizeof(Packet)); 
 8000f48:	9800      	ldr	r0, [sp, #0]
 8000f4a:	f04f 0100 	mov.w	r1, #0
 8000f4e:	f44f 72aa 	mov.w	r2, #340	; 0x154
 8000f52:	f7ff fa0d 	bl	8000370 <memset>
    memcpy(pkt, &(queue->packet_queue[queue->front]), 1 * sizeof(Packet));
 8000f56:	9b01      	ldr	r3, [sp, #4]
 8000f58:	681b      	ldr	r3, [r3, #0]
 8000f5a:	f44f 72aa 	mov.w	r2, #340	; 0x154
 8000f5e:	fb02 f303 	mul.w	r3, r2, r3
 8000f62:	f103 0308 	add.w	r3, r3, #8
 8000f66:	9a01      	ldr	r2, [sp, #4]
 8000f68:	18d3      	adds	r3, r2, r3
 8000f6a:	9800      	ldr	r0, [sp, #0]
 8000f6c:	4619      	mov	r1, r3
 8000f6e:	f44f 72aa 	mov.w	r2, #340	; 0x154
 8000f72:	f7ff f9ad 	bl	80002d0 <memcpy>
    queue->front = ((queue->front) + 1) % MAX_QUEUE_LENGTH;
 8000f76:	9b01      	ldr	r3, [sp, #4]
 8000f78:	681b      	ldr	r3, [r3, #0]
 8000f7a:	f103 0101 	add.w	r1, r3, #1
 8000f7e:	f246 6367 	movw	r3, #26215	; 0x6667
 8000f82:	f2c6 6366 	movt	r3, #26214	; 0x6666
 8000f86:	fb83 2301 	smull	r2, r3, r3, r1
 8000f8a:	ea4f 02a3 	mov.w	r2, r3, asr #2
 8000f8e:	ea4f 73e1 	mov.w	r3, r1, asr #31
 8000f92:	1ad2      	subs	r2, r2, r3
 8000f94:	4613      	mov	r3, r2
 8000f96:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000f9a:	189b      	adds	r3, r3, r2
 8000f9c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000fa0:	1aca      	subs	r2, r1, r3
 8000fa2:	9b01      	ldr	r3, [sp, #4]
 8000fa4:	601a      	str	r2, [r3, #0]

    if ((queue->front == queue->rear + 1) || \
 8000fa6:	9b01      	ldr	r3, [sp, #4]
 8000fa8:	681a      	ldr	r2, [r3, #0]
 8000faa:	9b01      	ldr	r3, [sp, #4]
 8000fac:	685b      	ldr	r3, [r3, #4]
 8000fae:	f103 0301 	add.w	r3, r3, #1
 8000fb2:	429a      	cmp	r2, r3
 8000fb4:	d007      	beq.n	8000fc6 <pop_packet_from_queue.4050+0x96>
       ((queue->front == 0) && (queue->rear == (MAX_QUEUE_LENGTH - 1))))
 8000fb6:	9b01      	ldr	r3, [sp, #4]
 8000fb8:	681b      	ldr	r3, [r3, #0]
  {
    memset(pkt, 0, 1 * sizeof(Packet)); 
    memcpy(pkt, &(queue->packet_queue[queue->front]), 1 * sizeof(Packet));
    queue->front = ((queue->front) + 1) % MAX_QUEUE_LENGTH;

    if ((queue->front == queue->rear + 1) || \
 8000fba:	2b00      	cmp	r3, #0
 8000fbc:	d10b      	bne.n	8000fd6 <pop_packet_from_queue.4050+0xa6>
       ((queue->front == 0) && (queue->rear == (MAX_QUEUE_LENGTH - 1))))
 8000fbe:	9b01      	ldr	r3, [sp, #4]
 8000fc0:	685b      	ldr	r3, [r3, #4]
 8000fc2:	2b09      	cmp	r3, #9
 8000fc4:	d107      	bne.n	8000fd6 <pop_packet_from_queue.4050+0xa6>
    {
      queue->front = -1;
 8000fc6:	9b01      	ldr	r3, [sp, #4]
 8000fc8:	f04f 32ff 	mov.w	r2, #4294967295
 8000fcc:	601a      	str	r2, [r3, #0]
      queue->rear = -1;
 8000fce:	9b01      	ldr	r3, [sp, #4]
 8000fd0:	f04f 32ff 	mov.w	r2, #4294967295
 8000fd4:	605a      	str	r2, [r3, #4]
    }
  }
  return 0;
 8000fd6:	f04f 0300 	mov.w	r3, #0
}
 8000fda:	4618      	mov	r0, r3
 8000fdc:	b003      	add	sp, #12
 8000fde:	bd00      	pop	{pc}

08000fe0 <display_packet.4047>:
 *
 *  Display the fields of the packet pkt in a user-friendly fashion 
 *  on the terminal.
 */
void display_packet(Packet* pkt)
{
 8000fe0:	b510      	push	{r4, lr}
 8000fe2:	b08a      	sub	sp, #40	; 0x28
 8000fe4:	9003      	str	r0, [sp, #12]
  int n;
  int i;
  char address_string[ADDRESS_LENGTH + 2];
  
  if (pkt == NULL) return;
 8000fe6:	9b03      	ldr	r3, [sp, #12]
 8000fe8:	2b00      	cmp	r3, #0
 8000fea:	f000 80ed 	beq.w	80011c8 <display_packet.4047+0x1e8>

  chprintf(SD_TERMINAL, "-------------------------------\n");
 8000fee:	f643 6024 	movw	r0, #15908	; 0x3e24
 8000ff2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000ff6:	f245 3118 	movw	r1, #21272	; 0x5318
 8000ffa:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000ffe:	f7ff fcef 	bl	80009e0 <chprintf.10715.4099>
  memset(address_string, 0, (ADDRESS_LENGTH + 2) * sizeof(char));
 8001002:	ab05      	add	r3, sp, #20
 8001004:	4618      	mov	r0, r3
 8001006:	f04f 0100 	mov.w	r1, #0
 800100a:	f04f 0209 	mov.w	r2, #9
 800100e:	f7ff f9af 	bl	8000370 <memset>
  get_packet_source(pkt, address_string, address_string + ADDRESS_LENGTH);
 8001012:	aa05      	add	r2, sp, #20
 8001014:	ab05      	add	r3, sp, #20
 8001016:	f103 0307 	add.w	r3, r3, #7
 800101a:	9803      	ldr	r0, [sp, #12]
 800101c:	4611      	mov	r1, r2
 800101e:	461a      	mov	r2, r3
 8001020:	f7ff fd76 	bl	8000b10 <get_packet_source.4088>
  address_string[ADDRESS_LENGTH - 1] = '-';
 8001024:	f04f 032d 	mov.w	r3, #45	; 0x2d
 8001028:	f88d 301a 	strb.w	r3, [sp, #26]
  address_string[ADDRESS_LENGTH] += '0';
 800102c:	f89d 301b 	ldrb.w	r3, [sp, #27]
 8001030:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001034:	b2db      	uxtb	r3, r3
 8001036:	f88d 301b 	strb.w	r3, [sp, #27]
  chprintf(SD_TERMINAL, "  Source : %s\n",address_string);
 800103a:	ab05      	add	r3, sp, #20
 800103c:	f643 6024 	movw	r0, #15908	; 0x3e24
 8001040:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001044:	f245 313c 	movw	r1, #21308	; 0x533c
 8001048:	f6c0 0100 	movt	r1, #2048	; 0x800
 800104c:	461a      	mov	r2, r3
 800104e:	f7ff fcc7 	bl	80009e0 <chprintf.10715.4099>
  
  memset(address_string, 0, (ADDRESS_LENGTH + 2) * sizeof(char));
 8001052:	ab05      	add	r3, sp, #20
 8001054:	4618      	mov	r0, r3
 8001056:	f04f 0100 	mov.w	r1, #0
 800105a:	f04f 0209 	mov.w	r2, #9
 800105e:	f7ff f987 	bl	8000370 <memset>
  get_packet_destination(pkt, address_string, address_string + ADDRESS_LENGTH);
 8001062:	aa05      	add	r2, sp, #20
 8001064:	ab05      	add	r3, sp, #20
 8001066:	f103 0307 	add.w	r3, r3, #7
 800106a:	9803      	ldr	r0, [sp, #12]
 800106c:	4611      	mov	r1, r2
 800106e:	461a      	mov	r2, r3
 8001070:	f7ff fd76 	bl	8000b60 <get_packet_destination.4083>
  address_string[ADDRESS_LENGTH - 1] = '-';
 8001074:	f04f 032d 	mov.w	r3, #45	; 0x2d
 8001078:	f88d 301a 	strb.w	r3, [sp, #26]
  address_string[ADDRESS_LENGTH] += '0';
 800107c:	f89d 301b 	ldrb.w	r3, [sp, #27]
 8001080:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8001084:	b2db      	uxtb	r3, r3
 8001086:	f88d 301b 	strb.w	r3, [sp, #27]
  chprintf(SD_TERMINAL, "  Destination : %s\n",address_string);
 800108a:	ab05      	add	r3, sp, #20
 800108c:	f643 6024 	movw	r0, #15908	; 0x3e24
 8001090:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001094:	f245 314c 	movw	r1, #21324	; 0x534c
 8001098:	f6c0 0100 	movt	r1, #2048	; 0x800
 800109c:	461a      	mov	r2, r3
 800109e:	f7ff fc9f 	bl	80009e0 <chprintf.10715.4099>

  for (i = 0; i < pkt->num_digipeaters; i++)
 80010a2:	f04f 0300 	mov.w	r3, #0
 80010a6:	9309      	str	r3, [sp, #36]	; 0x24
 80010a8:	e047      	b.n	800113a <display_packet.4047+0x15a>
  {
    memset(address_string, 0, (ADDRESS_LENGTH + 2) * sizeof(char));
 80010aa:	ab05      	add	r3, sp, #20
 80010ac:	4618      	mov	r0, r3
 80010ae:	f04f 0100 	mov.w	r1, #0
 80010b2:	f04f 0209 	mov.w	r2, #9
 80010b6:	f7ff f95b 	bl	8000370 <memset>
    n = get_packet_digipeater(pkt, 
                          i, 
                          address_string, 
 80010ba:	aa05      	add	r2, sp, #20
                          address_string + ADDRESS_LENGTH);
 80010bc:	ab05      	add	r3, sp, #20
  chprintf(SD_TERMINAL, "  Destination : %s\n",address_string);

  for (i = 0; i < pkt->num_digipeaters; i++)
  {
    memset(address_string, 0, (ADDRESS_LENGTH + 2) * sizeof(char));
    n = get_packet_digipeater(pkt, 
 80010be:	f103 0307 	add.w	r3, r3, #7
 80010c2:	9803      	ldr	r0, [sp, #12]
 80010c4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80010c6:	f7ff fd73 	bl	8000bb0 <get_packet_digipeater.4077>
 80010ca:	9008      	str	r0, [sp, #32]
                          i, 
                          address_string, 
                          address_string + ADDRESS_LENGTH);
    if (n < 0)
 80010cc:	9b08      	ldr	r3, [sp, #32]
 80010ce:	2b00      	cmp	r3, #0
 80010d0:	da0a      	bge.n	80010e8 <display_packet.4047+0x108>
    {
      chprintf(SD_TERMINAL, \
 80010d2:	f643 6024 	movw	r0, #15908	; 0x3e24
 80010d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80010da:	f245 3160 	movw	r1, #21344	; 0x5360
 80010de:	f6c0 0100 	movt	r1, #2048	; 0x800
 80010e2:	f7ff fc7d 	bl	80009e0 <chprintf.10715.4099>
 80010e6:	e06f      	b.n	80011c8 <display_packet.4047+0x1e8>
        "  Error in retrieving digipeater data, exitting display_packet....\n");
      return;
    }
    address_string[ADDRESS_LENGTH - 1] = '-';
 80010e8:	f04f 032d 	mov.w	r3, #45	; 0x2d
 80010ec:	f88d 301a 	strb.w	r3, [sp, #26]
    address_string[ADDRESS_LENGTH] += '0';
 80010f0:	f89d 301b 	ldrb.w	r3, [sp, #27]
 80010f4:	f103 0330 	add.w	r3, r3, #48	; 0x30
 80010f8:	b2db      	uxtb	r3, r3
 80010fa:	f88d 301b 	strb.w	r3, [sp, #27]
    chprintf(SD_TERMINAL, 
 80010fe:	9b08      	ldr	r3, [sp, #32]
 8001100:	2b01      	cmp	r3, #1
 8001102:	d104      	bne.n	800110e <display_packet.4047+0x12e>
 8001104:	f245 33a4 	movw	r3, #21412	; 0x53a4
 8001108:	f6c0 0300 	movt	r3, #2048	; 0x800
 800110c:	e003      	b.n	8001116 <display_packet.4047+0x136>
 800110e:	f245 33a8 	movw	r3, #21416	; 0x53a8
 8001112:	f6c0 0300 	movt	r3, #2048	; 0x800
      "  Digipeater %d : %s (Last Digipeater : %s)\n", 
      i, 
      address_string,
 8001116:	ac05      	add	r4, sp, #20
        "  Error in retrieving digipeater data, exitting display_packet....\n");
      return;
    }
    address_string[ADDRESS_LENGTH - 1] = '-';
    address_string[ADDRESS_LENGTH] += '0';
    chprintf(SD_TERMINAL, 
 8001118:	9300      	str	r3, [sp, #0]
 800111a:	f643 6024 	movw	r0, #15908	; 0x3e24
 800111e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001122:	f245 31ac 	movw	r1, #21420	; 0x53ac
 8001126:	f6c0 0100 	movt	r1, #2048	; 0x800
 800112a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800112c:	4623      	mov	r3, r4
 800112e:	f7ff fc57 	bl	80009e0 <chprintf.10715.4099>
  get_packet_destination(pkt, address_string, address_string + ADDRESS_LENGTH);
  address_string[ADDRESS_LENGTH - 1] = '-';
  address_string[ADDRESS_LENGTH] += '0';
  chprintf(SD_TERMINAL, "  Destination : %s\n",address_string);

  for (i = 0; i < pkt->num_digipeaters; i++)
 8001132:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001134:	f103 0301 	add.w	r3, r3, #1
 8001138:	9309      	str	r3, [sp, #36]	; 0x24
 800113a:	9b03      	ldr	r3, [sp, #12]
 800113c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800113e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001140:	429a      	cmp	r2, r3
 8001142:	dcb2      	bgt.n	80010aa <display_packet.4047+0xca>
      address_string,
      (n == 1) ? "YES" : "NO");
  }

  chprintf(SD_TERMINAL, "  Control Field : 0x%x\n",
            pkt->control_field & 0xff);
 8001144:	9b03      	ldr	r3, [sp, #12]
 8001146:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
      i, 
      address_string,
      (n == 1) ? "YES" : "NO");
  }

  chprintf(SD_TERMINAL, "  Control Field : 0x%x\n",
 800114a:	f643 6024 	movw	r0, #15908	; 0x3e24
 800114e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001152:	f245 31dc 	movw	r1, #21468	; 0x53dc
 8001156:	f6c0 0100 	movt	r1, #2048	; 0x800
 800115a:	461a      	mov	r2, r3
 800115c:	f7ff fc40 	bl	80009e0 <chprintf.10715.4099>
            pkt->control_field & 0xff);
  chprintf(SD_TERMINAL, "  PID : 0x%x\n", 
            pkt->pid & 0xff);
 8001160:	9b03      	ldr	r3, [sp, #12]
 8001162:	f893 304d 	ldrb.w	r3, [r3, #77]	; 0x4d
      (n == 1) ? "YES" : "NO");
  }

  chprintf(SD_TERMINAL, "  Control Field : 0x%x\n",
            pkt->control_field & 0xff);
  chprintf(SD_TERMINAL, "  PID : 0x%x\n", 
 8001166:	f643 6024 	movw	r0, #15908	; 0x3e24
 800116a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800116e:	f245 31f4 	movw	r1, #21492	; 0x53f4
 8001172:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001176:	461a      	mov	r2, r3
 8001178:	f7ff fc32 	bl	80009e0 <chprintf.10715.4099>
            pkt->pid & 0xff);
  chprintf(SD_TERMINAL, "  Payload : %s\n", 
            pkt->payload);
 800117c:	9b03      	ldr	r3, [sp, #12]
 800117e:	f103 034e 	add.w	r3, r3, #78	; 0x4e

  chprintf(SD_TERMINAL, "  Control Field : 0x%x\n",
            pkt->control_field & 0xff);
  chprintf(SD_TERMINAL, "  PID : 0x%x\n", 
            pkt->pid & 0xff);
  chprintf(SD_TERMINAL, "  Payload : %s\n", 
 8001182:	f643 6024 	movw	r0, #15908	; 0x3e24
 8001186:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800118a:	f245 4104 	movw	r1, #21508	; 0x5404
 800118e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001192:	461a      	mov	r2, r3
 8001194:	f7ff fc24 	bl	80009e0 <chprintf.10715.4099>
            pkt->payload);
  chprintf(SD_TERMINAL, "  Payload Length : %d\n", 
            pkt->payload_length);
 8001198:	9b03      	ldr	r3, [sp, #12]
            pkt->control_field & 0xff);
  chprintf(SD_TERMINAL, "  PID : 0x%x\n", 
            pkt->pid & 0xff);
  chprintf(SD_TERMINAL, "  Payload : %s\n", 
            pkt->payload);
  chprintf(SD_TERMINAL, "  Payload Length : %d\n", 
 800119a:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 800119e:	f643 6024 	movw	r0, #15908	; 0x3e24
 80011a2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80011a6:	f245 4114 	movw	r1, #21524	; 0x5414
 80011aa:	f6c0 0100 	movt	r1, #2048	; 0x800
 80011ae:	461a      	mov	r2, r3
 80011b0:	f7ff fc16 	bl	80009e0 <chprintf.10715.4099>
            pkt->payload_length);
  chprintf(SD_TERMINAL, "-------------------------------\n");
 80011b4:	f643 6024 	movw	r0, #15908	; 0x3e24
 80011b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80011bc:	f245 3118 	movw	r1, #21272	; 0x5318
 80011c0:	f6c0 0100 	movt	r1, #2048	; 0x800
 80011c4:	f7ff fc0c 	bl	80009e0 <chprintf.10715.4099>
}
 80011c8:	b00a      	add	sp, #40	; 0x28
 80011ca:	bd10      	pop	{r4, pc}
 80011cc:	f3af 8000 	nop.w

080011d0 <display_packet_queue.4028>:
 *
 *  Display the fields of the packets in the queue.  The packets are not popped
 *  out of the queue.
 */
void display_packet_queue(Queue* queue)
{  
 80011d0:	b500      	push	{lr}
 80011d2:	b085      	sub	sp, #20
 80011d4:	9001      	str	r0, [sp, #4]
  int k;

  if( (queue->front) != -1 )
 80011d6:	9b01      	ldr	r3, [sp, #4]
 80011d8:	681b      	ldr	r3, [r3, #0]
 80011da:	f1b3 3fff 	cmp.w	r3, #4294967295
 80011de:	d04b      	beq.n	8001278 <display_packet_queue.4028+0xa8>
  {    
    if(queue->front == queue->rear)
 80011e0:	9b01      	ldr	r3, [sp, #4]
 80011e2:	681a      	ldr	r2, [r3, #0]
 80011e4:	9b01      	ldr	r3, [sp, #4]
 80011e6:	685b      	ldr	r3, [r3, #4]
 80011e8:	429a      	cmp	r2, r3
 80011ea:	d10d      	bne.n	8001208 <display_packet_queue.4028+0x38>
      display_packet(&(queue->packet_queue[queue->front]));
 80011ec:	9b01      	ldr	r3, [sp, #4]
 80011ee:	681b      	ldr	r3, [r3, #0]
 80011f0:	f44f 72aa 	mov.w	r2, #340	; 0x154
 80011f4:	fb02 f303 	mul.w	r3, r2, r3
 80011f8:	f103 0308 	add.w	r3, r3, #8
 80011fc:	9a01      	ldr	r2, [sp, #4]
 80011fe:	18d3      	adds	r3, r2, r3
 8001200:	4618      	mov	r0, r3
 8001202:	f7ff feed 	bl	8000fe0 <display_packet.4047>
 8001206:	e041      	b.n	800128c <display_packet_queue.4028+0xbc>
    else
    {
      for (k = queue->front; 
 8001208:	9b01      	ldr	r3, [sp, #4]
 800120a:	681b      	ldr	r3, [r3, #0]
 800120c:	9303      	str	r3, [sp, #12]
 800120e:	e021      	b.n	8001254 <display_packet_queue.4028+0x84>
           k != queue->rear; 
           k = ((k + 1) % MAX_QUEUE_LENGTH))
      {
        display_packet(&(queue->packet_queue[k]));
 8001210:	9b03      	ldr	r3, [sp, #12]
 8001212:	f44f 72aa 	mov.w	r2, #340	; 0x154
 8001216:	fb02 f303 	mul.w	r3, r2, r3
 800121a:	f103 0308 	add.w	r3, r3, #8
 800121e:	9a01      	ldr	r2, [sp, #4]
 8001220:	18d3      	adds	r3, r2, r3
 8001222:	4618      	mov	r0, r3
 8001224:	f7ff fedc 	bl	8000fe0 <display_packet.4047>
      display_packet(&(queue->packet_queue[queue->front]));
    else
    {
      for (k = queue->front; 
           k != queue->rear; 
           k = ((k + 1) % MAX_QUEUE_LENGTH))
 8001228:	9b03      	ldr	r3, [sp, #12]
 800122a:	f103 0201 	add.w	r2, r3, #1
 800122e:	f246 6367 	movw	r3, #26215	; 0x6667
 8001232:	f2c6 6366 	movt	r3, #26214	; 0x6666
 8001236:	fb83 1302 	smull	r1, r3, r3, r2
 800123a:	ea4f 01a3 	mov.w	r1, r3, asr #2
 800123e:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8001242:	1ac9      	subs	r1, r1, r3
 8001244:	460b      	mov	r3, r1
 8001246:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800124a:	185b      	adds	r3, r3, r1
 800124c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001250:	1ad3      	subs	r3, r2, r3
 8001252:	9303      	str	r3, [sp, #12]
    if(queue->front == queue->rear)
      display_packet(&(queue->packet_queue[queue->front]));
    else
    {
      for (k = queue->front; 
           k != queue->rear; 
 8001254:	9b01      	ldr	r3, [sp, #4]
 8001256:	685a      	ldr	r2, [r3, #4]
  {    
    if(queue->front == queue->rear)
      display_packet(&(queue->packet_queue[queue->front]));
    else
    {
      for (k = queue->front; 
 8001258:	9b03      	ldr	r3, [sp, #12]
 800125a:	429a      	cmp	r2, r3
 800125c:	d1d8      	bne.n	8001210 <display_packet_queue.4028+0x40>
           k != queue->rear; 
           k = ((k + 1) % MAX_QUEUE_LENGTH))
      {
        display_packet(&(queue->packet_queue[k]));
      }
      display_packet(&(queue->packet_queue[k]));
 800125e:	9b03      	ldr	r3, [sp, #12]
 8001260:	f44f 72aa 	mov.w	r2, #340	; 0x154
 8001264:	fb02 f303 	mul.w	r3, r2, r3
 8001268:	f103 0308 	add.w	r3, r3, #8
 800126c:	9a01      	ldr	r2, [sp, #4]
 800126e:	18d3      	adds	r3, r2, r3
 8001270:	4618      	mov	r0, r3
 8001272:	f7ff feb5 	bl	8000fe0 <display_packet.4047>
 8001276:	e009      	b.n	800128c <display_packet_queue.4028+0xbc>
    }
  }
  else 
    chprintf(SD_TERMINAL, "Packet queue empty...\n");
 8001278:	f643 6024 	movw	r0, #15908	; 0x3e24
 800127c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001280:	f245 412c 	movw	r1, #21548	; 0x542c
 8001284:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001288:	f7ff fbaa 	bl	80009e0 <chprintf.10715.4099>
}
 800128c:	b005      	add	sp, #20
 800128e:	bd00      	pop	{pc}

08001290 <chprintf.10953.4006>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001290:	b40e      	push	{r1, r2, r3}
 8001292:	b500      	push	{lr}
 8001294:	b084      	sub	sp, #16
 8001296:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8001298:	ab06      	add	r3, sp, #24
 800129a:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800129c:	9801      	ldr	r0, [sp, #4]
 800129e:	9905      	ldr	r1, [sp, #20]
 80012a0:	9a02      	ldr	r2, [sp, #8]
 80012a2:	f7ff f92d 	bl	8000500 <chvprintf.4103>
 80012a6:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 80012a8:	9b03      	ldr	r3, [sp, #12]
}
 80012aa:	4618      	mov	r0, r3
 80012ac:	b004      	add	sp, #16
 80012ae:	f85d eb04 	ldr.w	lr, [sp], #4
 80012b2:	b003      	add	sp, #12
 80012b4:	4770      	bx	lr
 80012b6:	bf00      	nop
 80012b8:	f3af 8000 	nop.w
 80012bc:	f3af 8000 	nop.w

080012c0 <main>:
#include "chstreams.h"
#include "chprintf.h"
#include "packet_queue.h"

int main(void)
{
 80012c0:	b510      	push	{r4, lr}
 80012c2:	b0e2      	sub	sp, #392	; 0x188
  int i;
  int j;
  int rv;

  /* HAL and RTOS Init Calls */
  halInit();
 80012c4:	f002 fa1c 	bl	8003700 <halInit>
  chSysInit();
 80012c8:	f002 fe92 	bl	8003ff0 <chSysInit>
  
  /* Turn on UART6 */
  sdStart(&SD_TERMINAL_PORT , NULL );
 80012cc:	f643 6024 	movw	r0, #15908	; 0x3e24
 80012d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80012d4:	f04f 0100 	mov.w	r1, #0
 80012d8:	f002 fc62 	bl	8003ba0 <sdStart>
  palSetPadMode(GPIOC, 6, PAL_MODE_ALTERNATE(8));     // UART TX
 80012dc:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80012e0:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80012e4:	f04f 0140 	mov.w	r1, #64	; 0x40
 80012e8:	f240 4202 	movw	r2, #1026	; 0x402
 80012ec:	f001 f878 	bl	80023e0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 7, PAL_MODE_ALTERNATE(8));     // UART RX
 80012f0:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80012f4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80012f8:	f04f 0180 	mov.w	r1, #128	; 0x80
 80012fc:	f240 4202 	movw	r2, #1026	; 0x402
 8001300:	f001 f86e 	bl	80023e0 <_pal_lld_setgroupmode>

  /* Initialize the Packet Queue */
  init_queue(&my_queue);
 8001304:	f643 609c 	movw	r0, #16028	; 0x3e9c
 8001308:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800130c:	f7ff fbe8 	bl	8000ae0 <init_queue.4093>

  for (i = 0; i <= MAX_QUEUE_LENGTH; i++)
 8001310:	f04f 0300 	mov.w	r3, #0
 8001314:	9361      	str	r3, [sp, #388]	; 0x184
 8001316:	e098      	b.n	800144a <main+0x18a>
  {
    init_packet(&pkt);
 8001318:	ab0a      	add	r3, sp, #40	; 0x28
 800131a:	4618      	mov	r0, r3
 800131c:	f7ff fb78 	bl	8000a10 <init_packet.4096>
    set_packet_source(&pkt, "VU3EM", 1);  
 8001320:	ab0a      	add	r3, sp, #40	; 0x28
 8001322:	4618      	mov	r0, r3
 8001324:	f245 4144 	movw	r1, #21572	; 0x5444
 8001328:	f6c0 0100 	movt	r1, #2048	; 0x800
 800132c:	f04f 0201 	mov.w	r2, #1
 8001330:	f7ff fc8e 	bl	8000c50 <set_packet_source.4072>
    set_packet_destination(&pkt, "CQ", 0); 
 8001334:	ab0a      	add	r3, sp, #40	; 0x28
 8001336:	4618      	mov	r0, r3
 8001338:	f245 414c 	movw	r1, #21580	; 0x544c
 800133c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001340:	f04f 0200 	mov.w	r2, #0
 8001344:	f7ff fcc4 	bl	8000cd0 <set_packet_destination.4067>
    for (j = 0; j <= MAX_DIGIPEATERS; j++)
 8001348:	f04f 0300 	mov.w	r3, #0
 800134c:	9360      	str	r3, [sp, #384]	; 0x180
 800134e:	e02e      	b.n	80013ae <main+0xee>
    {
      memset(digipeater_name, 0, ADDRESS_LENGTH * sizeof(char));
 8001350:	466b      	mov	r3, sp
 8001352:	4618      	mov	r0, r3
 8001354:	f04f 0100 	mov.w	r1, #0
 8001358:	f04f 0207 	mov.w	r2, #7
 800135c:	f7ff f808 	bl	8000370 <memset>
      strncpy(digipeater_name, "DIGI", 4 * sizeof(char));
 8001360:	466a      	mov	r2, sp
 8001362:	f644 1344 	movw	r3, #18756	; 0x4944
 8001366:	f6c4 1347 	movt	r3, #18759	; 0x4947
 800136a:	6013      	str	r3, [r2, #0]
      digipeater_name[4] = j + '1';
 800136c:	9b60      	ldr	r3, [sp, #384]	; 0x180
 800136e:	b2db      	uxtb	r3, r3
 8001370:	f103 0331 	add.w	r3, r3, #49	; 0x31
 8001374:	b2da      	uxtb	r2, r3
 8001376:	466b      	mov	r3, sp
 8001378:	711a      	strb	r2, [r3, #4]
      rv = add_packet_digipeater(&pkt, digipeater_name, j);
 800137a:	9b60      	ldr	r3, [sp, #384]	; 0x180
 800137c:	b2db      	uxtb	r3, r3
 800137e:	a90a      	add	r1, sp, #40	; 0x28
 8001380:	466a      	mov	r2, sp
 8001382:	4608      	mov	r0, r1
 8001384:	4611      	mov	r1, r2
 8001386:	461a      	mov	r2, r3
 8001388:	f7ff fce2 	bl	8000d50 <add_packet_digipeater.4062>
 800138c:	905f      	str	r0, [sp, #380]	; 0x17c
      chprintf(SD_TERMINAL, "add_packet_digipeater returned %d for digi %d\n",
 800138e:	f643 6024 	movw	r0, #15908	; 0x3e24
 8001392:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001396:	f245 4150 	movw	r1, #21584	; 0x5450
 800139a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800139e:	9a5f      	ldr	r2, [sp, #380]	; 0x17c
 80013a0:	9b60      	ldr	r3, [sp, #384]	; 0x180
 80013a2:	f7ff ff75 	bl	8001290 <chprintf.10953.4006>
  for (i = 0; i <= MAX_QUEUE_LENGTH; i++)
  {
    init_packet(&pkt);
    set_packet_source(&pkt, "VU3EM", 1);  
    set_packet_destination(&pkt, "CQ", 0); 
    for (j = 0; j <= MAX_DIGIPEATERS; j++)
 80013a6:	9b60      	ldr	r3, [sp, #384]	; 0x180
 80013a8:	f103 0301 	add.w	r3, r3, #1
 80013ac:	9360      	str	r3, [sp, #384]	; 0x180
 80013ae:	9b60      	ldr	r3, [sp, #384]	; 0x180
 80013b0:	2b08      	cmp	r3, #8
 80013b2:	ddcd      	ble.n	8001350 <main+0x90>
      digipeater_name[4] = j + '1';
      rv = add_packet_digipeater(&pkt, digipeater_name, j);
      chprintf(SD_TERMINAL, "add_packet_digipeater returned %d for digi %d\n",
        rv, j);
    }
    memset(packet_payload, 0, 30 * sizeof(char));
 80013b4:	ab02      	add	r3, sp, #8
 80013b6:	4618      	mov	r0, r3
 80013b8:	f04f 0100 	mov.w	r1, #0
 80013bc:	f04f 021e 	mov.w	r2, #30
 80013c0:	f7fe ffd6 	bl	8000370 <memset>
    strncpy(packet_payload, "THIS IS PACKET ", 15 * sizeof(char));
 80013c4:	aa02      	add	r2, sp, #8
 80013c6:	f245 4380 	movw	r3, #21632	; 0x5480
 80013ca:	f6c0 0300 	movt	r3, #2048	; 0x800
 80013ce:	4614      	mov	r4, r2
 80013d0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80013d2:	c407      	stmia	r4!, {r0, r1, r2}
 80013d4:	8023      	strh	r3, [r4, #0]
 80013d6:	f104 0402 	add.w	r4, r4, #2
 80013da:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80013de:	7023      	strb	r3, [r4, #0]
    packet_payload[15] = i + '0';
 80013e0:	9b61      	ldr	r3, [sp, #388]	; 0x184
 80013e2:	b2db      	uxtb	r3, r3
 80013e4:	f103 0330 	add.w	r3, r3, #48	; 0x30
 80013e8:	b2da      	uxtb	r2, r3
 80013ea:	ab02      	add	r3, sp, #8
 80013ec:	73da      	strb	r2, [r3, #15]
    set_packet_payload(&pkt, packet_payload);
 80013ee:	aa0a      	add	r2, sp, #40	; 0x28
 80013f0:	ab02      	add	r3, sp, #8
 80013f2:	4610      	mov	r0, r2
 80013f4:	4619      	mov	r1, r3
 80013f6:	f7ff fd2b 	bl	8000e50 <set_packet_payload.4058>

    chprintf(SD_TERMINAL, "Packet %d\n", i);
 80013fa:	f643 6024 	movw	r0, #15908	; 0x3e24
 80013fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001402:	f245 4190 	movw	r1, #21648	; 0x5490
 8001406:	f6c0 0100 	movt	r1, #2048	; 0x800
 800140a:	9a61      	ldr	r2, [sp, #388]	; 0x184
 800140c:	f7ff ff40 	bl	8001290 <chprintf.10953.4006>
    display_packet(&pkt);
 8001410:	ab0a      	add	r3, sp, #40	; 0x28
 8001412:	4618      	mov	r0, r3
 8001414:	f7ff fde4 	bl	8000fe0 <display_packet.4047>

    rv = push_packet_to_queue(&my_queue, &pkt);
 8001418:	ab0a      	add	r3, sp, #40	; 0x28
 800141a:	f643 609c 	movw	r0, #16028	; 0x3e9c
 800141e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001422:	4619      	mov	r1, r3
 8001424:	f7ff fd34 	bl	8000e90 <push_packet_to_queue.4054>
 8001428:	905f      	str	r0, [sp, #380]	; 0x17c
    chprintf(SD_TERMINAL, "push_packet_to_queue returned %d for pkt %d\n", 
 800142a:	f643 6024 	movw	r0, #15908	; 0x3e24
 800142e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001432:	f245 419c 	movw	r1, #21660	; 0x549c
 8001436:	f6c0 0100 	movt	r1, #2048	; 0x800
 800143a:	9a5f      	ldr	r2, [sp, #380]	; 0x17c
 800143c:	9b61      	ldr	r3, [sp, #388]	; 0x184
 800143e:	f7ff ff27 	bl	8001290 <chprintf.10953.4006>
  palSetPadMode(GPIOC, 7, PAL_MODE_ALTERNATE(8));     // UART RX

  /* Initialize the Packet Queue */
  init_queue(&my_queue);

  for (i = 0; i <= MAX_QUEUE_LENGTH; i++)
 8001442:	9b61      	ldr	r3, [sp, #388]	; 0x184
 8001444:	f103 0301 	add.w	r3, r3, #1
 8001448:	9361      	str	r3, [sp, #388]	; 0x184
 800144a:	9b61      	ldr	r3, [sp, #388]	; 0x184
 800144c:	2b0a      	cmp	r3, #10
 800144e:	f77f af63 	ble.w	8001318 <main+0x58>
    rv = push_packet_to_queue(&my_queue, &pkt);
    chprintf(SD_TERMINAL, "push_packet_to_queue returned %d for pkt %d\n", 
      rv, i);
  }

  chprintf(SD_TERMINAL, "Displaying Packet Queue...\n");
 8001452:	f643 6024 	movw	r0, #15908	; 0x3e24
 8001456:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800145a:	f245 41cc 	movw	r1, #21708	; 0x54cc
 800145e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001462:	f7ff ff15 	bl	8001290 <chprintf.10953.4006>
  display_packet_queue(&my_queue);
 8001466:	f643 609c 	movw	r0, #16028	; 0x3e9c
 800146a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800146e:	f7ff feaf 	bl	80011d0 <display_packet_queue.4028>

  init_packet(&pkt);
 8001472:	ab0a      	add	r3, sp, #40	; 0x28
 8001474:	4618      	mov	r0, r3
 8001476:	f7ff facb 	bl	8000a10 <init_packet.4096>
 800147a:	e011      	b.n	80014a0 <main+0x1e0>
  while(pop_packet_from_queue(&my_queue, &pkt) == 0)
  {
    chprintf(SD_TERMINAL, "Popped Packet...\n");
 800147c:	f643 6024 	movw	r0, #15908	; 0x3e24
 8001480:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001484:	f245 41e8 	movw	r1, #21736	; 0x54e8
 8001488:	f6c0 0100 	movt	r1, #2048	; 0x800
 800148c:	f7ff ff00 	bl	8001290 <chprintf.10953.4006>
    display_packet(&pkt);
 8001490:	ab0a      	add	r3, sp, #40	; 0x28
 8001492:	4618      	mov	r0, r3
 8001494:	f7ff fda4 	bl	8000fe0 <display_packet.4047>
    init_packet(&pkt);
 8001498:	ab0a      	add	r3, sp, #40	; 0x28
 800149a:	4618      	mov	r0, r3
 800149c:	f7ff fab8 	bl	8000a10 <init_packet.4096>

  chprintf(SD_TERMINAL, "Displaying Packet Queue...\n");
  display_packet_queue(&my_queue);

  init_packet(&pkt);
  while(pop_packet_from_queue(&my_queue, &pkt) == 0)
 80014a0:	ab0a      	add	r3, sp, #40	; 0x28
 80014a2:	f643 609c 	movw	r0, #16028	; 0x3e9c
 80014a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80014aa:	4619      	mov	r1, r3
 80014ac:	f7ff fd40 	bl	8000f30 <pop_packet_from_queue.4050>
 80014b0:	4603      	mov	r3, r0
 80014b2:	2b00      	cmp	r3, #0
 80014b4:	d0e2      	beq.n	800147c <main+0x1bc>
    chprintf(SD_TERMINAL, "Popped Packet...\n");
    display_packet(&pkt);
    init_packet(&pkt);
  }

  chprintf(SD_TERMINAL, "Pop packet queue complete....\n");
 80014b6:	f643 6024 	movw	r0, #15908	; 0x3e24
 80014ba:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80014be:	f245 41fc 	movw	r1, #21756	; 0x54fc
 80014c2:	f6c0 0100 	movt	r1, #2048	; 0x800
 80014c6:	f7ff fee3 	bl	8001290 <chprintf.10953.4006>

  chprintf(SD_TERMINAL, "Displaying Queue after push...\n");
 80014ca:	f643 6024 	movw	r0, #15908	; 0x3e24
 80014ce:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80014d2:	f245 511c 	movw	r1, #21788	; 0x551c
 80014d6:	f6c0 0100 	movt	r1, #2048	; 0x800
 80014da:	f7ff fed9 	bl	8001290 <chprintf.10953.4006>
  display_packet_queue(&my_queue);
 80014de:	f643 609c 	movw	r0, #16028	; 0x3e9c
 80014e2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80014e6:	f7ff fe73 	bl	80011d0 <display_packet_queue.4028>

  chprintf(SD_TERMINAL, "Queue Status: %d, %d\n", 
 80014ea:	f643 639c 	movw	r3, #16028	; 0x3e9c
 80014ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014f2:	681a      	ldr	r2, [r3, #0]
 80014f4:	f643 639c 	movw	r3, #16028	; 0x3e9c
 80014f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014fc:	685b      	ldr	r3, [r3, #4]
 80014fe:	f643 6024 	movw	r0, #15908	; 0x3e24
 8001502:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001506:	f245 513c 	movw	r1, #21820	; 0x553c
 800150a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800150e:	f7ff febf 	bl	8001290 <chprintf.10953.4006>
    my_queue.front,
    my_queue.rear);

  while(1)
  {
    chprintf(SD_TERMINAL, "Waiting....\n");
 8001512:	f643 6024 	movw	r0, #15908	; 0x3e24
 8001516:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800151a:	f245 5154 	movw	r1, #21844	; 0x5554
 800151e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001522:	f7ff feb5 	bl	8001290 <chprintf.10953.4006>
    chThdSleepMilliseconds(1000);
 8001526:	f242 7010 	movw	r0, #10000	; 0x2710
 800152a:	f003 fdd9 	bl	80050e0 <chThdSleep>
    palTogglePad(GPIOD, GPIOD_LED3);       /* Orange.  */
 800152e:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8001532:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001536:	f44f 6240 	mov.w	r2, #3072	; 0xc00
 800153a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800153e:	6952      	ldr	r2, [r2, #20]
 8001540:	f482 5200 	eor.w	r2, r2, #8192	; 0x2000
 8001544:	615a      	str	r2, [r3, #20]
 8001546:	e7e4      	b.n	8001512 <main+0x252>
 8001548:	f3af 8000 	nop.w
 800154c:	f3af 8000 	nop.w

08001550 <sdIncomingDataI.4429>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8001550:	b500      	push	{lr}
 8001552:	b083      	sub	sp, #12
 8001554:	9001      	str	r0, [sp, #4]
 8001556:	460b      	mov	r3, r1
 8001558:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
 800155c:	f002 fee8 	bl	8004330 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
 8001560:	9b01      	ldr	r3, [sp, #4]
 8001562:	2b00      	cmp	r3, #0
 8001564:	d105      	bne.n	8001572 <sdIncomingDataI.4429+0x22>
 8001566:	f245 7060 	movw	r0, #22368	; 0x5760
 800156a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800156e:	f002 fd97 	bl	80040a0 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
 8001572:	9b01      	ldr	r3, [sp, #4]
 8001574:	f103 030c 	add.w	r3, r3, #12
 8001578:	4618      	mov	r0, r3
 800157a:	f002 f9e9 	bl	8003950 <chIQIsEmptyI.9352>
 800157e:	4603      	mov	r3, r0
 8001580:	2b00      	cmp	r3, #0
 8001582:	d007      	beq.n	8001594 <sdIncomingDataI.4429+0x44>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8001584:	9b01      	ldr	r3, [sp, #4]
 8001586:	f103 0304 	add.w	r3, r3, #4
 800158a:	4618      	mov	r0, r3
 800158c:	f04f 0104 	mov.w	r1, #4
 8001590:	f002 fa06 	bl	80039a0 <osalEventBroadcastFlagsI.9368>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8001594:	9b01      	ldr	r3, [sp, #4]
 8001596:	f103 020c 	add.w	r2, r3, #12
 800159a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800159e:	4610      	mov	r0, r2
 80015a0:	4619      	mov	r1, r3
 80015a2:	f001 fd55 	bl	8003050 <chIQPutI>
 80015a6:	4603      	mov	r3, r0
 80015a8:	2b00      	cmp	r3, #0
 80015aa:	da07      	bge.n	80015bc <sdIncomingDataI.4429+0x6c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 80015ac:	9b01      	ldr	r3, [sp, #4]
 80015ae:	f103 0304 	add.w	r3, r3, #4
 80015b2:	4618      	mov	r0, r3
 80015b4:	f04f 0180 	mov.w	r1, #128	; 0x80
 80015b8:	f002 f9f2 	bl	80039a0 <osalEventBroadcastFlagsI.9368>
}
 80015bc:	b003      	add	sp, #12
 80015be:	bd00      	pop	{pc}

080015c0 <nvicEnableVector.4424>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80015c0:	b082      	sub	sp, #8
 80015c2:	9001      	str	r0, [sp, #4]
 80015c4:	9100      	str	r1, [sp, #0]

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 80015c6:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80015ca:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80015ce:	9a00      	ldr	r2, [sp, #0]
 80015d0:	b2d2      	uxtb	r2, r2
 80015d2:	ea4f 1202 	mov.w	r2, r2, lsl #4
 80015d6:	b2d2      	uxtb	r2, r2
 80015d8:	9901      	ldr	r1, [sp, #4]
 80015da:	185b      	adds	r3, r3, r1
 80015dc:	f503 7340 	add.w	r3, r3, #768	; 0x300
 80015e0:	701a      	strb	r2, [r3, #0]
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80015e2:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80015e6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80015ea:	9a01      	ldr	r2, [sp, #4]
 80015ec:	ea4f 1252 	mov.w	r2, r2, lsr #5
 80015f0:	9901      	ldr	r1, [sp, #4]
 80015f2:	f001 011f 	and.w	r1, r1, #31
 80015f6:	f04f 0001 	mov.w	r0, #1
 80015fa:	fa00 f101 	lsl.w	r1, r0, r1
 80015fe:	f102 0260 	add.w	r2, r2, #96	; 0x60
 8001602:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 8001606:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 800160a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800160e:	9a01      	ldr	r2, [sp, #4]
 8001610:	ea4f 1252 	mov.w	r2, r2, lsr #5
 8001614:	9901      	ldr	r1, [sp, #4]
 8001616:	f001 011f 	and.w	r1, r1, #31
 800161a:	f04f 0001 	mov.w	r0, #1
 800161e:	fa00 f101 	lsl.w	r1, r0, r1
 8001622:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8001626:	b002      	add	sp, #8
 8001628:	4770      	bx	lr
 800162a:	bf00      	nop
 800162c:	f3af 8000 	nop.w

08001630 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector6C) {
 8001630:	b500      	push	{lr}
 8001632:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001634:	f001 fb34 	bl	8002ca0 <_stats_increase_irq>
 8001638:	f002 fe2a 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0) & STM32_DMA_ISR_MASK;
 800163c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001640:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001644:	681b      	ldr	r3, [r3, #0]
 8001646:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800164a:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0;
 800164c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001650:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001654:	9a01      	ldr	r2, [sp, #4]
 8001656:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 8001658:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 800165c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001660:	681b      	ldr	r3, [r3, #0]
 8001662:	2b00      	cmp	r3, #0
 8001664:	d00c      	beq.n	8001680 <Vector6C+0x50>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8001666:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 800166a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800166e:	681a      	ldr	r2, [r3, #0]
 8001670:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001674:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001678:	685b      	ldr	r3, [r3, #4]
 800167a:	4618      	mov	r0, r3
 800167c:	9901      	ldr	r1, [sp, #4]
 800167e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001680:	f002 fe2e 	bl	80042e0 <_dbg_check_leave_isr>
 8001684:	f001 fffc 	bl	8003680 <_port_irq_epilogue>
}
 8001688:	b003      	add	sp, #12
 800168a:	bd00      	pop	{pc}
 800168c:	f3af 8000 	nop.w

08001690 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector70) {
 8001690:	b500      	push	{lr}
 8001692:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001694:	f001 fb04 	bl	8002ca0 <_stats_increase_irq>
 8001698:	f002 fdfa 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6) & STM32_DMA_ISR_MASK;
 800169c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 80016a0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80016a4:	681b      	ldr	r3, [r3, #0]
 80016a6:	ea4f 1393 	mov.w	r3, r3, lsr #6
 80016aa:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80016ae:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6;
 80016b0:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 80016b4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80016b8:	9a01      	ldr	r2, [sp, #4]
 80016ba:	ea4f 1282 	mov.w	r2, r2, lsl #6
 80016be:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 80016c0:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80016c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80016c8:	689b      	ldr	r3, [r3, #8]
 80016ca:	2b00      	cmp	r3, #0
 80016cc:	d00c      	beq.n	80016e8 <Vector70+0x58>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 80016ce:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80016d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80016d6:	689a      	ldr	r2, [r3, #8]
 80016d8:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80016dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80016e0:	68db      	ldr	r3, [r3, #12]
 80016e2:	4618      	mov	r0, r3
 80016e4:	9901      	ldr	r1, [sp, #4]
 80016e6:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80016e8:	f002 fdfa 	bl	80042e0 <_dbg_check_leave_isr>
 80016ec:	f001 ffc8 	bl	8003680 <_port_irq_epilogue>
}
 80016f0:	b003      	add	sp, #12
 80016f2:	bd00      	pop	{pc}
 80016f4:	f3af 8000 	nop.w
 80016f8:	f3af 8000 	nop.w
 80016fc:	f3af 8000 	nop.w

08001700 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector74) {
 8001700:	b500      	push	{lr}
 8001702:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001704:	f001 facc 	bl	8002ca0 <_stats_increase_irq>
 8001708:	f002 fdc2 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16) & STM32_DMA_ISR_MASK;
 800170c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001710:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001714:	681b      	ldr	r3, [r3, #0]
 8001716:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800171a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800171e:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16;
 8001720:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001724:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001728:	9a01      	ldr	r2, [sp, #4]
 800172a:	ea4f 4202 	mov.w	r2, r2, lsl #16
 800172e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 8001730:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001734:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001738:	691b      	ldr	r3, [r3, #16]
 800173a:	2b00      	cmp	r3, #0
 800173c:	d00c      	beq.n	8001758 <Vector74+0x58>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 800173e:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001742:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001746:	691a      	ldr	r2, [r3, #16]
 8001748:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 800174c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001750:	695b      	ldr	r3, [r3, #20]
 8001752:	4618      	mov	r0, r3
 8001754:	9901      	ldr	r1, [sp, #4]
 8001756:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001758:	f002 fdc2 	bl	80042e0 <_dbg_check_leave_isr>
 800175c:	f001 ff90 	bl	8003680 <_port_irq_epilogue>
}
 8001760:	b003      	add	sp, #12
 8001762:	bd00      	pop	{pc}
 8001764:	f3af 8000 	nop.w
 8001768:	f3af 8000 	nop.w
 800176c:	f3af 8000 	nop.w

08001770 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector78) {
 8001770:	b500      	push	{lr}
 8001772:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001774:	f001 fa94 	bl	8002ca0 <_stats_increase_irq>
 8001778:	f002 fd8a 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22) & STM32_DMA_ISR_MASK;
 800177c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001780:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001784:	681b      	ldr	r3, [r3, #0]
 8001786:	ea4f 5393 	mov.w	r3, r3, lsr #22
 800178a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800178e:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22;
 8001790:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001794:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001798:	9a01      	ldr	r2, [sp, #4]
 800179a:	ea4f 5282 	mov.w	r2, r2, lsl #22
 800179e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 80017a0:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80017a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80017a8:	699b      	ldr	r3, [r3, #24]
 80017aa:	2b00      	cmp	r3, #0
 80017ac:	d00c      	beq.n	80017c8 <Vector78+0x58>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 80017ae:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80017b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80017b6:	699a      	ldr	r2, [r3, #24]
 80017b8:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80017bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80017c0:	69db      	ldr	r3, [r3, #28]
 80017c2:	4618      	mov	r0, r3
 80017c4:	9901      	ldr	r1, [sp, #4]
 80017c6:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80017c8:	f002 fd8a 	bl	80042e0 <_dbg_check_leave_isr>
 80017cc:	f001 ff58 	bl	8003680 <_port_irq_epilogue>
}
 80017d0:	b003      	add	sp, #12
 80017d2:	bd00      	pop	{pc}
 80017d4:	f3af 8000 	nop.w
 80017d8:	f3af 8000 	nop.w
 80017dc:	f3af 8000 	nop.w

080017e0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector7C) {
 80017e0:	b500      	push	{lr}
 80017e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80017e4:	f001 fa5c 	bl	8002ca0 <_stats_increase_irq>
 80017e8:	f002 fd52 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0) & STM32_DMA_ISR_MASK;
 80017ec:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 80017f0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80017f4:	685b      	ldr	r3, [r3, #4]
 80017f6:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80017fa:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0;
 80017fc:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001800:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001804:	9a01      	ldr	r2, [sp, #4]
 8001806:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 8001808:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 800180c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001810:	6a1b      	ldr	r3, [r3, #32]
 8001812:	2b00      	cmp	r3, #0
 8001814:	d00c      	beq.n	8001830 <Vector7C+0x50>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8001816:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 800181a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800181e:	6a1a      	ldr	r2, [r3, #32]
 8001820:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001824:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001828:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800182a:	4618      	mov	r0, r3
 800182c:	9901      	ldr	r1, [sp, #4]
 800182e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001830:	f002 fd56 	bl	80042e0 <_dbg_check_leave_isr>
 8001834:	f001 ff24 	bl	8003680 <_port_irq_epilogue>
}
 8001838:	b003      	add	sp, #12
 800183a:	bd00      	pop	{pc}
 800183c:	f3af 8000 	nop.w

08001840 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector80) {
 8001840:	b500      	push	{lr}
 8001842:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001844:	f001 fa2c 	bl	8002ca0 <_stats_increase_irq>
 8001848:	f002 fd22 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6) & STM32_DMA_ISR_MASK;
 800184c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001850:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001854:	685b      	ldr	r3, [r3, #4]
 8001856:	ea4f 1393 	mov.w	r3, r3, lsr #6
 800185a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800185e:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6;
 8001860:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001864:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001868:	9a01      	ldr	r2, [sp, #4]
 800186a:	ea4f 1282 	mov.w	r2, r2, lsl #6
 800186e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 8001870:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001874:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001878:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800187a:	2b00      	cmp	r3, #0
 800187c:	d00c      	beq.n	8001898 <Vector80+0x58>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 800187e:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001882:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001886:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001888:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 800188c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001890:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001892:	4618      	mov	r0, r3
 8001894:	9901      	ldr	r1, [sp, #4]
 8001896:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001898:	f002 fd22 	bl	80042e0 <_dbg_check_leave_isr>
 800189c:	f001 fef0 	bl	8003680 <_port_irq_epilogue>
}
 80018a0:	b003      	add	sp, #12
 80018a2:	bd00      	pop	{pc}
 80018a4:	f3af 8000 	nop.w
 80018a8:	f3af 8000 	nop.w
 80018ac:	f3af 8000 	nop.w

080018b0 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector84) {
 80018b0:	b500      	push	{lr}
 80018b2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80018b4:	f001 f9f4 	bl	8002ca0 <_stats_increase_irq>
 80018b8:	f002 fcea 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16) & STM32_DMA_ISR_MASK;
 80018bc:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 80018c0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80018c4:	685b      	ldr	r3, [r3, #4]
 80018c6:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80018ca:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80018ce:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16;
 80018d0:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 80018d4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80018d8:	9a01      	ldr	r2, [sp, #4]
 80018da:	ea4f 4202 	mov.w	r2, r2, lsl #16
 80018de:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 80018e0:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80018e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80018ea:	2b00      	cmp	r3, #0
 80018ec:	d00c      	beq.n	8001908 <Vector84+0x58>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 80018ee:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80018f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018f6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80018f8:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80018fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001900:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001902:	4618      	mov	r0, r3
 8001904:	9901      	ldr	r1, [sp, #4]
 8001906:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001908:	f002 fcea 	bl	80042e0 <_dbg_check_leave_isr>
 800190c:	f001 feb8 	bl	8003680 <_port_irq_epilogue>
}
 8001910:	b003      	add	sp, #12
 8001912:	bd00      	pop	{pc}
 8001914:	f3af 8000 	nop.w
 8001918:	f3af 8000 	nop.w
 800191c:	f3af 8000 	nop.w

08001920 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorFC) {
 8001920:	b500      	push	{lr}
 8001922:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001924:	f001 f9bc 	bl	8002ca0 <_stats_increase_irq>
 8001928:	f002 fcb2 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22) & STM32_DMA_ISR_MASK;
 800192c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001930:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001934:	685b      	ldr	r3, [r3, #4]
 8001936:	ea4f 5393 	mov.w	r3, r3, lsr #22
 800193a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800193e:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22;
 8001940:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001944:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001948:	9a01      	ldr	r2, [sp, #4]
 800194a:	ea4f 5282 	mov.w	r2, r2, lsl #22
 800194e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 8001950:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001954:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001958:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800195a:	2b00      	cmp	r3, #0
 800195c:	d00c      	beq.n	8001978 <VectorFC+0x58>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 800195e:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001962:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001966:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001968:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 800196c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001970:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001972:	4618      	mov	r0, r3
 8001974:	9901      	ldr	r1, [sp, #4]
 8001976:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001978:	f002 fcb2 	bl	80042e0 <_dbg_check_leave_isr>
 800197c:	f001 fe80 	bl	8003680 <_port_irq_epilogue>
}
 8001980:	b003      	add	sp, #12
 8001982:	bd00      	pop	{pc}
 8001984:	f3af 8000 	nop.w
 8001988:	f3af 8000 	nop.w
 800198c:	f3af 8000 	nop.w

08001990 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector120) {
 8001990:	b500      	push	{lr}
 8001992:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001994:	f001 f984 	bl	8002ca0 <_stats_increase_irq>
 8001998:	f002 fc7a 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0) & STM32_DMA_ISR_MASK;
 800199c:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 80019a0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80019a4:	681b      	ldr	r3, [r3, #0]
 80019a6:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80019aa:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0;
 80019ac:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 80019b0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80019b4:	9a01      	ldr	r2, [sp, #4]
 80019b6:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 80019b8:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80019bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019c0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80019c2:	2b00      	cmp	r3, #0
 80019c4:	d00c      	beq.n	80019e0 <Vector120+0x50>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 80019c6:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80019ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019ce:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80019d0:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 80019d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019d8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80019da:	4618      	mov	r0, r3
 80019dc:	9901      	ldr	r1, [sp, #4]
 80019de:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80019e0:	f002 fc7e 	bl	80042e0 <_dbg_check_leave_isr>
 80019e4:	f001 fe4c 	bl	8003680 <_port_irq_epilogue>
}
 80019e8:	b003      	add	sp, #12
 80019ea:	bd00      	pop	{pc}
 80019ec:	f3af 8000 	nop.w

080019f0 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector124) {
 80019f0:	b500      	push	{lr}
 80019f2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80019f4:	f001 f954 	bl	8002ca0 <_stats_increase_irq>
 80019f8:	f002 fc4a 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6) & STM32_DMA_ISR_MASK;
 80019fc:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001a00:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001a04:	681b      	ldr	r3, [r3, #0]
 8001a06:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8001a0a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001a0e:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6;
 8001a10:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001a14:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001a18:	9a01      	ldr	r2, [sp, #4]
 8001a1a:	ea4f 1282 	mov.w	r2, r2, lsl #6
 8001a1e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 8001a20:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001a24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a28:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001a2a:	2b00      	cmp	r3, #0
 8001a2c:	d00c      	beq.n	8001a48 <Vector124+0x58>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8001a2e:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001a32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a36:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8001a38:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001a3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a40:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001a42:	4618      	mov	r0, r3
 8001a44:	9901      	ldr	r1, [sp, #4]
 8001a46:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001a48:	f002 fc4a 	bl	80042e0 <_dbg_check_leave_isr>
 8001a4c:	f001 fe18 	bl	8003680 <_port_irq_epilogue>
}
 8001a50:	b003      	add	sp, #12
 8001a52:	bd00      	pop	{pc}
 8001a54:	f3af 8000 	nop.w
 8001a58:	f3af 8000 	nop.w
 8001a5c:	f3af 8000 	nop.w

08001a60 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector128) {
 8001a60:	b500      	push	{lr}
 8001a62:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001a64:	f001 f91c 	bl	8002ca0 <_stats_increase_irq>
 8001a68:	f002 fc12 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16) & STM32_DMA_ISR_MASK;
 8001a6c:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001a70:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001a74:	681b      	ldr	r3, [r3, #0]
 8001a76:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8001a7a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001a7e:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16;
 8001a80:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001a84:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001a88:	9a01      	ldr	r2, [sp, #4]
 8001a8a:	ea4f 4202 	mov.w	r2, r2, lsl #16
 8001a8e:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 8001a90:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001a94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a98:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001a9a:	2b00      	cmp	r3, #0
 8001a9c:	d00c      	beq.n	8001ab8 <Vector128+0x58>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8001a9e:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001aa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001aa6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8001aa8:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001aac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001ab0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8001ab2:	4618      	mov	r0, r3
 8001ab4:	9901      	ldr	r1, [sp, #4]
 8001ab6:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001ab8:	f002 fc12 	bl	80042e0 <_dbg_check_leave_isr>
 8001abc:	f001 fde0 	bl	8003680 <_port_irq_epilogue>
}
 8001ac0:	b003      	add	sp, #12
 8001ac2:	bd00      	pop	{pc}
 8001ac4:	f3af 8000 	nop.w
 8001ac8:	f3af 8000 	nop.w
 8001acc:	f3af 8000 	nop.w

08001ad0 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector12C) {
 8001ad0:	b500      	push	{lr}
 8001ad2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001ad4:	f001 f8e4 	bl	8002ca0 <_stats_increase_irq>
 8001ad8:	f002 fbda 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22) & STM32_DMA_ISR_MASK;
 8001adc:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001ae0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001ae4:	681b      	ldr	r3, [r3, #0]
 8001ae6:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8001aea:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001aee:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22;
 8001af0:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001af4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001af8:	9a01      	ldr	r2, [sp, #4]
 8001afa:	ea4f 5282 	mov.w	r2, r2, lsl #22
 8001afe:	609a      	str	r2, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 8001b00:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001b04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b08:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001b0a:	2b00      	cmp	r3, #0
 8001b0c:	d00c      	beq.n	8001b28 <Vector12C+0x58>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8001b0e:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001b12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b16:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001b18:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001b1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b20:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001b22:	4618      	mov	r0, r3
 8001b24:	9901      	ldr	r1, [sp, #4]
 8001b26:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001b28:	f002 fbda 	bl	80042e0 <_dbg_check_leave_isr>
 8001b2c:	f001 fda8 	bl	8003680 <_port_irq_epilogue>
}
 8001b30:	b003      	add	sp, #12
 8001b32:	bd00      	pop	{pc}
 8001b34:	f3af 8000 	nop.w
 8001b38:	f3af 8000 	nop.w
 8001b3c:	f3af 8000 	nop.w

08001b40 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector130) {
 8001b40:	b500      	push	{lr}
 8001b42:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001b44:	f001 f8ac 	bl	8002ca0 <_stats_increase_irq>
 8001b48:	f002 fba2 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0) & STM32_DMA_ISR_MASK;
 8001b4c:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001b50:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b54:	685b      	ldr	r3, [r3, #4]
 8001b56:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001b5a:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0;
 8001b5c:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001b60:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b64:	9a01      	ldr	r2, [sp, #4]
 8001b66:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 8001b68:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001b6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b70:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001b72:	2b00      	cmp	r3, #0
 8001b74:	d00c      	beq.n	8001b90 <Vector130+0x50>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 8001b76:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001b7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b7e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001b80:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001b84:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b88:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001b8a:	4618      	mov	r0, r3
 8001b8c:	9901      	ldr	r1, [sp, #4]
 8001b8e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001b90:	f002 fba6 	bl	80042e0 <_dbg_check_leave_isr>
 8001b94:	f001 fd74 	bl	8003680 <_port_irq_epilogue>
}
 8001b98:	b003      	add	sp, #12
 8001b9a:	bd00      	pop	{pc}
 8001b9c:	f3af 8000 	nop.w

08001ba0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector150) {
 8001ba0:	b500      	push	{lr}
 8001ba2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001ba4:	f001 f87c 	bl	8002ca0 <_stats_increase_irq>
 8001ba8:	f002 fb72 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6) & STM32_DMA_ISR_MASK;
 8001bac:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001bb0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001bb4:	685b      	ldr	r3, [r3, #4]
 8001bb6:	ea4f 1393 	mov.w	r3, r3, lsr #6
 8001bba:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001bbe:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6;
 8001bc0:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001bc4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001bc8:	9a01      	ldr	r2, [sp, #4]
 8001bca:	ea4f 1282 	mov.w	r2, r2, lsl #6
 8001bce:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 8001bd0:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001bd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001bd8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8001bda:	2b00      	cmp	r3, #0
 8001bdc:	d00c      	beq.n	8001bf8 <Vector150+0x58>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8001bde:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001be2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001be6:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8001be8:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001bec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001bf0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001bf2:	4618      	mov	r0, r3
 8001bf4:	9901      	ldr	r1, [sp, #4]
 8001bf6:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001bf8:	f002 fb72 	bl	80042e0 <_dbg_check_leave_isr>
 8001bfc:	f001 fd40 	bl	8003680 <_port_irq_epilogue>
}
 8001c00:	b003      	add	sp, #12
 8001c02:	bd00      	pop	{pc}
 8001c04:	f3af 8000 	nop.w
 8001c08:	f3af 8000 	nop.w
 8001c0c:	f3af 8000 	nop.w

08001c10 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector154) {
 8001c10:	b500      	push	{lr}
 8001c12:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001c14:	f001 f844 	bl	8002ca0 <_stats_increase_irq>
 8001c18:	f002 fb3a 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16) & STM32_DMA_ISR_MASK;
 8001c1c:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001c20:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c24:	685b      	ldr	r3, [r3, #4]
 8001c26:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8001c2a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001c2e:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16;
 8001c30:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001c34:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c38:	9a01      	ldr	r2, [sp, #4]
 8001c3a:	ea4f 4202 	mov.w	r2, r2, lsl #16
 8001c3e:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 8001c40:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001c44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c48:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001c4a:	2b00      	cmp	r3, #0
 8001c4c:	d00c      	beq.n	8001c68 <Vector154+0x58>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8001c4e:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001c52:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c56:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001c58:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001c5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c60:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001c62:	4618      	mov	r0, r3
 8001c64:	9901      	ldr	r1, [sp, #4]
 8001c66:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001c68:	f002 fb3a 	bl	80042e0 <_dbg_check_leave_isr>
 8001c6c:	f001 fd08 	bl	8003680 <_port_irq_epilogue>
}
 8001c70:	b003      	add	sp, #12
 8001c72:	bd00      	pop	{pc}
 8001c74:	f3af 8000 	nop.w
 8001c78:	f3af 8000 	nop.w
 8001c7c:	f3af 8000 	nop.w

08001c80 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector158) {
 8001c80:	b500      	push	{lr}
 8001c82:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001c84:	f001 f80c 	bl	8002ca0 <_stats_increase_irq>
 8001c88:	f002 fb02 	bl	8004290 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22) & STM32_DMA_ISR_MASK;
 8001c8c:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001c90:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c94:	685b      	ldr	r3, [r3, #4]
 8001c96:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8001c9a:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001c9e:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22;
 8001ca0:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001ca4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001ca8:	9a01      	ldr	r2, [sp, #4]
 8001caa:	ea4f 5282 	mov.w	r2, r2, lsl #22
 8001cae:	60da      	str	r2, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 8001cb0:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001cb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001cb8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8001cba:	2b00      	cmp	r3, #0
 8001cbc:	d00c      	beq.n	8001cd8 <Vector158+0x58>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8001cbe:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001cc2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001cc6:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8001cc8:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001ccc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001cd0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8001cd2:	4618      	mov	r0, r3
 8001cd4:	9901      	ldr	r1, [sp, #4]
 8001cd6:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001cd8:	f002 fb02 	bl	80042e0 <_dbg_check_leave_isr>
 8001cdc:	f001 fcd0 	bl	8003680 <_port_irq_epilogue>
}
 8001ce0:	b003      	add	sp, #12
 8001ce2:	bd00      	pop	{pc}
 8001ce4:	f3af 8000 	nop.w
 8001ce8:	f3af 8000 	nop.w
 8001cec:	f3af 8000 	nop.w

08001cf0 <dmaInit.4389>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8001cf0:	b082      	sub	sp, #8
  int i;

  dma_streams_mask = 0;
 8001cf2:	f643 43b0 	movw	r3, #15536	; 0x3cb0
 8001cf6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001cfa:	f04f 0200 	mov.w	r2, #0
 8001cfe:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001d00:	f04f 0300 	mov.w	r3, #0
 8001d04:	9301      	str	r3, [sp, #4]
 8001d06:	e01c      	b.n	8001d42 <dmaInit.4389+0x52>
    _stm32_dma_streams[i].stream->CR = 0;
 8001d08:	f245 7290 	movw	r2, #22416	; 0x5790
 8001d0c:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001d10:	9901      	ldr	r1, [sp, #4]
 8001d12:	460b      	mov	r3, r1
 8001d14:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001d18:	185b      	adds	r3, r3, r1
 8001d1a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001d1e:	18d3      	adds	r3, r2, r3
 8001d20:	681b      	ldr	r3, [r3, #0]
 8001d22:	f04f 0200 	mov.w	r2, #0
 8001d26:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
 8001d28:	f643 43b4 	movw	r3, #15540	; 0x3cb4
 8001d2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001d30:	9a01      	ldr	r2, [sp, #4]
 8001d32:	f04f 0100 	mov.w	r1, #0
 8001d36:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001d3a:	9b01      	ldr	r3, [sp, #4]
 8001d3c:	f103 0301 	add.w	r3, r3, #1
 8001d40:	9301      	str	r3, [sp, #4]
 8001d42:	9b01      	ldr	r3, [sp, #4]
 8001d44:	2b0f      	cmp	r3, #15
 8001d46:	dddf      	ble.n	8001d08 <dmaInit.4389+0x18>
    _stm32_dma_streams[i].stream->CR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFF;
 8001d48:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001d4c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d50:	f04f 32ff 	mov.w	r2, #4294967295
 8001d54:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFF;
 8001d56:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001d5a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d5e:	f04f 32ff 	mov.w	r2, #4294967295
 8001d62:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFF;
 8001d64:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001d68:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d6c:	f04f 32ff 	mov.w	r2, #4294967295
 8001d70:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFF;
 8001d72:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
 8001d76:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d7a:	f04f 32ff 	mov.w	r2, #4294967295
 8001d7e:	60da      	str	r2, [r3, #12]
}
 8001d80:	b002      	add	sp, #8
 8001d82:	4770      	bx	lr
 8001d84:	f3af 8000 	nop.w
 8001d88:	f3af 8000 	nop.w
 8001d8c:	f3af 8000 	nop.w

08001d90 <hal_lld_backup_domain_init.9713.4387>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001d90:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8001d94:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001d98:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8001d9c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8001da0:	6812      	ldr	r2, [r2, #0]
 8001da2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001da6:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8001da8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001dac:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001db0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001db2:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8001db6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8001dba:	d00d      	beq.n	8001dd8 <hal_lld_backup_domain_init.9713.4387+0x48>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001dbc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001dc0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001dc4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001dc8:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8001dca:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001dce:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001dd2:	f04f 0200 	mov.w	r2, #0
 8001dd6:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8001dd8:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8001ddc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001de0:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8001de4:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8001de8:	6852      	ldr	r2, [r2, #4]
 8001dea:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001dee:	605a      	str	r2, [r3, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 8001df0:	4770      	bx	lr
 8001df2:	bf00      	nop
 8001df4:	f3af 8000 	nop.w
 8001df8:	f3af 8000 	nop.w
 8001dfc:	f3af 8000 	nop.w

08001e00 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8001e00:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8001e02:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e06:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e0a:	691b      	ldr	r3, [r3, #16]
 8001e0c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e10:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e14:	f04f 32ff 	mov.w	r2, #4294967295
 8001e18:	611a      	str	r2, [r3, #16]
 8001e1a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e1e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e22:	f04f 0200 	mov.w	r2, #0
 8001e26:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8001e28:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e2c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e30:	695b      	ldr	r3, [r3, #20]
 8001e32:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e36:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e3a:	f04f 32ff 	mov.w	r2, #4294967295
 8001e3e:	615a      	str	r2, [r3, #20]
 8001e40:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e44:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e48:	f04f 0200 	mov.w	r2, #0
 8001e4c:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8001e4e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e52:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e56:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001e5a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001e5e:	6a12      	ldr	r2, [r2, #32]
 8001e60:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 8001e64:	621a      	str	r2, [r3, #32]
 8001e66:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e6a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e6e:	f04f 0200 	mov.w	r2, #0
 8001e72:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8001e74:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e78:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e7c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001e7e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e82:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e86:	f04f 32ff 	mov.w	r2, #4294967295
 8001e8a:	625a      	str	r2, [r3, #36]	; 0x24
 8001e8c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e90:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e94:	f04f 0200 	mov.w	r2, #0
 8001e98:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001e9a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e9e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001ea2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001ea6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001eaa:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8001eac:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001eb0:	641a      	str	r2, [r3, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8001eb2:	f7ff ff6d 	bl	8001d90 <hal_lld_backup_domain_init.9713.4387>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8001eb6:	f7ff ff1b 	bl	8001cf0 <dmaInit.4389>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8001eba:	bd08      	pop	{r3, pc}
 8001ebc:	f3af 8000 	nop.w

08001ec0 <stm32_clock_init.4382>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001ec0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001ec4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001ec8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001ecc:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001ece:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8001ed2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001ed6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8001eda:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001edc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001ee0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001ee4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001ee8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001eec:	6812      	ldr	r2, [r2, #0]
 8001eee:	f042 0201 	orr.w	r2, r2, #1
 8001ef2:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001ef4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001ef8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001efc:	681b      	ldr	r3, [r3, #0]
 8001efe:	f003 0302 	and.w	r3, r3, #2
 8001f02:	2b00      	cmp	r3, #0
 8001f04:	d0f6      	beq.n	8001ef4 <stm32_clock_init.4382+0x34>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001f06:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001f0a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f0e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001f12:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001f16:	6892      	ldr	r2, [r2, #8]
 8001f18:	f022 0203 	bic.w	r2, r2, #3
 8001f1c:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001f1e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001f22:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f26:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001f2a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001f2e:	6892      	ldr	r2, [r2, #8]
 8001f30:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001f32:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001f36:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f3a:	689b      	ldr	r3, [r3, #8]
 8001f3c:	f003 030c 	and.w	r3, r3, #12
 8001f40:	2b00      	cmp	r3, #0
 8001f42:	d1f6      	bne.n	8001f32 <stm32_clock_init.4382+0x72>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001f44:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001f48:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f4c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001f50:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001f54:	6812      	ldr	r2, [r2, #0]
 8001f56:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
 8001f5a:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001f5c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001f60:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f64:	f04f 0200 	mov.w	r2, #0
 8001f68:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8001f6a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001f6e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f72:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001f76:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001f7a:	6812      	ldr	r2, [r2, #0]
 8001f7c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001f80:	601a      	str	r2, [r3, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8001f82:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001f86:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f8a:	681b      	ldr	r3, [r3, #0]
 8001f8c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001f90:	2b00      	cmp	r3, #0
 8001f92:	d0f6      	beq.n	8001f82 <stm32_clock_init.4382+0xc2>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001f94:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001f98:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f9c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001fa0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001fa4:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8001fa6:	f042 0201 	orr.w	r2, r2, #1
 8001faa:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001fac:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001fb0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001fb4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001fb6:	f003 0302 	and.w	r3, r3, #2
 8001fba:	2b00      	cmp	r3, #0
 8001fbc:	d0f6      	beq.n	8001fac <stm32_clock_init.4382+0xec>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8001fbe:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001fc2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001fc6:	f244 2208 	movw	r2, #16904	; 0x4208
 8001fca:	f2c0 6240 	movt	r2, #1600	; 0x640
 8001fce:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001fd0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001fd4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001fd8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001fdc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001fe0:	6812      	ldr	r2, [r2, #0]
 8001fe2:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001fe6:	601a      	str	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001fe8:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8001fec:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001ff0:	685b      	ldr	r3, [r3, #4]
 8001ff2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001ff6:	2b00      	cmp	r3, #0
 8001ff8:	d0f6      	beq.n	8001fe8 <stm32_clock_init.4382+0x128>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001ffa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001ffe:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002002:	681b      	ldr	r3, [r3, #0]
 8002004:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002008:	2b00      	cmp	r3, #0
 800200a:	d0f6      	beq.n	8001ffa <stm32_clock_init.4382+0x13a>
    ;
#endif /* STM32_OVERDRIVE_REQUIRED */

#if STM32_ACTIVATE_PLLI2S
  /* PLLI2S activation.*/
  RCC->PLLI2SCFGR = STM32_PLLI2SR | STM32_PLLI2SN;
 800200c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002010:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002014:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 8002018:	f2c5 0200 	movt	r2, #20480	; 0x5000
 800201c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  RCC->CR |= RCC_CR_PLLI2SON;
 8002020:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002024:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002028:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800202c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002030:	6812      	ldr	r2, [r2, #0]
 8002032:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8002036:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
 8002038:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800203c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002040:	681b      	ldr	r3, [r3, #0]
 8002042:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8002046:	2b00      	cmp	r3, #0
 8002048:	d0f6      	beq.n	8002038 <stm32_clock_init.4382+0x178>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 800204a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800204e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002052:	f44f 4214 	mov.w	r2, #37888	; 0x9400
 8002056:	f6c3 0208 	movt	r2, #14344	; 0x3808
 800205a:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800205c:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8002060:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002064:	f240 7204 	movw	r2, #1796	; 0x704
 8002068:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800206a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800206e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002072:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002076:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800207a:	6892      	ldr	r2, [r2, #8]
 800207c:	f042 0202 	orr.w	r2, r2, #2
 8002080:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8002082:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002086:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800208a:	689b      	ldr	r3, [r3, #8]
 800208c:	f003 030c 	and.w	r3, r3, #12
 8002090:	2b08      	cmp	r3, #8
 8002092:	d1f6      	bne.n	8002082 <stm32_clock_init.4382+0x1c2>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8002094:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002098:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800209c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80020a0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80020a4:	6c52      	ldr	r2, [r2, #68]	; 0x44
 80020a6:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80020aa:	645a      	str	r2, [r3, #68]	; 0x44
 80020ac:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80020b0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80020b4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80020b8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80020bc:	6e52      	ldr	r2, [r2, #100]	; 0x64
 80020be:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80020c2:	665a      	str	r2, [r3, #100]	; 0x64
}
 80020c4:	4770      	bx	lr
 80020c6:	bf00      	nop
 80020c8:	f3af 8000 	nop.w
 80020cc:	f3af 8000 	nop.w

080020d0 <port_lock.9768.4380>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80020d0:	b082      	sub	sp, #8
 80020d2:	f04f 0320 	mov.w	r3, #32
 80020d6:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80020d8:	9b01      	ldr	r3, [sp, #4]
 80020da:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80020de:	b002      	add	sp, #8
 80020e0:	4770      	bx	lr
 80020e2:	bf00      	nop
 80020e4:	f3af 8000 	nop.w
 80020e8:	f3af 8000 	nop.w
 80020ec:	f3af 8000 	nop.w

080020f0 <port_unlock.9771.4378>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80020f0:	b082      	sub	sp, #8
 80020f2:	f04f 0300 	mov.w	r3, #0
 80020f6:	9301      	str	r3, [sp, #4]
 80020f8:	9b01      	ldr	r3, [sp, #4]
 80020fa:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80020fe:	b002      	add	sp, #8
 8002100:	4770      	bx	lr
 8002102:	bf00      	nop
 8002104:	f3af 8000 	nop.w
 8002108:	f3af 8000 	nop.w
 800210c:	f3af 8000 	nop.w

08002110 <port_lock_from_isr.9773.4376>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002110:	b508      	push	{r3, lr}

  port_lock();
 8002112:	f7ff ffdd 	bl	80020d0 <port_lock.9768.4380>
}
 8002116:	bd08      	pop	{r3, pc}
 8002118:	f3af 8000 	nop.w
 800211c:	f3af 8000 	nop.w

08002120 <port_unlock_from_isr.9775.4374>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002120:	b508      	push	{r3, lr}

  port_unlock();
 8002122:	f7ff ffe5 	bl	80020f0 <port_unlock.9771.4378>
}
 8002126:	bd08      	pop	{r3, pc}
 8002128:	f3af 8000 	nop.w
 800212c:	f3af 8000 	nop.w

08002130 <chSysLockFromISR.9777.4372>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002130:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002132:	f7ff ffed 	bl	8002110 <port_lock_from_isr.9773.4376>
  _stats_start_measure_crit_isr();
 8002136:	f000 fdf3 	bl	8002d20 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800213a:	f002 f869 	bl	8004210 <_dbg_check_lock_from_isr>
}
 800213e:	bd08      	pop	{r3, pc}

08002140 <chSysUnlockFromISR.9783.4370>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002140:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8002142:	f002 f885 	bl	8004250 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8002146:	f000 fdf3 	bl	8002d30 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800214a:	f7ff ffe9 	bl	8002120 <port_unlock_from_isr.9775.4374>
}
 800214e:	bd08      	pop	{r3, pc}

08002150 <osalSysLockFromISR.9779.4368>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8002150:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8002152:	f7ff ffed 	bl	8002130 <chSysLockFromISR.9777.4372>
}
 8002156:	bd08      	pop	{r3, pc}
 8002158:	f3af 8000 	nop.w
 800215c:	f3af 8000 	nop.w

08002160 <osalSysUnlockFromISR.9785.4366>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8002160:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8002162:	f7ff ffed 	bl	8002140 <chSysUnlockFromISR.9783.4370>
}
 8002166:	bd08      	pop	{r3, pc}
 8002168:	f3af 8000 	nop.w
 800216c:	f3af 8000 	nop.w

08002170 <osalOsTimerHandlerI.9781.4364>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8002170:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8002172:	f001 ffa5 	bl	80040c0 <chSysTimerHandlerI>
}
 8002176:	bd08      	pop	{r3, pc}
 8002178:	f3af 8000 	nop.w
 800217c:	f3af 8000 	nop.w

08002180 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8002180:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8002182:	f000 fd8d 	bl	8002ca0 <_stats_increase_irq>
 8002186:	f002 f883 	bl	8004290 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800218a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800218e:	691b      	ldr	r3, [r3, #16]
 8002190:	f003 0302 	and.w	r3, r3, #2
 8002194:	2b00      	cmp	r3, #0
 8002196:	d00a      	beq.n	80021ae <VectorB0+0x2e>
    STM32_ST_TIM->SR = 0U;
 8002198:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800219c:	f04f 0200 	mov.w	r2, #0
 80021a0:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 80021a2:	f7ff ffd5 	bl	8002150 <osalSysLockFromISR.9779.4368>
    osalOsTimerHandlerI();
 80021a6:	f7ff ffe3 	bl	8002170 <osalOsTimerHandlerI.9781.4364>
    osalSysUnlockFromISR();
 80021aa:	f7ff ffd9 	bl	8002160 <osalSysUnlockFromISR.9785.4366>
  }

  OSAL_IRQ_EPILOGUE();
 80021ae:	f002 f897 	bl	80042e0 <_dbg_check_leave_isr>
 80021b2:	f001 fa65 	bl	8003680 <_port_irq_epilogue>
}
 80021b6:	bd08      	pop	{r3, pc}
 80021b8:	f3af 8000 	nop.w
 80021bc:	f3af 8000 	nop.w

080021c0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80021c0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80021c2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80021c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80021ca:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80021ce:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80021d2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80021d4:	f042 0201 	orr.w	r2, r2, #1
 80021d8:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80021da:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80021de:	f2ce 0304 	movt	r3, #57348	; 0xe004
 80021e2:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80021e6:	f2ce 0204 	movt	r2, #57348	; 0xe004
 80021ea:	6892      	ldr	r2, [r2, #8]
 80021ec:	f042 0201 	orr.w	r2, r2, #1
 80021f0:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80021f2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80021f6:	f641 12c7 	movw	r2, #6599	; 0x19c7
 80021fa:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80021fc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002200:	f04f 32ff 	mov.w	r2, #4294967295
 8002204:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8002206:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800220a:	f04f 0200 	mov.w	r2, #0
 800220e:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002210:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002214:	f04f 0200 	mov.w	r2, #0
 8002218:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 800221a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800221e:	f04f 0200 	mov.w	r2, #0
 8002222:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8002224:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002228:	f04f 0200 	mov.w	r2, #0
 800222c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800222e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002232:	f04f 0201 	mov.w	r2, #1
 8002236:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002238:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800223c:	f04f 0201 	mov.w	r2, #1
 8002240:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8002242:	f04f 001c 	mov.w	r0, #28
 8002246:	f04f 0108 	mov.w	r1, #8
 800224a:	f7ff f9b9 	bl	80015c0 <nvicEnableVector.4424>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 800224e:	bd08      	pop	{r3, pc}

08002250 <dac_lld_init>:
/**
 * @brief   Low level DAC driver initialization.
 *
 * @notapi
 */
void dac_lld_init(void) {
 8002250:	b508      	push	{r3, lr}

#if STM32_DAC_USE_DAC1_CH1
  dacObjectInit(&DACD1);
 8002252:	f643 5034 	movw	r0, #15668	; 0x3d34
 8002256:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800225a:	f001 faf1 	bl	8003840 <dacObjectInit>
  DACD1.params  = &dma1_ch1_params;
 800225e:	f643 5334 	movw	r3, #15668	; 0x3d34
 8002262:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002266:	f645 0250 	movw	r2, #22608	; 0x5850
 800226a:	f6c0 0200 	movt	r2, #2048	; 0x800
 800226e:	629a      	str	r2, [r3, #40]	; 0x28
#endif

#if STM32_DAC_USE_DAC1_CH2
  dacObjectInit(&DACD2);
 8002270:	f643 5060 	movw	r0, #15712	; 0x3d60
 8002274:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002278:	f001 fae2 	bl	8003840 <dacObjectInit>
  DACD2.params  = &dma1_ch2_params;
 800227c:	f643 5360 	movw	r3, #15712	; 0x3d60
 8002280:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002284:	f645 0270 	movw	r2, #22640	; 0x5870
 8002288:	f6c0 0200 	movt	r2, #2048	; 0x800
 800228c:	629a      	str	r2, [r3, #40]	; 0x28

#if STM32_DAC_USE_DAC2_CH2
  dacObjectInit(&DACD4);
  DACD4.params  = &dma2_ch2_params;
#endif
}
 800228e:	bd08      	pop	{r3, pc}

08002290 <initgpio.10120.4344>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8002290:	b082      	sub	sp, #8
 8002292:	9001      	str	r0, [sp, #4]
 8002294:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8002296:	9b00      	ldr	r3, [sp, #0]
 8002298:	685a      	ldr	r2, [r3, #4]
 800229a:	9b01      	ldr	r3, [sp, #4]
 800229c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800229e:	9b00      	ldr	r3, [sp, #0]
 80022a0:	689a      	ldr	r2, [r3, #8]
 80022a2:	9b01      	ldr	r3, [sp, #4]
 80022a4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80022a6:	9b00      	ldr	r3, [sp, #0]
 80022a8:	68da      	ldr	r2, [r3, #12]
 80022aa:	9b01      	ldr	r3, [sp, #4]
 80022ac:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80022ae:	9b00      	ldr	r3, [sp, #0]
 80022b0:	691a      	ldr	r2, [r3, #16]
 80022b2:	9b01      	ldr	r3, [sp, #4]
 80022b4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80022b6:	9b00      	ldr	r3, [sp, #0]
 80022b8:	695a      	ldr	r2, [r3, #20]
 80022ba:	9b01      	ldr	r3, [sp, #4]
 80022bc:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80022be:	9b00      	ldr	r3, [sp, #0]
 80022c0:	699a      	ldr	r2, [r3, #24]
 80022c2:	9b01      	ldr	r3, [sp, #4]
 80022c4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80022c6:	9b00      	ldr	r3, [sp, #0]
 80022c8:	681a      	ldr	r2, [r3, #0]
 80022ca:	9b01      	ldr	r3, [sp, #4]
 80022cc:	601a      	str	r2, [r3, #0]
}
 80022ce:	b002      	add	sp, #8
 80022d0:	4770      	bx	lr
 80022d2:	bf00      	nop
 80022d4:	f3af 8000 	nop.w
 80022d8:	f3af 8000 	nop.w
 80022dc:	f3af 8000 	nop.w

080022e0 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 80022e0:	b500      	push	{lr}
 80022e2:	b083      	sub	sp, #12
 80022e4:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80022e6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80022ea:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80022ee:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80022f2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80022f6:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80022f8:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 80022fc:	ea6f 2242 	mvn.w	r2, r2, lsl #9
 8002300:	631a      	str	r2, [r3, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8002302:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002306:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800230a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800230e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002312:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8002314:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 8002318:	ea6f 2242 	mvn.w	r2, r2, lsl #9
 800231c:	651a      	str	r2, [r3, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 800231e:	9b01      	ldr	r3, [sp, #4]
 8002320:	f04f 0000 	mov.w	r0, #0
 8002324:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002328:	4619      	mov	r1, r3
 800232a:	f7ff ffb1 	bl	8002290 <initgpio.10120.4344>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 800232e:	9b01      	ldr	r3, [sp, #4]
 8002330:	f103 031c 	add.w	r3, r3, #28
 8002334:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8002338:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800233c:	4619      	mov	r1, r3
 800233e:	f7ff ffa7 	bl	8002290 <initgpio.10120.4344>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 8002342:	9b01      	ldr	r3, [sp, #4]
 8002344:	f103 0338 	add.w	r3, r3, #56	; 0x38
 8002348:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800234c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002350:	4619      	mov	r1, r3
 8002352:	f7ff ff9d 	bl	8002290 <initgpio.10120.4344>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 8002356:	9b01      	ldr	r3, [sp, #4]
 8002358:	f103 0354 	add.w	r3, r3, #84	; 0x54
 800235c:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8002360:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002364:	4619      	mov	r1, r3
 8002366:	f7ff ff93 	bl	8002290 <initgpio.10120.4344>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 800236a:	9b01      	ldr	r3, [sp, #4]
 800236c:	f103 0370 	add.w	r3, r3, #112	; 0x70
 8002370:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8002374:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002378:	4619      	mov	r1, r3
 800237a:	f7ff ff89 	bl	8002290 <initgpio.10120.4344>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 800237e:	9b01      	ldr	r3, [sp, #4]
 8002380:	f103 038c 	add.w	r3, r3, #140	; 0x8c
 8002384:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
 8002388:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800238c:	4619      	mov	r1, r3
 800238e:	f7ff ff7f 	bl	8002290 <initgpio.10120.4344>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
 8002392:	9b01      	ldr	r3, [sp, #4]
 8002394:	f103 03a8 	add.w	r3, r3, #168	; 0xa8
 8002398:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 800239c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80023a0:	4619      	mov	r1, r3
 80023a2:	f7ff ff75 	bl	8002290 <initgpio.10120.4344>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 80023a6:	9b01      	ldr	r3, [sp, #4]
 80023a8:	f103 03c4 	add.w	r3, r3, #196	; 0xc4
 80023ac:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
 80023b0:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80023b4:	4619      	mov	r1, r3
 80023b6:	f7ff ff6b 	bl	8002290 <initgpio.10120.4344>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
 80023ba:	9b01      	ldr	r3, [sp, #4]
 80023bc:	f103 03e0 	add.w	r3, r3, #224	; 0xe0
 80023c0:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80023c4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80023c8:	4619      	mov	r1, r3
 80023ca:	f7ff ff61 	bl	8002290 <initgpio.10120.4344>
#endif
}
 80023ce:	b003      	add	sp, #12
 80023d0:	bd00      	pop	{pc}
 80023d2:	bf00      	nop
 80023d4:	f3af 8000 	nop.w
 80023d8:	f3af 8000 	nop.w
 80023dc:	f3af 8000 	nop.w

080023e0 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80023e0:	b08e      	sub	sp, #56	; 0x38
 80023e2:	9003      	str	r0, [sp, #12]
 80023e4:	9102      	str	r1, [sp, #8]
 80023e6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80023e8:	9b01      	ldr	r3, [sp, #4]
 80023ea:	f003 0303 	and.w	r3, r3, #3
 80023ee:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 80023f0:	9b01      	ldr	r3, [sp, #4]
 80023f2:	f003 0304 	and.w	r3, r3, #4
 80023f6:	ea4f 0393 	mov.w	r3, r3, lsr #2
 80023fa:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 80023fc:	9b01      	ldr	r3, [sp, #4]
 80023fe:	f003 0318 	and.w	r3, r3, #24
 8002402:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8002406:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 8002408:	9b01      	ldr	r3, [sp, #4]
 800240a:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800240e:	ea4f 1353 	mov.w	r3, r3, lsr #5
 8002412:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8002414:	9b01      	ldr	r3, [sp, #4]
 8002416:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
 800241a:	ea4f 13d3 	mov.w	r3, r3, lsr #7
 800241e:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8002420:	f04f 0300 	mov.w	r3, #0
 8002424:	9309      	str	r3, [sp, #36]	; 0x24
  while (TRUE) {
    if ((mask & 1) != 0) {
 8002426:	9b02      	ldr	r3, [sp, #8]
 8002428:	f003 0301 	and.w	r3, r3, #1
 800242c:	2b00      	cmp	r3, #0
 800242e:	d060      	beq.n	80024f2 <_pal_lld_setgroupmode+0x112>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8002430:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002432:	f003 0307 	and.w	r3, r3, #7
 8002436:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800243a:	9a08      	ldr	r2, [sp, #32]
 800243c:	fa02 f303 	lsl.w	r3, r2, r3
 8002440:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
 8002442:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002444:	f003 0307 	and.w	r3, r3, #7
 8002448:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800244c:	f04f 020f 	mov.w	r2, #15
 8002450:	fa02 f303 	lsl.w	r3, r2, r3
 8002454:	9306      	str	r3, [sp, #24]
      if (bit < 8)
 8002456:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002458:	2b07      	cmp	r3, #7
 800245a:	d80a      	bhi.n	8002472 <_pal_lld_setgroupmode+0x92>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 800245c:	9b03      	ldr	r3, [sp, #12]
 800245e:	6a1a      	ldr	r2, [r3, #32]
 8002460:	9b06      	ldr	r3, [sp, #24]
 8002462:	ea6f 0303 	mvn.w	r3, r3
 8002466:	401a      	ands	r2, r3
 8002468:	9b07      	ldr	r3, [sp, #28]
 800246a:	431a      	orrs	r2, r3
 800246c:	9b03      	ldr	r3, [sp, #12]
 800246e:	621a      	str	r2, [r3, #32]
 8002470:	e009      	b.n	8002486 <_pal_lld_setgroupmode+0xa6>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8002472:	9b03      	ldr	r3, [sp, #12]
 8002474:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002476:	9b06      	ldr	r3, [sp, #24]
 8002478:	ea6f 0303 	mvn.w	r3, r3
 800247c:	401a      	ands	r2, r3
 800247e:	9b07      	ldr	r3, [sp, #28]
 8002480:	431a      	orrs	r2, r3
 8002482:	9b03      	ldr	r3, [sp, #12]
 8002484:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
 8002486:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002488:	f04f 0201 	mov.w	r2, #1
 800248c:	fa02 f303 	lsl.w	r3, r2, r3
 8002490:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8002492:	9b03      	ldr	r3, [sp, #12]
 8002494:	685a      	ldr	r2, [r3, #4]
 8002496:	9b05      	ldr	r3, [sp, #20]
 8002498:	ea6f 0303 	mvn.w	r3, r3
 800249c:	401a      	ands	r2, r3
 800249e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80024a0:	431a      	orrs	r2, r3
 80024a2:	9b03      	ldr	r3, [sp, #12]
 80024a4:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
 80024a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80024a8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80024ac:	f04f 0203 	mov.w	r2, #3
 80024b0:	fa02 f303 	lsl.w	r3, r2, r3
 80024b4:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80024b6:	9b03      	ldr	r3, [sp, #12]
 80024b8:	689a      	ldr	r2, [r3, #8]
 80024ba:	9b04      	ldr	r3, [sp, #16]
 80024bc:	ea6f 0303 	mvn.w	r3, r3
 80024c0:	401a      	ands	r2, r3
 80024c2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80024c4:	431a      	orrs	r2, r3
 80024c6:	9b03      	ldr	r3, [sp, #12]
 80024c8:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80024ca:	9b03      	ldr	r3, [sp, #12]
 80024cc:	68da      	ldr	r2, [r3, #12]
 80024ce:	9b04      	ldr	r3, [sp, #16]
 80024d0:	ea6f 0303 	mvn.w	r3, r3
 80024d4:	401a      	ands	r2, r3
 80024d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80024d8:	431a      	orrs	r2, r3
 80024da:	9b03      	ldr	r3, [sp, #12]
 80024dc:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 80024de:	9b03      	ldr	r3, [sp, #12]
 80024e0:	681a      	ldr	r2, [r3, #0]
 80024e2:	9b04      	ldr	r3, [sp, #16]
 80024e4:	ea6f 0303 	mvn.w	r3, r3
 80024e8:	401a      	ands	r2, r3
 80024ea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80024ec:	431a      	orrs	r2, r3
 80024ee:	9b03      	ldr	r3, [sp, #12]
 80024f0:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
 80024f2:	9b02      	ldr	r3, [sp, #8]
 80024f4:	ea4f 0353 	mov.w	r3, r3, lsr #1
 80024f8:	9302      	str	r3, [sp, #8]
    if (!mask)
 80024fa:	9b02      	ldr	r3, [sp, #8]
 80024fc:	2b00      	cmp	r3, #0
 80024fe:	d014      	beq.n	800252a <_pal_lld_setgroupmode+0x14a>
      return;
    otyper <<= 1;
 8002500:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8002502:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8002506:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 8002508:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800250a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800250e:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 8002510:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002512:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002516:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8002518:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800251a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800251e:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 8002520:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002522:	f103 0301 	add.w	r3, r3, #1
 8002526:	9309      	str	r3, [sp, #36]	; 0x24
 8002528:	e77d      	b.n	8002426 <_pal_lld_setgroupmode+0x46>
  }
}
 800252a:	b00e      	add	sp, #56	; 0x38
 800252c:	4770      	bx	lr
 800252e:	bf00      	nop

08002530 <gpt_lld_serve_interrupt.10266.4288>:
/**
 * @brief   Shared IRQ handler.
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 */
static void gpt_lld_serve_interrupt(GPTDriver *gptp) {
 8002530:	b500      	push	{lr}
 8002532:	b083      	sub	sp, #12
 8002534:	9001      	str	r0, [sp, #4]

  gptp->tim->SR = 0;
 8002536:	9b01      	ldr	r3, [sp, #4]
 8002538:	68db      	ldr	r3, [r3, #12]
 800253a:	f04f 0200 	mov.w	r2, #0
 800253e:	611a      	str	r2, [r3, #16]
  if (gptp->state == GPT_ONESHOT) {
 8002540:	9b01      	ldr	r3, [sp, #4]
 8002542:	781b      	ldrb	r3, [r3, #0]
 8002544:	2b04      	cmp	r3, #4
 8002546:	d106      	bne.n	8002556 <gpt_lld_serve_interrupt.10266.4288+0x26>
    gptp->state = GPT_READY;                /* Back in GPT_READY state.     */
 8002548:	9b01      	ldr	r3, [sp, #4]
 800254a:	f04f 0202 	mov.w	r2, #2
 800254e:	701a      	strb	r2, [r3, #0]
    gpt_lld_stop_timer(gptp);               /* Timer automatically stopped. */
 8002550:	9801      	ldr	r0, [sp, #4]
 8002552:	f000 f84d 	bl	80025f0 <gpt_lld_stop_timer.4239>
  }
  gptp->config->callback(gptp);
 8002556:	9b01      	ldr	r3, [sp, #4]
 8002558:	685b      	ldr	r3, [r3, #4]
 800255a:	685b      	ldr	r3, [r3, #4]
 800255c:	9801      	ldr	r0, [sp, #4]
 800255e:	4798      	blx	r3
}
 8002560:	b003      	add	sp, #12
 8002562:	bd00      	pop	{pc}
 8002564:	f3af 8000 	nop.w
 8002568:	f3af 8000 	nop.w
 800256c:	f3af 8000 	nop.w

08002570 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8002570:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8002572:	f000 fb95 	bl	8002ca0 <_stats_increase_irq>
 8002576:	f001 fe8b 	bl	8004290 <_dbg_check_enter_isr>

  gpt_lld_serve_interrupt(&GPTD4);
 800257a:	f643 508c 	movw	r0, #15756	; 0x3d8c
 800257e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002582:	f7ff ffd5 	bl	8002530 <gpt_lld_serve_interrupt.10266.4288>

  OSAL_IRQ_EPILOGUE();
 8002586:	f001 feab 	bl	80042e0 <_dbg_check_leave_isr>
 800258a:	f001 f879 	bl	8003680 <_port_irq_epilogue>
}
 800258e:	bd08      	pop	{r3, pc}

08002590 <Vector118>:
/**
 * @brief   TIM6 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM6_HANDLER) {
 8002590:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8002592:	f000 fb85 	bl	8002ca0 <_stats_increase_irq>
 8002596:	f001 fe7b 	bl	8004290 <_dbg_check_enter_isr>

  gpt_lld_serve_interrupt(&GPTD6);
 800259a:	f643 509c 	movw	r0, #15772	; 0x3d9c
 800259e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80025a2:	f7ff ffc5 	bl	8002530 <gpt_lld_serve_interrupt.10266.4288>

  OSAL_IRQ_EPILOGUE();
 80025a6:	f001 fe9b 	bl	80042e0 <_dbg_check_leave_isr>
 80025aa:	f001 f869 	bl	8003680 <_port_irq_epilogue>
}
 80025ae:	bd08      	pop	{r3, pc}

080025b0 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
 80025b0:	b508      	push	{r3, lr}
  gptObjectInit(&GPTD3);
#endif

#if STM32_GPT_USE_TIM4
  /* Driver initialization.*/
  GPTD4.tim = STM32_TIM4;
 80025b2:	f643 538c 	movw	r3, #15756	; 0x3d8c
 80025b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80025ba:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80025be:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80025c2:	60da      	str	r2, [r3, #12]
  gptObjectInit(&GPTD4);
 80025c4:	f643 508c 	movw	r0, #15756	; 0x3d8c
 80025c8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80025cc:	f001 f958 	bl	8003880 <gptObjectInit>
  gptObjectInit(&GPTD5);
#endif

#if STM32_GPT_USE_TIM6
  /* Driver initialization.*/
  GPTD6.tim = STM32_TIM6;
 80025d0:	f643 539c 	movw	r3, #15772	; 0x3d9c
 80025d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80025d8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80025dc:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80025e0:	60da      	str	r2, [r3, #12]
  gptObjectInit(&GPTD6);
 80025e2:	f643 509c 	movw	r0, #15772	; 0x3d9c
 80025e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80025ea:	f001 f949 	bl	8003880 <gptObjectInit>
#if STM32_GPT_USE_TIM14
  /* Driver initialization.*/
  GPTD14.tim = STM32_TIM14;
  gptObjectInit(&GPTD14);
#endif
}
 80025ee:	bd08      	pop	{r3, pc}

080025f0 <gpt_lld_stop_timer.4239>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {
 80025f0:	b082      	sub	sp, #8
 80025f2:	9001      	str	r0, [sp, #4]

  gptp->tim->CR1   = 0;                         /* Initially stopped.       */
 80025f4:	9b01      	ldr	r3, [sp, #4]
 80025f6:	68db      	ldr	r3, [r3, #12]
 80025f8:	f04f 0200 	mov.w	r2, #0
 80025fc:	601a      	str	r2, [r3, #0]
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
 80025fe:	9b01      	ldr	r3, [sp, #4]
 8002600:	68db      	ldr	r3, [r3, #12]
 8002602:	f04f 0200 	mov.w	r2, #0
 8002606:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8002608:	9b01      	ldr	r3, [sp, #4]
 800260a:	68db      	ldr	r3, [r3, #12]
 800260c:	9a01      	ldr	r2, [sp, #4]
 800260e:	68d2      	ldr	r2, [r2, #12]
 8002610:	68d2      	ldr	r2, [r2, #12]
 8002612:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8002616:	60da      	str	r2, [r3, #12]
}
 8002618:	b002      	add	sp, #8
 800261a:	4770      	bx	lr
 800261c:	f3af 8000 	nop.w

08002620 <port_lock.10322.4237>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002620:	b082      	sub	sp, #8
 8002622:	f04f 0320 	mov.w	r3, #32
 8002626:	9301      	str	r3, [sp, #4]
 8002628:	9b01      	ldr	r3, [sp, #4]
 800262a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800262e:	b002      	add	sp, #8
 8002630:	4770      	bx	lr
 8002632:	bf00      	nop
 8002634:	f3af 8000 	nop.w
 8002638:	f3af 8000 	nop.w
 800263c:	f3af 8000 	nop.w

08002640 <port_unlock.10325.4235>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002640:	b082      	sub	sp, #8
 8002642:	f04f 0300 	mov.w	r3, #0
 8002646:	9301      	str	r3, [sp, #4]
 8002648:	9b01      	ldr	r3, [sp, #4]
 800264a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800264e:	b002      	add	sp, #8
 8002650:	4770      	bx	lr
 8002652:	bf00      	nop
 8002654:	f3af 8000 	nop.w
 8002658:	f3af 8000 	nop.w
 800265c:	f3af 8000 	nop.w

08002660 <port_lock_from_isr.10327.4233>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002660:	b508      	push	{r3, lr}

  port_lock();
 8002662:	f7ff ffdd 	bl	8002620 <port_lock.10322.4237>
}
 8002666:	bd08      	pop	{r3, pc}
 8002668:	f3af 8000 	nop.w
 800266c:	f3af 8000 	nop.w

08002670 <port_unlock_from_isr.10329.4231>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002670:	b508      	push	{r3, lr}

  port_unlock();
 8002672:	f7ff ffe5 	bl	8002640 <port_unlock.10325.4235>
}
 8002676:	bd08      	pop	{r3, pc}
 8002678:	f3af 8000 	nop.w
 800267c:	f3af 8000 	nop.w

08002680 <chSysLockFromISR.10489.4229>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002680:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002682:	f7ff ffed 	bl	8002660 <port_lock_from_isr.10327.4233>
  _stats_start_measure_crit_isr();
 8002686:	f000 fb4b 	bl	8002d20 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800268a:	f001 fdc1 	bl	8004210 <_dbg_check_lock_from_isr>
}
 800268e:	bd08      	pop	{r3, pc}

08002690 <chSysUnlockFromISR.10505.4227>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002690:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8002692:	f001 fddd 	bl	8004250 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8002696:	f000 fb4b 	bl	8002d30 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800269a:	f7ff ffe9 	bl	8002670 <port_unlock_from_isr.10329.4231>
}
 800269e:	bd08      	pop	{r3, pc}

080026a0 <chOQIsEmptyI.10493.4223>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 80026a0:	b500      	push	{lr}
 80026a2:	b083      	sub	sp, #12
 80026a4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80026a6:	f001 fe43 	bl	8004330 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80026aa:	9b01      	ldr	r3, [sp, #4]
 80026ac:	695a      	ldr	r2, [r3, #20]
 80026ae:	9b01      	ldr	r3, [sp, #4]
 80026b0:	699b      	ldr	r3, [r3, #24]
 80026b2:	429a      	cmp	r2, r3
 80026b4:	d106      	bne.n	80026c4 <chOQIsEmptyI.10493.4223+0x24>
 80026b6:	9b01      	ldr	r3, [sp, #4]
 80026b8:	689b      	ldr	r3, [r3, #8]
 80026ba:	2b00      	cmp	r3, #0
 80026bc:	d002      	beq.n	80026c4 <chOQIsEmptyI.10493.4223+0x24>
 80026be:	f04f 0301 	mov.w	r3, #1
 80026c2:	e001      	b.n	80026c8 <chOQIsEmptyI.10493.4223+0x28>
 80026c4:	f04f 0300 	mov.w	r3, #0
 80026c8:	f003 0301 	and.w	r3, r3, #1
 80026cc:	b2db      	uxtb	r3, r3
}
 80026ce:	4618      	mov	r0, r3
 80026d0:	b003      	add	sp, #12
 80026d2:	bd00      	pop	{pc}
 80026d4:	f3af 8000 	nop.w
 80026d8:	f3af 8000 	nop.w
 80026dc:	f3af 8000 	nop.w

080026e0 <osalSysLockFromISR.10491.4221>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80026e0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80026e2:	f7ff ffcd 	bl	8002680 <chSysLockFromISR.10489.4229>
}
 80026e6:	bd08      	pop	{r3, pc}
 80026e8:	f3af 8000 	nop.w
 80026ec:	f3af 8000 	nop.w

080026f0 <osalSysUnlockFromISR.10507.4219>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80026f0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 80026f2:	f7ff ffcd 	bl	8002690 <chSysUnlockFromISR.10505.4227>
}
 80026f6:	bd08      	pop	{r3, pc}
 80026f8:	f3af 8000 	nop.w
 80026fc:	f3af 8000 	nop.w

08002700 <osalEventBroadcastFlagsI.10497.4215>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8002700:	b500      	push	{lr}
 8002702:	b083      	sub	sp, #12
 8002704:	9001      	str	r0, [sp, #4]
 8002706:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8002708:	9801      	ldr	r0, [sp, #4]
 800270a:	9900      	ldr	r1, [sp, #0]
 800270c:	f000 fb40 	bl	8002d90 <chEvtBroadcastFlagsI>
}
 8002710:	b003      	add	sp, #12
 8002712:	bd00      	pop	{pc}
 8002714:	f3af 8000 	nop.w
 8002718:	f3af 8000 	nop.w
 800271c:	f3af 8000 	nop.w

08002720 <usart_init.10331.4211>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 8002720:	b084      	sub	sp, #16
 8002722:	9001      	str	r0, [sp, #4]
 8002724:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 8002726:	9b01      	ldr	r3, [sp, #4]
 8002728:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800272a:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 800272c:	9b01      	ldr	r3, [sp, #4]
 800272e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8002730:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8002734:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002738:	429a      	cmp	r2, r3
 800273a:	d007      	beq.n	800274c <usart_init.10331.4211+0x2c>
 800273c:	9b01      	ldr	r3, [sp, #4]
 800273e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8002740:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8002744:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002748:	429a      	cmp	r2, r3
 800274a:	d10a      	bne.n	8002762 <usart_init.10331.4211+0x42>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 800274c:	9b00      	ldr	r3, [sp, #0]
 800274e:	681a      	ldr	r2, [r3, #0]
 8002750:	f44f 53a4 	mov.w	r3, #5248	; 0x1480
 8002754:	f2c0 33ef 	movt	r3, #1007	; 0x3ef
 8002758:	fbb3 f2f2 	udiv	r2, r3, r2
 800275c:	9b03      	ldr	r3, [sp, #12]
 800275e:	609a      	str	r2, [r3, #8]
 8002760:	e009      	b.n	8002776 <usart_init.10331.4211+0x56>
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8002762:	9b00      	ldr	r3, [sp, #0]
 8002764:	681a      	ldr	r2, [r3, #0]
 8002766:	f648 2340 	movw	r3, #35392	; 0x8a40
 800276a:	f2c0 13f7 	movt	r3, #503	; 0x1f7
 800276e:	fbb3 f2f2 	udiv	r2, r3, r2
 8002772:	9b03      	ldr	r3, [sp, #12]
 8002774:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002776:	9b00      	ldr	r3, [sp, #0]
 8002778:	88db      	ldrh	r3, [r3, #6]
 800277a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800277e:	b29b      	uxth	r3, r3
 8002780:	461a      	mov	r2, r3
 8002782:	9b03      	ldr	r3, [sp, #12]
 8002784:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002786:	9b00      	ldr	r3, [sp, #0]
 8002788:	891b      	ldrh	r3, [r3, #8]
 800278a:	f043 0301 	orr.w	r3, r3, #1
 800278e:	b29b      	uxth	r3, r3
 8002790:	461a      	mov	r2, r3
 8002792:	9b03      	ldr	r3, [sp, #12]
 8002794:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002796:	9b00      	ldr	r3, [sp, #0]
 8002798:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 800279a:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
 800279e:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 80027a2:	b29b      	uxth	r3, r3
 80027a4:	461a      	mov	r2, r3
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80027a6:	9b03      	ldr	r3, [sp, #12]
 80027a8:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 80027aa:	9b03      	ldr	r3, [sp, #12]
 80027ac:	f04f 0200 	mov.w	r2, #0
 80027b0:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 80027b2:	9b03      	ldr	r3, [sp, #12]
 80027b4:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 80027b6:	9b03      	ldr	r3, [sp, #12]
 80027b8:	685b      	ldr	r3, [r3, #4]
}
 80027ba:	b004      	add	sp, #16
 80027bc:	4770      	bx	lr
 80027be:	bf00      	nop

080027c0 <set_error.10501.4207>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
 80027c0:	b500      	push	{lr}
 80027c2:	b085      	sub	sp, #20
 80027c4:	9001      	str	r0, [sp, #4]
 80027c6:	460b      	mov	r3, r1
 80027c8:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
 80027cc:	f04f 0300 	mov.w	r3, #0
 80027d0:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
 80027d2:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80027d6:	f003 0308 	and.w	r3, r3, #8
 80027da:	2b00      	cmp	r3, #0
 80027dc:	d003      	beq.n	80027e6 <set_error.10501.4207+0x26>
    sts |= SD_OVERRUN_ERROR;
 80027de:	9b03      	ldr	r3, [sp, #12]
 80027e0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80027e4:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
 80027e6:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80027ea:	f003 0301 	and.w	r3, r3, #1
 80027ee:	2b00      	cmp	r3, #0
 80027f0:	d003      	beq.n	80027fa <set_error.10501.4207+0x3a>
    sts |= SD_PARITY_ERROR;
 80027f2:	9b03      	ldr	r3, [sp, #12]
 80027f4:	f043 0320 	orr.w	r3, r3, #32
 80027f8:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
 80027fa:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80027fe:	f003 0302 	and.w	r3, r3, #2
 8002802:	2b00      	cmp	r3, #0
 8002804:	d003      	beq.n	800280e <set_error.10501.4207+0x4e>
    sts |= SD_FRAMING_ERROR;
 8002806:	9b03      	ldr	r3, [sp, #12]
 8002808:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800280c:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
 800280e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8002812:	f003 0304 	and.w	r3, r3, #4
 8002816:	2b00      	cmp	r3, #0
 8002818:	d003      	beq.n	8002822 <set_error.10501.4207+0x62>
    sts |= SD_NOISE_ERROR;
 800281a:	9b03      	ldr	r3, [sp, #12]
 800281c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002820:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
 8002822:	9b01      	ldr	r3, [sp, #4]
 8002824:	f103 0304 	add.w	r3, r3, #4
 8002828:	4618      	mov	r0, r3
 800282a:	9903      	ldr	r1, [sp, #12]
 800282c:	f7ff ff68 	bl	8002700 <osalEventBroadcastFlagsI.10497.4215>
}
 8002830:	b005      	add	sp, #20
 8002832:	bd00      	pop	{pc}
 8002834:	f3af 8000 	nop.w
 8002838:	f3af 8000 	nop.w
 800283c:	f3af 8000 	nop.w

08002840 <serve_interrupt.10509.4204>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8002840:	b500      	push	{lr}
 8002842:	b087      	sub	sp, #28
 8002844:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8002846:	9b01      	ldr	r3, [sp, #4]
 8002848:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800284a:	9304      	str	r3, [sp, #16]
  uint16_t cr1 = u->CR1;
 800284c:	9b04      	ldr	r3, [sp, #16]
 800284e:	68db      	ldr	r3, [r3, #12]
 8002850:	f8ad 300e 	strh.w	r3, [sp, #14]
  uint16_t sr = u->SR;
 8002854:	9b04      	ldr	r3, [sp, #16]
 8002856:	681b      	ldr	r3, [r3, #0]
 8002858:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 800285c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002860:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002864:	2b00      	cmp	r3, #0
 8002866:	d00f      	beq.n	8002888 <serve_interrupt.10509.4204+0x48>
    osalSysLockFromISR();
 8002868:	f7ff ff3a 	bl	80026e0 <osalSysLockFromISR.10491.4221>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 800286c:	9b01      	ldr	r3, [sp, #4]
 800286e:	f103 0304 	add.w	r3, r3, #4
 8002872:	4618      	mov	r0, r3
 8002874:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002878:	f7ff ff42 	bl	8002700 <osalEventBroadcastFlagsI.10497.4215>
    u->SR = ~USART_SR_LBD;
 800287c:	9b04      	ldr	r3, [sp, #16]
 800287e:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8002882:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8002884:	f7ff ff34 	bl	80026f0 <osalSysUnlockFromISR.10507.4219>
  }

  /* Data available.*/
  osalSysLockFromISR();
 8002888:	f7ff ff2a 	bl	80026e0 <osalSysLockFromISR.10491.4221>
 800288c:	e01f      	b.n	80028ce <serve_interrupt.10509.4204+0x8e>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 800288e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8002892:	f003 030f 	and.w	r3, r3, #15
 8002896:	2b00      	cmp	r3, #0
 8002898:	d005      	beq.n	80028a6 <serve_interrupt.10509.4204+0x66>
      set_error(sdp, sr);
 800289a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800289e:	9801      	ldr	r0, [sp, #4]
 80028a0:	4619      	mov	r1, r3
 80028a2:	f7ff ff8d 	bl	80027c0 <set_error.10501.4207>
    b = u->DR;
 80028a6:	9b04      	ldr	r3, [sp, #16]
 80028a8:	685b      	ldr	r3, [r3, #4]
 80028aa:	f88d 300d 	strb.w	r3, [sp, #13]
    if (sr & USART_SR_RXNE)
 80028ae:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80028b2:	f003 0320 	and.w	r3, r3, #32
 80028b6:	2b00      	cmp	r3, #0
 80028b8:	d005      	beq.n	80028c6 <serve_interrupt.10509.4204+0x86>
      sdIncomingDataI(sdp, b);
 80028ba:	f89d 300d 	ldrb.w	r3, [sp, #13]
 80028be:	9801      	ldr	r0, [sp, #4]
 80028c0:	4619      	mov	r1, r3
 80028c2:	f7fe fe45 	bl	8001550 <sdIncomingDataI.4429>
    sr = u->SR;
 80028c6:	9b04      	ldr	r3, [sp, #16]
 80028c8:	681b      	ldr	r3, [r3, #0]
 80028ca:	f8ad 3016 	strh.w	r3, [sp, #22]
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80028ce:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80028d2:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 80028d6:	2b00      	cmp	r3, #0
 80028d8:	d1d9      	bne.n	800288e <serve_interrupt.10509.4204+0x4e>
    b = u->DR;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
  }
  osalSysUnlockFromISR();
 80028da:	f7ff ff09 	bl	80026f0 <osalSysUnlockFromISR.10507.4219>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 80028de:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80028e2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80028e6:	2b00      	cmp	r3, #0
 80028e8:	d027      	beq.n	800293a <serve_interrupt.10509.4204+0xfa>
 80028ea:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80028ee:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80028f2:	2b00      	cmp	r3, #0
 80028f4:	d021      	beq.n	800293a <serve_interrupt.10509.4204+0xfa>
    msg_t b;
    osalSysLockFromISR();
 80028f6:	f7ff fef3 	bl	80026e0 <osalSysLockFromISR.10491.4221>
    b = oqGetI(&sdp->oqueue);
 80028fa:	9b01      	ldr	r3, [sp, #4]
 80028fc:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8002900:	4618      	mov	r0, r3
 8002902:	f000 fcfd 	bl	8003300 <chOQGetI>
 8002906:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
 8002908:	9b02      	ldr	r3, [sp, #8]
 800290a:	2b00      	cmp	r3, #0
 800290c:	da10      	bge.n	8002930 <serve_interrupt.10509.4204+0xf0>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 800290e:	9b01      	ldr	r3, [sp, #4]
 8002910:	f103 0304 	add.w	r3, r3, #4
 8002914:	4618      	mov	r0, r3
 8002916:	f04f 0108 	mov.w	r1, #8
 800291a:	f7ff fef1 	bl	8002700 <osalEventBroadcastFlagsI.10497.4215>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800291e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8002922:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8002926:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800292a:	9b04      	ldr	r3, [sp, #16]
 800292c:	60da      	str	r2, [r3, #12]
 800292e:	e002      	b.n	8002936 <serve_interrupt.10509.4204+0xf6>
    }
    else
      u->DR = b;
 8002930:	9a02      	ldr	r2, [sp, #8]
 8002932:	9b04      	ldr	r3, [sp, #16]
 8002934:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 8002936:	f7ff fedb 	bl	80026f0 <osalSysUnlockFromISR.10507.4219>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 800293a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800293e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002942:	2b00      	cmp	r3, #0
 8002944:	d01e      	beq.n	8002984 <serve_interrupt.10509.4204+0x144>
    osalSysLockFromISR();
 8002946:	f7ff fecb 	bl	80026e0 <osalSysLockFromISR.10491.4221>
    if (oqIsEmptyI(&sdp->oqueue))
 800294a:	9b01      	ldr	r3, [sp, #4]
 800294c:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8002950:	4618      	mov	r0, r3
 8002952:	f7ff fea5 	bl	80026a0 <chOQIsEmptyI.10493.4223>
 8002956:	4603      	mov	r3, r0
 8002958:	2b00      	cmp	r3, #0
 800295a:	d007      	beq.n	800296c <serve_interrupt.10509.4204+0x12c>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 800295c:	9b01      	ldr	r3, [sp, #4]
 800295e:	f103 0304 	add.w	r3, r3, #4
 8002962:	4618      	mov	r0, r3
 8002964:	f04f 0110 	mov.w	r1, #16
 8002968:	f7ff feca 	bl	8002700 <osalEventBroadcastFlagsI.10497.4215>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800296c:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8002970:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8002974:	9b04      	ldr	r3, [sp, #16]
 8002976:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
 8002978:	9b04      	ldr	r3, [sp, #16]
 800297a:	f06f 0240 	mvn.w	r2, #64	; 0x40
 800297e:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8002980:	f7ff feb6 	bl	80026f0 <osalSysUnlockFromISR.10507.4219>
  }
}
 8002984:	b007      	add	sp, #28
 8002986:	bd00      	pop	{pc}
 8002988:	f3af 8000 	nop.w
 800298c:	f3af 8000 	nop.w

08002990 <notify2.10483.4194>:
  USART1->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {
 8002990:	b082      	sub	sp, #8
 8002992:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8002994:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8002998:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800299c:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 80029a0:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80029a4:	68d2      	ldr	r2, [r2, #12]
 80029a6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80029aa:	60da      	str	r2, [r3, #12]
}
 80029ac:	b002      	add	sp, #8
 80029ae:	4770      	bx	lr

080029b0 <notify6.10486.4197>:
  UART5->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_USART6 || defined(__DOXYGEN__)
static void notify6(io_queue_t *qp) {
 80029b0:	b082      	sub	sp, #8
 80029b2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART6->CR1 |= USART_CR1_TXEIE;
 80029b4:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 80029b8:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80029bc:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
 80029c0:	f2c4 0201 	movt	r2, #16385	; 0x4001
 80029c4:	68d2      	ldr	r2, [r2, #12]
 80029c6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80029ca:	60da      	str	r2, [r3, #12]
}
 80029cc:	b002      	add	sp, #8
 80029ce:	4770      	bx	lr

080029d0 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 80029d0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80029d2:	f000 f965 	bl	8002ca0 <_stats_increase_irq>
 80029d6:	f001 fc5b 	bl	8004290 <_dbg_check_enter_isr>

  serve_interrupt(&SD2);
 80029da:	f643 50ac 	movw	r0, #15788	; 0x3dac
 80029de:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80029e2:	f7ff ff2d 	bl	8002840 <serve_interrupt.10509.4204>

  OSAL_IRQ_EPILOGUE();
 80029e6:	f001 fc7b 	bl	80042e0 <_dbg_check_leave_isr>
 80029ea:	f000 fe49 	bl	8003680 <_port_irq_epilogue>
}
 80029ee:	bd08      	pop	{r3, pc}

080029f0 <Vector15C>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART6_HANDLER) {
 80029f0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80029f2:	f000 f955 	bl	8002ca0 <_stats_increase_irq>
 80029f6:	f001 fc4b 	bl	8004290 <_dbg_check_enter_isr>

  serve_interrupt(&SD6);
 80029fa:	f643 6024 	movw	r0, #15908	; 0x3e24
 80029fe:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002a02:	f7ff ff1d 	bl	8002840 <serve_interrupt.10509.4204>

  OSAL_IRQ_EPILOGUE();
 8002a06:	f001 fc6b 	bl	80042e0 <_dbg_check_leave_isr>
 8002a0a:	f000 fe39 	bl	8003680 <_port_irq_epilogue>
}
 8002a0e:	bd08      	pop	{r3, pc}

08002a10 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8002a10:	b508      	push	{r3, lr}
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8002a12:	f643 50ac 	movw	r0, #15788	; 0x3dac
 8002a16:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002a1a:	f04f 0100 	mov.w	r1, #0
 8002a1e:	f642 1291 	movw	r2, #10641	; 0x2991
 8002a22:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002a26:	f001 f883 	bl	8003b30 <sdObjectInit>
  SD2.usart = USART2;
 8002a2a:	f643 53ac 	movw	r3, #15788	; 0x3dac
 8002a2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002a32:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8002a36:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8002a3a:	675a      	str	r2, [r3, #116]	; 0x74
  sdObjectInit(&SD5, NULL, notify5);
  SD5.usart = UART5;
#endif

#if STM32_SERIAL_USE_USART6
  sdObjectInit(&SD6, NULL, notify6);
 8002a3c:	f643 6024 	movw	r0, #15908	; 0x3e24
 8002a40:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002a44:	f04f 0100 	mov.w	r1, #0
 8002a48:	f642 12b1 	movw	r2, #10673	; 0x29b1
 8002a4c:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002a50:	f001 f86e 	bl	8003b30 <sdObjectInit>
  SD6.usart = USART6;
 8002a54:	f643 6324 	movw	r3, #15908	; 0x3e24
 8002a58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002a5c:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
 8002a60:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8002a64:	675a      	str	r2, [r3, #116]	; 0x74
#endif
}
 8002a66:	bd08      	pop	{r3, pc}
 8002a68:	f3af 8000 	nop.w
 8002a6c:	f3af 8000 	nop.w

08002a70 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8002a70:	b500      	push	{lr}
 8002a72:	b083      	sub	sp, #12
 8002a74:	9001      	str	r0, [sp, #4]
 8002a76:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 8002a78:	9b00      	ldr	r3, [sp, #0]
 8002a7a:	2b00      	cmp	r3, #0
 8002a7c:	d104      	bne.n	8002a88 <sd_lld_start+0x18>
    config = &default_config;
 8002a7e:	f645 0390 	movw	r3, #22672	; 0x5890
 8002a82:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002a86:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 8002a88:	9b01      	ldr	r3, [sp, #4]
 8002a8a:	7a1b      	ldrb	r3, [r3, #8]
 8002a8c:	2b01      	cmp	r3, #1
 8002a8e:	d131      	bne.n	8002af4 <sd_lld_start+0x84>
      rccEnableUSART1(FALSE);
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 8002a90:	9a01      	ldr	r2, [sp, #4]
 8002a92:	f643 53ac 	movw	r3, #15788	; 0x3dac
 8002a96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002a9a:	429a      	cmp	r2, r3
 8002a9c:	d111      	bne.n	8002ac2 <sd_lld_start+0x52>
      rccEnableUSART2(FALSE);
 8002a9e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002aa2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002aa6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002aaa:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002aae:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8002ab0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8002ab4:	641a      	str	r2, [r3, #64]	; 0x40
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 8002ab6:	f04f 0026 	mov.w	r0, #38	; 0x26
 8002aba:	f04f 010c 	mov.w	r1, #12
 8002abe:	f7fe fd7f 	bl	80015c0 <nvicEnableVector.4424>
      rccEnableUART5(FALSE);
      nvicEnableVector(STM32_UART5_NUMBER, STM32_SERIAL_UART5_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART6
    if (&SD6 == sdp) {
 8002ac2:	9a01      	ldr	r2, [sp, #4]
 8002ac4:	f643 6324 	movw	r3, #15908	; 0x3e24
 8002ac8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002acc:	429a      	cmp	r2, r3
 8002ace:	d111      	bne.n	8002af4 <sd_lld_start+0x84>
      rccEnableUSART6(FALSE);
 8002ad0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002ad4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002ad8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002adc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002ae0:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8002ae2:	f042 0220 	orr.w	r2, r2, #32
 8002ae6:	645a      	str	r2, [r3, #68]	; 0x44
      nvicEnableVector(STM32_USART6_NUMBER, STM32_SERIAL_USART6_PRIORITY);
 8002ae8:	f04f 0047 	mov.w	r0, #71	; 0x47
 8002aec:	f04f 010c 	mov.w	r1, #12
 8002af0:	f7fe fd66 	bl	80015c0 <nvicEnableVector.4424>
    }
#endif
  }
  usart_init(sdp, config);
 8002af4:	9801      	ldr	r0, [sp, #4]
 8002af6:	9900      	ldr	r1, [sp, #0]
 8002af8:	f7ff fe12 	bl	8002720 <usart_init.10331.4211>
}
 8002afc:	b003      	add	sp, #12
 8002afe:	bd00      	pop	{pc}

08002b00 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8002b00:	b508      	push	{r3, lr}

  stm32_clock_init();
 8002b02:	f7ff f9dd 	bl	8001ec0 <stm32_clock_init.4382>
}
 8002b06:	bd08      	pop	{r3, pc}
 8002b08:	f3af 8000 	nop.w
 8002b0c:	f3af 8000 	nop.w

08002b10 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8002b10:	4770      	bx	lr
 8002b12:	bf00      	nop
 8002b14:	f3af 8000 	nop.w
 8002b18:	f3af 8000 	nop.w
 8002b1c:	f3af 8000 	nop.w

08002b20 <long_to_string_with_divisor.10651>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8002b20:	b088      	sub	sp, #32
 8002b22:	9003      	str	r0, [sp, #12]
 8002b24:	9102      	str	r1, [sp, #8]
 8002b26:	9201      	str	r2, [sp, #4]
 8002b28:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 8002b2a:	9b02      	ldr	r3, [sp, #8]
 8002b2c:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 8002b2e:	9b00      	ldr	r3, [sp, #0]
 8002b30:	2b00      	cmp	r3, #0
 8002b32:	d102      	bne.n	8002b3a <long_to_string_with_divisor.10651+0x1a>
    ll = num;
 8002b34:	9b02      	ldr	r3, [sp, #8]
 8002b36:	9304      	str	r3, [sp, #16]
 8002b38:	e001      	b.n	8002b3e <long_to_string_with_divisor.10651+0x1e>
  } else {
    ll = divisor;
 8002b3a:	9b00      	ldr	r3, [sp, #0]
 8002b3c:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 8002b3e:	9b03      	ldr	r3, [sp, #12]
 8002b40:	f103 030b 	add.w	r3, r3, #11
 8002b44:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 8002b46:	9b05      	ldr	r3, [sp, #20]
 8002b48:	9a01      	ldr	r2, [sp, #4]
 8002b4a:	fbb3 f2f2 	udiv	r2, r3, r2
 8002b4e:	9901      	ldr	r1, [sp, #4]
 8002b50:	fb01 f202 	mul.w	r2, r1, r2
 8002b54:	1a9b      	subs	r3, r3, r2
 8002b56:	9307      	str	r3, [sp, #28]
    i += '0';
 8002b58:	9b07      	ldr	r3, [sp, #28]
 8002b5a:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8002b5e:	9307      	str	r3, [sp, #28]
    if (i > '9')
 8002b60:	9b07      	ldr	r3, [sp, #28]
 8002b62:	2b39      	cmp	r3, #57	; 0x39
 8002b64:	dd03      	ble.n	8002b6e <long_to_string_with_divisor.10651+0x4e>
      i += 'A' - '0' - 10;
 8002b66:	9b07      	ldr	r3, [sp, #28]
 8002b68:	f103 0307 	add.w	r3, r3, #7
 8002b6c:	9307      	str	r3, [sp, #28]
    *--q = i;
 8002b6e:	9b06      	ldr	r3, [sp, #24]
 8002b70:	f103 33ff 	add.w	r3, r3, #4294967295
 8002b74:	9306      	str	r3, [sp, #24]
 8002b76:	9b07      	ldr	r3, [sp, #28]
 8002b78:	b2da      	uxtb	r2, r3
 8002b7a:	9b06      	ldr	r3, [sp, #24]
 8002b7c:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8002b7e:	9a05      	ldr	r2, [sp, #20]
 8002b80:	9b01      	ldr	r3, [sp, #4]
 8002b82:	fbb2 f3f3 	udiv	r3, r2, r3
 8002b86:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8002b88:	9a04      	ldr	r2, [sp, #16]
 8002b8a:	9b01      	ldr	r3, [sp, #4]
 8002b8c:	fbb2 f3f3 	udiv	r3, r2, r3
 8002b90:	9304      	str	r3, [sp, #16]
 8002b92:	9b04      	ldr	r3, [sp, #16]
 8002b94:	2b00      	cmp	r3, #0
 8002b96:	d1d6      	bne.n	8002b46 <long_to_string_with_divisor.10651+0x26>

  i = (int)(p + MAX_FILLER - q);
 8002b98:	9b03      	ldr	r3, [sp, #12]
 8002b9a:	f103 030b 	add.w	r3, r3, #11
 8002b9e:	461a      	mov	r2, r3
 8002ba0:	9b06      	ldr	r3, [sp, #24]
 8002ba2:	1ad3      	subs	r3, r2, r3
 8002ba4:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 8002ba6:	9b06      	ldr	r3, [sp, #24]
 8002ba8:	781a      	ldrb	r2, [r3, #0]
 8002baa:	9b03      	ldr	r3, [sp, #12]
 8002bac:	701a      	strb	r2, [r3, #0]
 8002bae:	9b03      	ldr	r3, [sp, #12]
 8002bb0:	f103 0301 	add.w	r3, r3, #1
 8002bb4:	9303      	str	r3, [sp, #12]
 8002bb6:	9b06      	ldr	r3, [sp, #24]
 8002bb8:	f103 0301 	add.w	r3, r3, #1
 8002bbc:	9306      	str	r3, [sp, #24]
  while (--i);
 8002bbe:	9b07      	ldr	r3, [sp, #28]
 8002bc0:	f103 33ff 	add.w	r3, r3, #4294967295
 8002bc4:	9307      	str	r3, [sp, #28]
 8002bc6:	9b07      	ldr	r3, [sp, #28]
 8002bc8:	2b00      	cmp	r3, #0
 8002bca:	d1ec      	bne.n	8002ba6 <long_to_string_with_divisor.10651+0x86>

  return p;
 8002bcc:	9b03      	ldr	r3, [sp, #12]
}
 8002bce:	4618      	mov	r0, r3
 8002bd0:	b008      	add	sp, #32
 8002bd2:	4770      	bx	lr
 8002bd4:	f3af 8000 	nop.w
 8002bd8:	f3af 8000 	nop.w
 8002bdc:	f3af 8000 	nop.w

08002be0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8002be0:	b500      	push	{lr}
 8002be2:	b083      	sub	sp, #12
 8002be4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8002be6:	f002 fb0b 	bl	8005200 <port_rt_get_counter_value.5541>
 8002bea:	4602      	mov	r2, r0
 8002bec:	9b01      	ldr	r3, [sp, #4]
 8002bee:	609a      	str	r2, [r3, #8]
}
 8002bf0:	b003      	add	sp, #12
 8002bf2:	bd00      	pop	{pc}
 8002bf4:	f3af 8000 	nop.w
 8002bf8:	f3af 8000 	nop.w
 8002bfc:	f3af 8000 	nop.w

08002c00 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8002c00:	b500      	push	{lr}
 8002c02:	b083      	sub	sp, #12
 8002c04:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8002c06:	f002 fafb 	bl	8005200 <port_rt_get_counter_value.5541>
 8002c0a:	4602      	mov	r2, r0
 8002c0c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8002c10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c14:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 8002c18:	9801      	ldr	r0, [sp, #4]
 8002c1a:	4611      	mov	r1, r2
 8002c1c:	461a      	mov	r2, r3
 8002c1e:	f002 faf7 	bl	8005210 <tm_stop.5546>
}
 8002c22:	b003      	add	sp, #12
 8002c24:	bd00      	pop	{pc}
 8002c26:	bf00      	nop
 8002c28:	f3af 8000 	nop.w
 8002c2c:	f3af 8000 	nop.w

08002c30 <chTMChainMeasurementToX.4515>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 8002c30:	b500      	push	{lr}
 8002c32:	b083      	sub	sp, #12
 8002c34:	9001      	str	r0, [sp, #4]
 8002c36:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 8002c38:	f002 fae2 	bl	8005200 <port_rt_get_counter_value.5541>
 8002c3c:	4602      	mov	r2, r0
 8002c3e:	9b00      	ldr	r3, [sp, #0]
 8002c40:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
 8002c42:	9b00      	ldr	r3, [sp, #0]
 8002c44:	689b      	ldr	r3, [r3, #8]
 8002c46:	9801      	ldr	r0, [sp, #4]
 8002c48:	4619      	mov	r1, r3
 8002c4a:	f04f 0200 	mov.w	r2, #0
 8002c4e:	f002 fadf 	bl	8005210 <tm_stop.5546>
}
 8002c52:	b003      	add	sp, #12
 8002c54:	bd00      	pop	{pc}
 8002c56:	bf00      	nop
 8002c58:	f3af 8000 	nop.w
 8002c5c:	f3af 8000 	nop.w

08002c60 <_stats_init>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
 8002c60:	b508      	push	{r3, lr}

  ch.kernel_stats.n_irq = (ucnt_t)0;
 8002c62:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8002c66:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c6a:	f04f 0200 	mov.w	r2, #0
 8002c6e:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
 8002c72:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8002c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c7a:	f04f 0200 	mov.w	r2, #0
 8002c7e:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
 8002c82:	4803      	ldr	r0, [pc, #12]	; (8002c90 <_stats_init+0x30>)
 8002c84:	f002 fb24 	bl	80052d0 <chTMObjectInit>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
 8002c88:	4802      	ldr	r0, [pc, #8]	; (8002c94 <_stats_init+0x34>)
 8002c8a:	f002 fb21 	bl	80052d0 <chTMObjectInit>
}
 8002c8e:	bd08      	pop	{r3, pc}
 8002c90:	20003b60 	.word	0x20003b60
 8002c94:	20003b78 	.word	0x20003b78
 8002c98:	f3af 8000 	nop.w
 8002c9c:	f3af 8000 	nop.w

08002ca0 <_stats_increase_irq>:
/**
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {

  ch.kernel_stats.n_irq++;
 8002ca0:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8002ca4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002ca8:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
 8002cac:	f103 0201 	add.w	r2, r3, #1
 8002cb0:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8002cb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002cb8:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
}
 8002cbc:	4770      	bx	lr
 8002cbe:	bf00      	nop

08002cc0 <_stats_ctxswc>:
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
 8002cc0:	b500      	push	{lr}
 8002cc2:	b083      	sub	sp, #12
 8002cc4:	9001      	str	r0, [sp, #4]
 8002cc6:	9100      	str	r1, [sp, #0]

  ch.kernel_stats.n_ctxswc++;
 8002cc8:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8002ccc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002cd0:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8002cd4:	f103 0201 	add.w	r2, r3, #1
 8002cd8:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8002cdc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002ce0:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 8002ce4:	9b00      	ldr	r3, [sp, #0]
 8002ce6:	f103 0248 	add.w	r2, r3, #72	; 0x48
 8002cea:	9b01      	ldr	r3, [sp, #4]
 8002cec:	f103 0348 	add.w	r3, r3, #72	; 0x48
 8002cf0:	4610      	mov	r0, r2
 8002cf2:	4619      	mov	r1, r3
 8002cf4:	f7ff ff9c 	bl	8002c30 <chTMChainMeasurementToX.4515>
}
 8002cf8:	b003      	add	sp, #12
 8002cfa:	bd00      	pop	{pc}
 8002cfc:	f3af 8000 	nop.w

08002d00 <_stats_start_measure_crit_thd>:

/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {
 8002d00:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
 8002d02:	4802      	ldr	r0, [pc, #8]	; (8002d0c <_stats_start_measure_crit_thd+0xc>)
 8002d04:	f7ff ff6c 	bl	8002be0 <chTMStartMeasurementX>
}
 8002d08:	bd08      	pop	{r3, pc}
 8002d0a:	bf00      	nop
 8002d0c:	20003b60 	.word	0x20003b60

08002d10 <_stats_stop_measure_crit_thd>:

/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {
 8002d10:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
 8002d12:	4802      	ldr	r0, [pc, #8]	; (8002d1c <_stats_stop_measure_crit_thd+0xc>)
 8002d14:	f7ff ff74 	bl	8002c00 <chTMStopMeasurementX>
}
 8002d18:	bd08      	pop	{r3, pc}
 8002d1a:	bf00      	nop
 8002d1c:	20003b60 	.word	0x20003b60

08002d20 <_stats_start_measure_crit_isr>:

/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {
 8002d20:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
 8002d22:	4802      	ldr	r0, [pc, #8]	; (8002d2c <_stats_start_measure_crit_isr+0xc>)
 8002d24:	f7ff ff5c 	bl	8002be0 <chTMStartMeasurementX>
}
 8002d28:	bd08      	pop	{r3, pc}
 8002d2a:	bf00      	nop
 8002d2c:	20003b78 	.word	0x20003b78

08002d30 <_stats_stop_measure_crit_isr>:

/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {
 8002d30:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
 8002d32:	4802      	ldr	r0, [pc, #8]	; (8002d3c <_stats_stop_measure_crit_isr+0xc>)
 8002d34:	f7ff ff64 	bl	8002c00 <chTMStopMeasurementX>
}
 8002d38:	bd08      	pop	{r3, pc}
 8002d3a:	bf00      	nop
 8002d3c:	20003b78 	.word	0x20003b78

08002d40 <queue_init.6541.4495>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002d40:	b082      	sub	sp, #8
 8002d42:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8002d44:	9b01      	ldr	r3, [sp, #4]
 8002d46:	9a01      	ldr	r2, [sp, #4]
 8002d48:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002d4a:	9b01      	ldr	r3, [sp, #4]
 8002d4c:	9a01      	ldr	r2, [sp, #4]
 8002d4e:	605a      	str	r2, [r3, #4]
}
 8002d50:	b002      	add	sp, #8
 8002d52:	4770      	bx	lr
 8002d54:	f3af 8000 	nop.w
 8002d58:	f3af 8000 	nop.w
 8002d5c:	f3af 8000 	nop.w

08002d60 <chMtxObjectInit.4491>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8002d60:	b500      	push	{lr}
 8002d62:	b083      	sub	sp, #12
 8002d64:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8002d66:	9b01      	ldr	r3, [sp, #4]
 8002d68:	2b00      	cmp	r3, #0
 8002d6a:	d105      	bne.n	8002d78 <chMtxObjectInit.4491+0x18>
 8002d6c:	f245 6090 	movw	r0, #22160	; 0x5690
 8002d70:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002d74:	f001 f994 	bl	80040a0 <chSysHalt>

  queue_init(&mp->m_queue);
 8002d78:	9b01      	ldr	r3, [sp, #4]
 8002d7a:	4618      	mov	r0, r3
 8002d7c:	f7ff ffe0 	bl	8002d40 <queue_init.6541.4495>
  mp->m_owner = NULL;
 8002d80:	9b01      	ldr	r3, [sp, #4]
 8002d82:	f04f 0200 	mov.w	r2, #0
 8002d86:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 8002d88:	b003      	add	sp, #12
 8002d8a:	bd00      	pop	{pc}
 8002d8c:	f3af 8000 	nop.w

08002d90 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8002d90:	b500      	push	{lr}
 8002d92:	b085      	sub	sp, #20
 8002d94:	9001      	str	r0, [sp, #4]
 8002d96:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
 8002d98:	f001 faca 	bl	8004330 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 8002d9c:	9b01      	ldr	r3, [sp, #4]
 8002d9e:	2b00      	cmp	r3, #0
 8002da0:	d105      	bne.n	8002dae <chEvtBroadcastFlagsI+0x1e>
 8002da2:	f245 60b0 	movw	r0, #22192	; 0x56b0
 8002da6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002daa:	f001 f979 	bl	80040a0 <chSysHalt>

  elp = esp->es_next;
 8002dae:	9b01      	ldr	r3, [sp, #4]
 8002db0:	681b      	ldr	r3, [r3, #0]
 8002db2:	9303      	str	r3, [sp, #12]
 8002db4:	e01a      	b.n	8002dec <chEvtBroadcastFlagsI+0x5c>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
 8002db6:	9b03      	ldr	r3, [sp, #12]
 8002db8:	68da      	ldr	r2, [r3, #12]
 8002dba:	9b00      	ldr	r3, [sp, #0]
 8002dbc:	431a      	orrs	r2, r3
 8002dbe:	9b03      	ldr	r3, [sp, #12]
 8002dc0:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8002dc2:	9b00      	ldr	r3, [sp, #0]
 8002dc4:	2b00      	cmp	r3, #0
 8002dc6:	d006      	beq.n	8002dd6 <chEvtBroadcastFlagsI+0x46>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 8002dc8:	9b03      	ldr	r3, [sp, #12]
 8002dca:	68da      	ldr	r2, [r3, #12]
 8002dcc:	9b03      	ldr	r3, [sp, #12]
 8002dce:	691b      	ldr	r3, [r3, #16]
 8002dd0:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8002dd2:	2b00      	cmp	r3, #0
 8002dd4:	d007      	beq.n	8002de6 <chEvtBroadcastFlagsI+0x56>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8002dd6:	9b03      	ldr	r3, [sp, #12]
 8002dd8:	685a      	ldr	r2, [r3, #4]
 8002dda:	9b03      	ldr	r3, [sp, #12]
 8002ddc:	689b      	ldr	r3, [r3, #8]
 8002dde:	4610      	mov	r0, r2
 8002de0:	4619      	mov	r1, r3
 8002de2:	f000 f80d 	bl	8002e00 <chEvtSignalI.4483>
    }
    elp = elp->el_next;
 8002de6:	9b03      	ldr	r3, [sp, #12]
 8002de8:	681b      	ldr	r3, [r3, #0]
 8002dea:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8002dec:	9a03      	ldr	r2, [sp, #12]
 8002dee:	9b01      	ldr	r3, [sp, #4]
 8002df0:	429a      	cmp	r2, r3
 8002df2:	d1e0      	bne.n	8002db6 <chEvtBroadcastFlagsI+0x26>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 8002df4:	b005      	add	sp, #20
 8002df6:	bd00      	pop	{pc}
 8002df8:	f3af 8000 	nop.w
 8002dfc:	f3af 8000 	nop.w

08002e00 <chEvtSignalI.4483>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8002e00:	b500      	push	{lr}
 8002e02:	b083      	sub	sp, #12
 8002e04:	9001      	str	r0, [sp, #4]
 8002e06:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8002e08:	f001 fa92 	bl	8004330 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8002e0c:	9b01      	ldr	r3, [sp, #4]
 8002e0e:	2b00      	cmp	r3, #0
 8002e10:	d105      	bne.n	8002e1e <chEvtSignalI.4483+0x1e>
 8002e12:	f245 60a0 	movw	r0, #22176	; 0x56a0
 8002e16:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002e1a:	f001 f941 	bl	80040a0 <chSysHalt>

  tp->p_epending |= events;
 8002e1e:	9b01      	ldr	r3, [sp, #4]
 8002e20:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002e22:	9b00      	ldr	r3, [sp, #0]
 8002e24:	431a      	orrs	r2, r3
 8002e26:	9b01      	ldr	r3, [sp, #4]
 8002e28:	639a      	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002e2a:	9b01      	ldr	r3, [sp, #4]
 8002e2c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8002e30:	2b0a      	cmp	r3, #10
 8002e32:	d106      	bne.n	8002e42 <chEvtSignalI.4483+0x42>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8002e34:	9b01      	ldr	r3, [sp, #4]
 8002e36:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002e38:	9b01      	ldr	r3, [sp, #4]
 8002e3a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002e3c:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002e3e:	2b00      	cmp	r3, #0
 8002e40:	d10d      	bne.n	8002e5e <chEvtSignalI.4483+0x5e>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8002e42:	9b01      	ldr	r3, [sp, #4]
 8002e44:	f893 3020 	ldrb.w	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8002e48:	2b0b      	cmp	r3, #11
 8002e4a:	d10f      	bne.n	8002e6c <chEvtSignalI.4483+0x6c>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8002e4c:	9b01      	ldr	r3, [sp, #4]
 8002e4e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002e50:	9b01      	ldr	r3, [sp, #4]
 8002e52:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002e54:	401a      	ands	r2, r3
 8002e56:	9b01      	ldr	r3, [sp, #4]
 8002e58:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8002e5a:	429a      	cmp	r2, r3
 8002e5c:	d106      	bne.n	8002e6c <chEvtSignalI.4483+0x6c>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8002e5e:	9b01      	ldr	r3, [sp, #4]
 8002e60:	f04f 0200 	mov.w	r2, #0
 8002e64:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002e66:	9801      	ldr	r0, [sp, #4]
 8002e68:	f001 fd42 	bl	80048f0 <chSchReadyI>
  }
}
 8002e6c:	b003      	add	sp, #12
 8002e6e:	bd00      	pop	{pc}

08002e70 <port_lock.7677.4481>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002e70:	b082      	sub	sp, #8
 8002e72:	f04f 0320 	mov.w	r3, #32
 8002e76:	9301      	str	r3, [sp, #4]
 8002e78:	9b01      	ldr	r3, [sp, #4]
 8002e7a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002e7e:	b002      	add	sp, #8
 8002e80:	4770      	bx	lr
 8002e82:	bf00      	nop
 8002e84:	f3af 8000 	nop.w
 8002e88:	f3af 8000 	nop.w
 8002e8c:	f3af 8000 	nop.w

08002e90 <port_unlock.7680.4479>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002e90:	b082      	sub	sp, #8
 8002e92:	f04f 0300 	mov.w	r3, #0
 8002e96:	9301      	str	r3, [sp, #4]
 8002e98:	9b01      	ldr	r3, [sp, #4]
 8002e9a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002e9e:	b002      	add	sp, #8
 8002ea0:	4770      	bx	lr
 8002ea2:	bf00      	nop
 8002ea4:	f3af 8000 	nop.w
 8002ea8:	f3af 8000 	nop.w
 8002eac:	f3af 8000 	nop.w

08002eb0 <queue_init.7682.4476>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002eb0:	b082      	sub	sp, #8
 8002eb2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8002eb4:	9b01      	ldr	r3, [sp, #4]
 8002eb6:	9a01      	ldr	r2, [sp, #4]
 8002eb8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002eba:	9b01      	ldr	r3, [sp, #4]
 8002ebc:	9a01      	ldr	r2, [sp, #4]
 8002ebe:	605a      	str	r2, [r3, #4]
}
 8002ec0:	b002      	add	sp, #8
 8002ec2:	4770      	bx	lr
 8002ec4:	f3af 8000 	nop.w
 8002ec8:	f3af 8000 	nop.w
 8002ecc:	f3af 8000 	nop.w

08002ed0 <chSysLock.7799.4474>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8002ed0:	b508      	push	{r3, lr}

  port_lock();
 8002ed2:	f7ff ffcd 	bl	8002e70 <port_lock.7677.4481>
  _stats_start_measure_crit_thd();
 8002ed6:	f7ff ff13 	bl	8002d00 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8002eda:	f001 f959 	bl	8004190 <_dbg_check_lock>
}
 8002ede:	bd08      	pop	{r3, pc}

08002ee0 <chSysUnlock.7797.4472>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002ee0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8002ee2:	f001 f975 	bl	80041d0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8002ee6:	f7ff ff13 	bl	8002d10 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002eea:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8002eee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002ef2:	681a      	ldr	r2, [r3, #0]
 8002ef4:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8002ef8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002efc:	429a      	cmp	r2, r3
 8002efe:	d013      	beq.n	8002f28 <chSysUnlock.7797.4472+0x48>
 8002f00:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8002f04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f08:	699b      	ldr	r3, [r3, #24]
 8002f0a:	689a      	ldr	r2, [r3, #8]
 8002f0c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8002f10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f14:	681b      	ldr	r3, [r3, #0]
 8002f16:	689b      	ldr	r3, [r3, #8]
 8002f18:	429a      	cmp	r2, r3
 8002f1a:	d205      	bcs.n	8002f28 <chSysUnlock.7797.4472+0x48>
 8002f1c:	f245 60f0 	movw	r0, #22256	; 0x56f0
 8002f20:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002f24:	f001 f8bc 	bl	80040a0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
 8002f28:	f7ff ffb2 	bl	8002e90 <port_unlock.7680.4479>
}
 8002f2c:	bd08      	pop	{r3, pc}
 8002f2e:	bf00      	nop

08002f30 <chThdQueueObjectInit.7767.4469>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8002f30:	b500      	push	{lr}
 8002f32:	b083      	sub	sp, #12
 8002f34:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8002f36:	9801      	ldr	r0, [sp, #4]
 8002f38:	f7ff ffba 	bl	8002eb0 <queue_init.7682.4476>
}
 8002f3c:	b003      	add	sp, #12
 8002f3e:	bd00      	pop	{pc}

08002f40 <chIQIsEmptyI.7790.4466>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8002f40:	b500      	push	{lr}
 8002f42:	b083      	sub	sp, #12
 8002f44:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002f46:	f001 f9f3 	bl	8004330 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8002f4a:	9b01      	ldr	r3, [sp, #4]
 8002f4c:	689b      	ldr	r3, [r3, #8]
 8002f4e:	2b00      	cmp	r3, #0
 8002f50:	bf14      	ite	ne
 8002f52:	2300      	movne	r3, #0
 8002f54:	2301      	moveq	r3, #1
 8002f56:	b2db      	uxtb	r3, r3
}
 8002f58:	4618      	mov	r0, r3
 8002f5a:	b003      	add	sp, #12
 8002f5c:	bd00      	pop	{pc}
 8002f5e:	bf00      	nop

08002f60 <chIQIsFullI.7794.4463>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 8002f60:	b500      	push	{lr}
 8002f62:	b083      	sub	sp, #12
 8002f64:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002f66:	f001 f9e3 	bl	8004330 <chDbgCheckClassI>

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8002f6a:	9b01      	ldr	r3, [sp, #4]
 8002f6c:	695a      	ldr	r2, [r3, #20]
 8002f6e:	9b01      	ldr	r3, [sp, #4]
 8002f70:	699b      	ldr	r3, [r3, #24]
 8002f72:	429a      	cmp	r2, r3
 8002f74:	d106      	bne.n	8002f84 <chIQIsFullI.7794.4463+0x24>
 8002f76:	9b01      	ldr	r3, [sp, #4]
 8002f78:	689b      	ldr	r3, [r3, #8]
 8002f7a:	2b00      	cmp	r3, #0
 8002f7c:	d002      	beq.n	8002f84 <chIQIsFullI.7794.4463+0x24>
 8002f7e:	f04f 0301 	mov.w	r3, #1
 8002f82:	e001      	b.n	8002f88 <chIQIsFullI.7794.4463+0x28>
 8002f84:	f04f 0300 	mov.w	r3, #0
 8002f88:	f003 0301 	and.w	r3, r3, #1
 8002f8c:	b2db      	uxtb	r3, r3
}
 8002f8e:	4618      	mov	r0, r3
 8002f90:	b003      	add	sp, #12
 8002f92:	bd00      	pop	{pc}
 8002f94:	f3af 8000 	nop.w
 8002f98:	f3af 8000 	nop.w
 8002f9c:	f3af 8000 	nop.w

08002fa0 <chOQIsEmptyI.7787.4460>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8002fa0:	b500      	push	{lr}
 8002fa2:	b083      	sub	sp, #12
 8002fa4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002fa6:	f001 f9c3 	bl	8004330 <chDbgCheckClassI>

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8002faa:	9b01      	ldr	r3, [sp, #4]
 8002fac:	695a      	ldr	r2, [r3, #20]
 8002fae:	9b01      	ldr	r3, [sp, #4]
 8002fb0:	699b      	ldr	r3, [r3, #24]
 8002fb2:	429a      	cmp	r2, r3
 8002fb4:	d106      	bne.n	8002fc4 <chOQIsEmptyI.7787.4460+0x24>
 8002fb6:	9b01      	ldr	r3, [sp, #4]
 8002fb8:	689b      	ldr	r3, [r3, #8]
 8002fba:	2b00      	cmp	r3, #0
 8002fbc:	d002      	beq.n	8002fc4 <chOQIsEmptyI.7787.4460+0x24>
 8002fbe:	f04f 0301 	mov.w	r3, #1
 8002fc2:	e001      	b.n	8002fc8 <chOQIsEmptyI.7787.4460+0x28>
 8002fc4:	f04f 0300 	mov.w	r3, #0
 8002fc8:	f003 0301 	and.w	r3, r3, #1
 8002fcc:	b2db      	uxtb	r3, r3
}
 8002fce:	4618      	mov	r0, r3
 8002fd0:	b003      	add	sp, #12
 8002fd2:	bd00      	pop	{pc}
 8002fd4:	f3af 8000 	nop.w
 8002fd8:	f3af 8000 	nop.w
 8002fdc:	f3af 8000 	nop.w

08002fe0 <chOQIsFullI.7770.4457>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8002fe0:	b500      	push	{lr}
 8002fe2:	b083      	sub	sp, #12
 8002fe4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002fe6:	f001 f9a3 	bl	8004330 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8002fea:	9b01      	ldr	r3, [sp, #4]
 8002fec:	689b      	ldr	r3, [r3, #8]
 8002fee:	2b00      	cmp	r3, #0
 8002ff0:	bf14      	ite	ne
 8002ff2:	2300      	movne	r3, #0
 8002ff4:	2301      	moveq	r3, #1
 8002ff6:	b2db      	uxtb	r3, r3
}
 8002ff8:	4618      	mov	r0, r3
 8002ffa:	b003      	add	sp, #12
 8002ffc:	bd00      	pop	{pc}
 8002ffe:	bf00      	nop

08003000 <chIQObjectInit.4450>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8003000:	b500      	push	{lr}
 8003002:	b085      	sub	sp, #20
 8003004:	9003      	str	r0, [sp, #12]
 8003006:	9102      	str	r1, [sp, #8]
 8003008:	9201      	str	r2, [sp, #4]
 800300a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
 800300c:	9b03      	ldr	r3, [sp, #12]
 800300e:	4618      	mov	r0, r3
 8003010:	f7ff ff8e 	bl	8002f30 <chThdQueueObjectInit.7767.4469>
  iqp->q_counter = 0;
 8003014:	9b03      	ldr	r3, [sp, #12]
 8003016:	f04f 0200 	mov.w	r2, #0
 800301a:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 800301c:	9b03      	ldr	r3, [sp, #12]
 800301e:	9a02      	ldr	r2, [sp, #8]
 8003020:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8003022:	9b03      	ldr	r3, [sp, #12]
 8003024:	9a02      	ldr	r2, [sp, #8]
 8003026:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8003028:	9b03      	ldr	r3, [sp, #12]
 800302a:	9a02      	ldr	r2, [sp, #8]
 800302c:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800302e:	9a02      	ldr	r2, [sp, #8]
 8003030:	9b01      	ldr	r3, [sp, #4]
 8003032:	18d2      	adds	r2, r2, r3
 8003034:	9b03      	ldr	r3, [sp, #12]
 8003036:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8003038:	9b03      	ldr	r3, [sp, #12]
 800303a:	9a00      	ldr	r2, [sp, #0]
 800303c:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800303e:	9b03      	ldr	r3, [sp, #12]
 8003040:	9a06      	ldr	r2, [sp, #24]
 8003042:	621a      	str	r2, [r3, #32]
}
 8003044:	b005      	add	sp, #20
 8003046:	bd00      	pop	{pc}
 8003048:	f3af 8000 	nop.w
 800304c:	f3af 8000 	nop.w

08003050 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8003050:	b500      	push	{lr}
 8003052:	b083      	sub	sp, #12
 8003054:	9001      	str	r0, [sp, #4]
 8003056:	460b      	mov	r3, r1
 8003058:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();
 800305c:	f001 f968 	bl	8004330 <chDbgCheckClassI>

  if (chIQIsFullI(iqp)) {
 8003060:	9801      	ldr	r0, [sp, #4]
 8003062:	f7ff ff7d 	bl	8002f60 <chIQIsFullI.7794.4463>
 8003066:	4603      	mov	r3, r0
 8003068:	2b00      	cmp	r3, #0
 800306a:	d002      	beq.n	8003072 <chIQPutI+0x22>
    return Q_FULL;
 800306c:	f06f 0303 	mvn.w	r3, #3
 8003070:	e020      	b.n	80030b4 <chIQPutI+0x64>
  }

  iqp->q_counter++;
 8003072:	9b01      	ldr	r3, [sp, #4]
 8003074:	689b      	ldr	r3, [r3, #8]
 8003076:	f103 0201 	add.w	r2, r3, #1
 800307a:	9b01      	ldr	r3, [sp, #4]
 800307c:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 800307e:	9b01      	ldr	r3, [sp, #4]
 8003080:	695b      	ldr	r3, [r3, #20]
 8003082:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8003086:	701a      	strb	r2, [r3, #0]
 8003088:	f103 0201 	add.w	r2, r3, #1
 800308c:	9b01      	ldr	r3, [sp, #4]
 800308e:	615a      	str	r2, [r3, #20]
  if (iqp->q_wrptr >= iqp->q_top) {
 8003090:	9b01      	ldr	r3, [sp, #4]
 8003092:	695a      	ldr	r2, [r3, #20]
 8003094:	9b01      	ldr	r3, [sp, #4]
 8003096:	691b      	ldr	r3, [r3, #16]
 8003098:	429a      	cmp	r2, r3
 800309a:	d303      	bcc.n	80030a4 <chIQPutI+0x54>
    iqp->q_wrptr = iqp->q_buffer;
 800309c:	9b01      	ldr	r3, [sp, #4]
 800309e:	68da      	ldr	r2, [r3, #12]
 80030a0:	9b01      	ldr	r3, [sp, #4]
 80030a2:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 80030a4:	9b01      	ldr	r3, [sp, #4]
 80030a6:	4618      	mov	r0, r3
 80030a8:	f04f 0100 	mov.w	r1, #0
 80030ac:	f002 f898 	bl	80051e0 <chThdDequeueNextI>

  return Q_OK;
 80030b0:	f04f 0300 	mov.w	r3, #0
}
 80030b4:	4618      	mov	r0, r3
 80030b6:	b003      	add	sp, #12
 80030b8:	bd00      	pop	{pc}
 80030ba:	bf00      	nop
 80030bc:	f3af 8000 	nop.w

080030c0 <chIQGetTimeout.4442>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 80030c0:	b500      	push	{lr}
 80030c2:	b085      	sub	sp, #20
 80030c4:	9001      	str	r0, [sp, #4]
 80030c6:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
 80030c8:	f7ff ff02 	bl	8002ed0 <chSysLock.7799.4474>
  if (iqp->q_notify != NULL) {
 80030cc:	9b01      	ldr	r3, [sp, #4]
 80030ce:	69db      	ldr	r3, [r3, #28]
 80030d0:	2b00      	cmp	r3, #0
 80030d2:	d011      	beq.n	80030f8 <chIQGetTimeout.4442+0x38>
    iqp->q_notify(iqp);
 80030d4:	9b01      	ldr	r3, [sp, #4]
 80030d6:	69db      	ldr	r3, [r3, #28]
 80030d8:	9801      	ldr	r0, [sp, #4]
 80030da:	4798      	blx	r3
 80030dc:	e00c      	b.n	80030f8 <chIQGetTimeout.4442+0x38>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80030de:	9b01      	ldr	r3, [sp, #4]
 80030e0:	4618      	mov	r0, r3
 80030e2:	9900      	ldr	r1, [sp, #0]
 80030e4:	f002 f85c 	bl	80051a0 <chThdEnqueueTimeoutS>
 80030e8:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
 80030ea:	9b03      	ldr	r3, [sp, #12]
 80030ec:	2b00      	cmp	r3, #0
 80030ee:	da03      	bge.n	80030f8 <chIQGetTimeout.4442+0x38>
      chSysUnlock();
 80030f0:	f7ff fef6 	bl	8002ee0 <chSysUnlock.7797.4472>
      return msg;
 80030f4:	9b03      	ldr	r3, [sp, #12]
 80030f6:	e022      	b.n	800313e <chIQGetTimeout.4442+0x7e>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 80030f8:	9801      	ldr	r0, [sp, #4]
 80030fa:	f7ff ff21 	bl	8002f40 <chIQIsEmptyI.7790.4466>
 80030fe:	4603      	mov	r3, r0
 8003100:	2b00      	cmp	r3, #0
 8003102:	d1ec      	bne.n	80030de <chIQGetTimeout.4442+0x1e>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8003104:	9b01      	ldr	r3, [sp, #4]
 8003106:	689b      	ldr	r3, [r3, #8]
 8003108:	f103 32ff 	add.w	r2, r3, #4294967295
 800310c:	9b01      	ldr	r3, [sp, #4]
 800310e:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 8003110:	9b01      	ldr	r3, [sp, #4]
 8003112:	699b      	ldr	r3, [r3, #24]
 8003114:	781a      	ldrb	r2, [r3, #0]
 8003116:	f88d 200b 	strb.w	r2, [sp, #11]
 800311a:	f103 0201 	add.w	r2, r3, #1
 800311e:	9b01      	ldr	r3, [sp, #4]
 8003120:	619a      	str	r2, [r3, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8003122:	9b01      	ldr	r3, [sp, #4]
 8003124:	699a      	ldr	r2, [r3, #24]
 8003126:	9b01      	ldr	r3, [sp, #4]
 8003128:	691b      	ldr	r3, [r3, #16]
 800312a:	429a      	cmp	r2, r3
 800312c:	d303      	bcc.n	8003136 <chIQGetTimeout.4442+0x76>
    iqp->q_rdptr = iqp->q_buffer;
 800312e:	9b01      	ldr	r3, [sp, #4]
 8003130:	68da      	ldr	r2, [r3, #12]
 8003132:	9b01      	ldr	r3, [sp, #4]
 8003134:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
 8003136:	f7ff fed3 	bl	8002ee0 <chSysUnlock.7797.4472>

  return (msg_t)b;
 800313a:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800313e:	4618      	mov	r0, r3
 8003140:	b005      	add	sp, #20
 8003142:	bd00      	pop	{pc}
 8003144:	f3af 8000 	nop.w
 8003148:	f3af 8000 	nop.w
 800314c:	f3af 8000 	nop.w

08003150 <chIQReadTimeout.4436>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8003150:	b500      	push	{lr}
 8003152:	b087      	sub	sp, #28
 8003154:	9003      	str	r0, [sp, #12]
 8003156:	9102      	str	r1, [sp, #8]
 8003158:	9201      	str	r2, [sp, #4]
 800315a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 800315c:	9b03      	ldr	r3, [sp, #12]
 800315e:	69db      	ldr	r3, [r3, #28]
 8003160:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 8003162:	f04f 0300 	mov.w	r3, #0
 8003166:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
 8003168:	9b01      	ldr	r3, [sp, #4]
 800316a:	2b00      	cmp	r3, #0
 800316c:	d105      	bne.n	800317a <chIQReadTimeout.4436+0x2a>
 800316e:	f245 7000 	movw	r0, #22272	; 0x5700
 8003172:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003176:	f000 ff93 	bl	80040a0 <chSysHalt>

  chSysLock();
 800317a:	f7ff fea9 	bl	8002ed0 <chSysLock.7799.4474>
  while (true) {
    if (nfy != NULL) {
 800317e:	9b04      	ldr	r3, [sp, #16]
 8003180:	2b00      	cmp	r3, #0
 8003182:	d00f      	beq.n	80031a4 <chIQReadTimeout.4436+0x54>
      nfy(iqp);
 8003184:	9b04      	ldr	r3, [sp, #16]
 8003186:	9803      	ldr	r0, [sp, #12]
 8003188:	4798      	blx	r3
 800318a:	e00b      	b.n	80031a4 <chIQReadTimeout.4436+0x54>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800318c:	9b03      	ldr	r3, [sp, #12]
 800318e:	4618      	mov	r0, r3
 8003190:	9900      	ldr	r1, [sp, #0]
 8003192:	f002 f805 	bl	80051a0 <chThdEnqueueTimeoutS>
 8003196:	4603      	mov	r3, r0
 8003198:	2b00      	cmp	r3, #0
 800319a:	d003      	beq.n	80031a4 <chIQReadTimeout.4436+0x54>
        chSysUnlock();
 800319c:	f7ff fea0 	bl	8002ee0 <chSysUnlock.7797.4472>
        return r;
 80031a0:	9b05      	ldr	r3, [sp, #20]
 80031a2:	e034      	b.n	800320e <chIQReadTimeout.4436+0xbe>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 80031a4:	9803      	ldr	r0, [sp, #12]
 80031a6:	f7ff fecb 	bl	8002f40 <chIQIsEmptyI.7790.4466>
 80031aa:	4603      	mov	r3, r0
 80031ac:	2b00      	cmp	r3, #0
 80031ae:	d1ed      	bne.n	800318c <chIQReadTimeout.4436+0x3c>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80031b0:	9b03      	ldr	r3, [sp, #12]
 80031b2:	689b      	ldr	r3, [r3, #8]
 80031b4:	f103 32ff 	add.w	r2, r3, #4294967295
 80031b8:	9b03      	ldr	r3, [sp, #12]
 80031ba:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 80031bc:	9b03      	ldr	r3, [sp, #12]
 80031be:	699b      	ldr	r3, [r3, #24]
 80031c0:	7819      	ldrb	r1, [r3, #0]
 80031c2:	9a02      	ldr	r2, [sp, #8]
 80031c4:	7011      	strb	r1, [r2, #0]
 80031c6:	9a02      	ldr	r2, [sp, #8]
 80031c8:	f102 0201 	add.w	r2, r2, #1
 80031cc:	9202      	str	r2, [sp, #8]
 80031ce:	f103 0201 	add.w	r2, r3, #1
 80031d2:	9b03      	ldr	r3, [sp, #12]
 80031d4:	619a      	str	r2, [r3, #24]
    if (iqp->q_rdptr >= iqp->q_top) {
 80031d6:	9b03      	ldr	r3, [sp, #12]
 80031d8:	699a      	ldr	r2, [r3, #24]
 80031da:	9b03      	ldr	r3, [sp, #12]
 80031dc:	691b      	ldr	r3, [r3, #16]
 80031de:	429a      	cmp	r2, r3
 80031e0:	d303      	bcc.n	80031ea <chIQReadTimeout.4436+0x9a>
      iqp->q_rdptr = iqp->q_buffer;
 80031e2:	9b03      	ldr	r3, [sp, #12]
 80031e4:	68da      	ldr	r2, [r3, #12]
 80031e6:	9b03      	ldr	r3, [sp, #12]
 80031e8:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80031ea:	f7ff fe79 	bl	8002ee0 <chSysUnlock.7797.4472>

    r++;
 80031ee:	9b05      	ldr	r3, [sp, #20]
 80031f0:	f103 0301 	add.w	r3, r3, #1
 80031f4:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 80031f6:	9b01      	ldr	r3, [sp, #4]
 80031f8:	f103 33ff 	add.w	r3, r3, #4294967295
 80031fc:	9301      	str	r3, [sp, #4]
 80031fe:	9b01      	ldr	r3, [sp, #4]
 8003200:	2b00      	cmp	r3, #0
 8003202:	d101      	bne.n	8003208 <chIQReadTimeout.4436+0xb8>
      return r;
 8003204:	9b05      	ldr	r3, [sp, #20]
 8003206:	e002      	b.n	800320e <chIQReadTimeout.4436+0xbe>
    }

    chSysLock();
 8003208:	f7ff fe62 	bl	8002ed0 <chSysLock.7799.4474>
 800320c:	e7b7      	b.n	800317e <chIQReadTimeout.4436+0x2e>
  }
}
 800320e:	4618      	mov	r0, r3
 8003210:	b007      	add	sp, #28
 8003212:	bd00      	pop	{pc}
 8003214:	f3af 8000 	nop.w
 8003218:	f3af 8000 	nop.w
 800321c:	f3af 8000 	nop.w

08003220 <chOQObjectInit.4429>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8003220:	b500      	push	{lr}
 8003222:	b085      	sub	sp, #20
 8003224:	9003      	str	r0, [sp, #12]
 8003226:	9102      	str	r1, [sp, #8]
 8003228:	9201      	str	r2, [sp, #4]
 800322a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
 800322c:	9b03      	ldr	r3, [sp, #12]
 800322e:	4618      	mov	r0, r3
 8003230:	f7ff fe7e 	bl	8002f30 <chThdQueueObjectInit.7767.4469>
  oqp->q_counter = size;
 8003234:	9b03      	ldr	r3, [sp, #12]
 8003236:	9a01      	ldr	r2, [sp, #4]
 8003238:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800323a:	9b03      	ldr	r3, [sp, #12]
 800323c:	9a02      	ldr	r2, [sp, #8]
 800323e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8003240:	9b03      	ldr	r3, [sp, #12]
 8003242:	9a02      	ldr	r2, [sp, #8]
 8003244:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8003246:	9b03      	ldr	r3, [sp, #12]
 8003248:	9a02      	ldr	r2, [sp, #8]
 800324a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800324c:	9a02      	ldr	r2, [sp, #8]
 800324e:	9b01      	ldr	r3, [sp, #4]
 8003250:	18d2      	adds	r2, r2, r3
 8003252:	9b03      	ldr	r3, [sp, #12]
 8003254:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8003256:	9b03      	ldr	r3, [sp, #12]
 8003258:	9a00      	ldr	r2, [sp, #0]
 800325a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800325c:	9b03      	ldr	r3, [sp, #12]
 800325e:	9a06      	ldr	r2, [sp, #24]
 8003260:	621a      	str	r2, [r3, #32]
}
 8003262:	b005      	add	sp, #20
 8003264:	bd00      	pop	{pc}
 8003266:	bf00      	nop
 8003268:	f3af 8000 	nop.w
 800326c:	f3af 8000 	nop.w

08003270 <chOQPutTimeout.4424>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8003270:	b500      	push	{lr}
 8003272:	b087      	sub	sp, #28
 8003274:	9003      	str	r0, [sp, #12]
 8003276:	460b      	mov	r3, r1
 8003278:	9201      	str	r2, [sp, #4]
 800327a:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
 800327e:	f7ff fe27 	bl	8002ed0 <chSysLock.7799.4474>
 8003282:	e00c      	b.n	800329e <chOQPutTimeout.4424+0x2e>
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8003284:	9b03      	ldr	r3, [sp, #12]
 8003286:	4618      	mov	r0, r3
 8003288:	9901      	ldr	r1, [sp, #4]
 800328a:	f001 ff89 	bl	80051a0 <chThdEnqueueTimeoutS>
 800328e:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
 8003290:	9b05      	ldr	r3, [sp, #20]
 8003292:	2b00      	cmp	r3, #0
 8003294:	da03      	bge.n	800329e <chOQPutTimeout.4424+0x2e>
      chSysUnlock();
 8003296:	f7ff fe23 	bl	8002ee0 <chSysUnlock.7797.4472>
      return msg;
 800329a:	9b05      	ldr	r3, [sp, #20]
 800329c:	e02a      	b.n	80032f4 <chOQPutTimeout.4424+0x84>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800329e:	9803      	ldr	r0, [sp, #12]
 80032a0:	f7ff fe9e 	bl	8002fe0 <chOQIsFullI.7770.4457>
 80032a4:	4603      	mov	r3, r0
 80032a6:	2b00      	cmp	r3, #0
 80032a8:	d1ec      	bne.n	8003284 <chOQPutTimeout.4424+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80032aa:	9b03      	ldr	r3, [sp, #12]
 80032ac:	689b      	ldr	r3, [r3, #8]
 80032ae:	f103 32ff 	add.w	r2, r3, #4294967295
 80032b2:	9b03      	ldr	r3, [sp, #12]
 80032b4:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 80032b6:	9b03      	ldr	r3, [sp, #12]
 80032b8:	695b      	ldr	r3, [r3, #20]
 80032ba:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80032be:	701a      	strb	r2, [r3, #0]
 80032c0:	f103 0201 	add.w	r2, r3, #1
 80032c4:	9b03      	ldr	r3, [sp, #12]
 80032c6:	615a      	str	r2, [r3, #20]
  if (oqp->q_wrptr >= oqp->q_top) {
 80032c8:	9b03      	ldr	r3, [sp, #12]
 80032ca:	695a      	ldr	r2, [r3, #20]
 80032cc:	9b03      	ldr	r3, [sp, #12]
 80032ce:	691b      	ldr	r3, [r3, #16]
 80032d0:	429a      	cmp	r2, r3
 80032d2:	d303      	bcc.n	80032dc <chOQPutTimeout.4424+0x6c>
    oqp->q_wrptr = oqp->q_buffer;
 80032d4:	9b03      	ldr	r3, [sp, #12]
 80032d6:	68da      	ldr	r2, [r3, #12]
 80032d8:	9b03      	ldr	r3, [sp, #12]
 80032da:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 80032dc:	9b03      	ldr	r3, [sp, #12]
 80032de:	69db      	ldr	r3, [r3, #28]
 80032e0:	2b00      	cmp	r3, #0
 80032e2:	d003      	beq.n	80032ec <chOQPutTimeout.4424+0x7c>
    oqp->q_notify(oqp);
 80032e4:	9b03      	ldr	r3, [sp, #12]
 80032e6:	69db      	ldr	r3, [r3, #28]
 80032e8:	9803      	ldr	r0, [sp, #12]
 80032ea:	4798      	blx	r3
  }
  chSysUnlock();
 80032ec:	f7ff fdf8 	bl	8002ee0 <chSysUnlock.7797.4472>

  return Q_OK;
 80032f0:	f04f 0300 	mov.w	r3, #0
}
 80032f4:	4618      	mov	r0, r3
 80032f6:	b007      	add	sp, #28
 80032f8:	bd00      	pop	{pc}
 80032fa:	bf00      	nop
 80032fc:	f3af 8000 	nop.w

08003300 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8003300:	b500      	push	{lr}
 8003302:	b085      	sub	sp, #20
 8003304:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();
 8003306:	f001 f813 	bl	8004330 <chDbgCheckClassI>

  if (chOQIsEmptyI(oqp)) {
 800330a:	9801      	ldr	r0, [sp, #4]
 800330c:	f7ff fe48 	bl	8002fa0 <chOQIsEmptyI.7787.4460>
 8003310:	4603      	mov	r3, r0
 8003312:	2b00      	cmp	r3, #0
 8003314:	d002      	beq.n	800331c <chOQGetI+0x1c>
    return Q_EMPTY;
 8003316:	f06f 0302 	mvn.w	r3, #2
 800331a:	e020      	b.n	800335e <chOQGetI+0x5e>
  }

  oqp->q_counter++;
 800331c:	9b01      	ldr	r3, [sp, #4]
 800331e:	689b      	ldr	r3, [r3, #8]
 8003320:	f103 0201 	add.w	r2, r3, #1
 8003324:	9b01      	ldr	r3, [sp, #4]
 8003326:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8003328:	9b01      	ldr	r3, [sp, #4]
 800332a:	699b      	ldr	r3, [r3, #24]
 800332c:	781a      	ldrb	r2, [r3, #0]
 800332e:	f88d 200f 	strb.w	r2, [sp, #15]
 8003332:	f103 0201 	add.w	r2, r3, #1
 8003336:	9b01      	ldr	r3, [sp, #4]
 8003338:	619a      	str	r2, [r3, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 800333a:	9b01      	ldr	r3, [sp, #4]
 800333c:	699a      	ldr	r2, [r3, #24]
 800333e:	9b01      	ldr	r3, [sp, #4]
 8003340:	691b      	ldr	r3, [r3, #16]
 8003342:	429a      	cmp	r2, r3
 8003344:	d303      	bcc.n	800334e <chOQGetI+0x4e>
    oqp->q_rdptr = oqp->q_buffer;
 8003346:	9b01      	ldr	r3, [sp, #4]
 8003348:	68da      	ldr	r2, [r3, #12]
 800334a:	9b01      	ldr	r3, [sp, #4]
 800334c:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 800334e:	9b01      	ldr	r3, [sp, #4]
 8003350:	4618      	mov	r0, r3
 8003352:	f04f 0100 	mov.w	r1, #0
 8003356:	f001 ff43 	bl	80051e0 <chThdDequeueNextI>

  return (msg_t)b;
 800335a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800335e:	4618      	mov	r0, r3
 8003360:	b005      	add	sp, #20
 8003362:	bd00      	pop	{pc}
 8003364:	f3af 8000 	nop.w
 8003368:	f3af 8000 	nop.w
 800336c:	f3af 8000 	nop.w

08003370 <chOQWriteTimeout.4415>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8003370:	b500      	push	{lr}
 8003372:	b087      	sub	sp, #28
 8003374:	9003      	str	r0, [sp, #12]
 8003376:	9102      	str	r1, [sp, #8]
 8003378:	9201      	str	r2, [sp, #4]
 800337a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 800337c:	9b03      	ldr	r3, [sp, #12]
 800337e:	69db      	ldr	r3, [r3, #28]
 8003380:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 8003382:	f04f 0300 	mov.w	r3, #0
 8003386:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
 8003388:	9b01      	ldr	r3, [sp, #4]
 800338a:	2b00      	cmp	r3, #0
 800338c:	d105      	bne.n	800339a <chOQWriteTimeout.4415+0x2a>
 800338e:	f245 60d0 	movw	r0, #22224	; 0x56d0
 8003392:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003396:	f000 fe83 	bl	80040a0 <chSysHalt>

  chSysLock();
 800339a:	f7ff fd99 	bl	8002ed0 <chSysLock.7799.4474>
 800339e:	e00b      	b.n	80033b8 <chOQWriteTimeout.4415+0x48>
  while (true) {
    while (chOQIsFullI(oqp)) {
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 80033a0:	9b03      	ldr	r3, [sp, #12]
 80033a2:	4618      	mov	r0, r3
 80033a4:	9900      	ldr	r1, [sp, #0]
 80033a6:	f001 fefb 	bl	80051a0 <chThdEnqueueTimeoutS>
 80033aa:	4603      	mov	r3, r0
 80033ac:	2b00      	cmp	r3, #0
 80033ae:	d003      	beq.n	80033b8 <chOQWriteTimeout.4415+0x48>
        chSysUnlock();
 80033b0:	f7ff fd96 	bl	8002ee0 <chSysUnlock.7797.4472>
        return w;
 80033b4:	9b05      	ldr	r3, [sp, #20]
 80033b6:	e03a      	b.n	800342e <chOQWriteTimeout.4415+0xbe>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80033b8:	9803      	ldr	r0, [sp, #12]
 80033ba:	f7ff fe11 	bl	8002fe0 <chOQIsFullI.7770.4457>
 80033be:	4603      	mov	r3, r0
 80033c0:	2b00      	cmp	r3, #0
 80033c2:	d1ed      	bne.n	80033a0 <chOQWriteTimeout.4415+0x30>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 80033c4:	9b03      	ldr	r3, [sp, #12]
 80033c6:	689b      	ldr	r3, [r3, #8]
 80033c8:	f103 32ff 	add.w	r2, r3, #4294967295
 80033cc:	9b03      	ldr	r3, [sp, #12]
 80033ce:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 80033d0:	9b03      	ldr	r3, [sp, #12]
 80033d2:	695b      	ldr	r3, [r3, #20]
 80033d4:	9a02      	ldr	r2, [sp, #8]
 80033d6:	7812      	ldrb	r2, [r2, #0]
 80033d8:	701a      	strb	r2, [r3, #0]
 80033da:	f103 0201 	add.w	r2, r3, #1
 80033de:	9b03      	ldr	r3, [sp, #12]
 80033e0:	615a      	str	r2, [r3, #20]
 80033e2:	9b02      	ldr	r3, [sp, #8]
 80033e4:	f103 0301 	add.w	r3, r3, #1
 80033e8:	9302      	str	r3, [sp, #8]
    if (oqp->q_wrptr >= oqp->q_top) {
 80033ea:	9b03      	ldr	r3, [sp, #12]
 80033ec:	695a      	ldr	r2, [r3, #20]
 80033ee:	9b03      	ldr	r3, [sp, #12]
 80033f0:	691b      	ldr	r3, [r3, #16]
 80033f2:	429a      	cmp	r2, r3
 80033f4:	d303      	bcc.n	80033fe <chOQWriteTimeout.4415+0x8e>
      oqp->q_wrptr = oqp->q_buffer;
 80033f6:	9b03      	ldr	r3, [sp, #12]
 80033f8:	68da      	ldr	r2, [r3, #12]
 80033fa:	9b03      	ldr	r3, [sp, #12]
 80033fc:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 80033fe:	9b04      	ldr	r3, [sp, #16]
 8003400:	2b00      	cmp	r3, #0
 8003402:	d002      	beq.n	800340a <chOQWriteTimeout.4415+0x9a>
      nfy(oqp);
 8003404:	9b04      	ldr	r3, [sp, #16]
 8003406:	9803      	ldr	r0, [sp, #12]
 8003408:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 800340a:	f7ff fd69 	bl	8002ee0 <chSysUnlock.7797.4472>

    w++;
 800340e:	9b05      	ldr	r3, [sp, #20]
 8003410:	f103 0301 	add.w	r3, r3, #1
 8003414:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8003416:	9b01      	ldr	r3, [sp, #4]
 8003418:	f103 33ff 	add.w	r3, r3, #4294967295
 800341c:	9301      	str	r3, [sp, #4]
 800341e:	9b01      	ldr	r3, [sp, #4]
 8003420:	2b00      	cmp	r3, #0
 8003422:	d101      	bne.n	8003428 <chOQWriteTimeout.4415+0xb8>
      return w;
 8003424:	9b05      	ldr	r3, [sp, #20]
 8003426:	e002      	b.n	800342e <chOQWriteTimeout.4415+0xbe>
    }
    chSysLock();
 8003428:	f7ff fd52 	bl	8002ed0 <chSysLock.7799.4474>
 800342c:	e7c4      	b.n	80033b8 <chOQWriteTimeout.4415+0x48>
  }
}
 800342e:	4618      	mov	r0, r3
 8003430:	b007      	add	sp, #28
 8003432:	bd00      	pop	{pc}
 8003434:	f3af 8000 	nop.w
 8003438:	f3af 8000 	nop.w
 800343c:	f3af 8000 	nop.w

08003440 <port_lock.7930.4413>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003440:	b082      	sub	sp, #8
 8003442:	f04f 0320 	mov.w	r3, #32
 8003446:	9301      	str	r3, [sp, #4]
 8003448:	9b01      	ldr	r3, [sp, #4]
 800344a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800344e:	b002      	add	sp, #8
 8003450:	4770      	bx	lr
 8003452:	bf00      	nop
 8003454:	f3af 8000 	nop.w
 8003458:	f3af 8000 	nop.w
 800345c:	f3af 8000 	nop.w

08003460 <port_unlock.7933.4411>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003460:	b082      	sub	sp, #8
 8003462:	f04f 0300 	mov.w	r3, #0
 8003466:	9301      	str	r3, [sp, #4]
 8003468:	9b01      	ldr	r3, [sp, #4]
 800346a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800346e:	b002      	add	sp, #8
 8003470:	4770      	bx	lr
 8003472:	bf00      	nop
 8003474:	f3af 8000 	nop.w
 8003478:	f3af 8000 	nop.w
 800347c:	f3af 8000 	nop.w

08003480 <chSysLock.7935.4409>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8003480:	b508      	push	{r3, lr}

  port_lock();
 8003482:	f7ff ffdd 	bl	8003440 <port_lock.7930.4413>
  _stats_start_measure_crit_thd();
 8003486:	f7ff fc3b 	bl	8002d00 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800348a:	f000 fe81 	bl	8004190 <_dbg_check_lock>
}
 800348e:	bd08      	pop	{r3, pc}

08003490 <chSysUnlock.7937.4407>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003490:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8003492:	f000 fe9d 	bl	80041d0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8003496:	f7ff fc3b 	bl	8002d10 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800349a:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800349e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80034a2:	681a      	ldr	r2, [r3, #0]
 80034a4:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80034a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80034ac:	429a      	cmp	r2, r3
 80034ae:	d013      	beq.n	80034d8 <chSysUnlock.7937.4407+0x48>
 80034b0:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80034b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80034b8:	699b      	ldr	r3, [r3, #24]
 80034ba:	689a      	ldr	r2, [r3, #8]
 80034bc:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80034c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80034c4:	681b      	ldr	r3, [r3, #0]
 80034c6:	689b      	ldr	r3, [r3, #8]
 80034c8:	429a      	cmp	r2, r3
 80034ca:	d205      	bcs.n	80034d8 <chSysUnlock.7937.4407+0x48>
 80034cc:	f245 7010 	movw	r0, #22288	; 0x5710
 80034d0:	f6c0 0000 	movt	r0, #2048	; 0x800
 80034d4:	f000 fde4 	bl	80040a0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
 80034d8:	f7ff ffc2 	bl	8003460 <port_unlock.7933.4411>
}
 80034dc:	bd08      	pop	{r3, pc}
 80034de:	bf00      	nop

080034e0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80034e0:	f644 33ec 	movw	r3, #19436	; 0x4bec
 80034e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80034e8:	f103 0307 	add.w	r3, r3, #7
 80034ec:	f023 0307 	bic.w	r3, r3, #7
 80034f0:	461a      	mov	r2, r3
 80034f2:	f643 4388 	movw	r3, #15496	; 0x3c88
 80034f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80034fa:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80034fc:	f240 0300 	movw	r3, #0
 8003500:	f2c2 0302 	movt	r3, #8194	; 0x2002
 8003504:	f023 0307 	bic.w	r3, r3, #7
 8003508:	461a      	mov	r2, r3
 800350a:	f643 438c 	movw	r3, #15500	; 0x3c8c
 800350e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003512:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 8003514:	4770      	bx	lr
 8003516:	bf00      	nop
 8003518:	f3af 8000 	nop.w
 800351c:	f3af 8000 	nop.w

08003520 <chCoreAlloc.4398>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8003520:	b500      	push	{lr}
 8003522:	b085      	sub	sp, #20
 8003524:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8003526:	f7ff ffab 	bl	8003480 <chSysLock.7935.4409>
  p = chCoreAllocI(size);
 800352a:	9801      	ldr	r0, [sp, #4]
 800352c:	f000 f808 	bl	8003540 <chCoreAllocI.4402>
 8003530:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8003532:	f7ff ffad 	bl	8003490 <chSysUnlock.7937.4407>

  return p;
 8003536:	9b03      	ldr	r3, [sp, #12]
}
 8003538:	4618      	mov	r0, r3
 800353a:	b005      	add	sp, #20
 800353c:	bd00      	pop	{pc}
 800353e:	bf00      	nop

08003540 <chCoreAllocI.4402>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8003540:	b500      	push	{lr}
 8003542:	b085      	sub	sp, #20
 8003544:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();
 8003546:	f000 fef3 	bl	8004330 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
 800354a:	9b01      	ldr	r3, [sp, #4]
 800354c:	f103 0307 	add.w	r3, r3, #7
 8003550:	f023 0307 	bic.w	r3, r3, #7
 8003554:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8003556:	f643 438c 	movw	r3, #15500	; 0x3c8c
 800355a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800355e:	681b      	ldr	r3, [r3, #0]
 8003560:	461a      	mov	r2, r3
 8003562:	f643 4388 	movw	r3, #15496	; 0x3c88
 8003566:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800356a:	681b      	ldr	r3, [r3, #0]
 800356c:	1ad3      	subs	r3, r2, r3
 800356e:	461a      	mov	r2, r3
 8003570:	9b01      	ldr	r3, [sp, #4]
 8003572:	429a      	cmp	r2, r3
 8003574:	d202      	bcs.n	800357c <chCoreAllocI.4402+0x3c>
  /*lint -restore*/
    return NULL;
 8003576:	f04f 0300 	mov.w	r3, #0
 800357a:	e012      	b.n	80035a2 <chCoreAllocI.4402+0x62>
  }
  p = nextmem;
 800357c:	f643 4388 	movw	r3, #15496	; 0x3c88
 8003580:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003584:	681b      	ldr	r3, [r3, #0]
 8003586:	9303      	str	r3, [sp, #12]
  nextmem += size;
 8003588:	f643 4388 	movw	r3, #15496	; 0x3c88
 800358c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003590:	681a      	ldr	r2, [r3, #0]
 8003592:	9b01      	ldr	r3, [sp, #4]
 8003594:	18d2      	adds	r2, r2, r3
 8003596:	f643 4388 	movw	r3, #15496	; 0x3c88
 800359a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800359e:	601a      	str	r2, [r3, #0]

  return p;
 80035a0:	9b03      	ldr	r3, [sp, #12]
}
 80035a2:	4618      	mov	r0, r3
 80035a4:	b005      	add	sp, #20
 80035a6:	bd00      	pop	{pc}
 80035a8:	f3af 8000 	nop.w
 80035ac:	f3af 8000 	nop.w

080035b0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 80035b0:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 80035b2:	f643 4390 	movw	r3, #15504	; 0x3c90
 80035b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035ba:	f243 5221 	movw	r2, #13601	; 0x3521
 80035be:	f6c0 0200 	movt	r2, #2048	; 0x800
 80035c2:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 80035c4:	f643 4390 	movw	r3, #15504	; 0x3c90
 80035c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035cc:	f04f 0200 	mov.w	r2, #0
 80035d0:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 80035d2:	f643 4390 	movw	r3, #15504	; 0x3c90
 80035d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035da:	f04f 0200 	mov.w	r2, #0
 80035de:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 80035e0:	4801      	ldr	r0, [pc, #4]	; (80035e8 <_heap_init+0x38>)
 80035e2:	f7ff fbbd 	bl	8002d60 <chMtxObjectInit.4491>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 80035e6:	bd08      	pop	{r3, pc}
 80035e8:	20003ca0 	.word	0x20003ca0
 80035ec:	f3af 8000 	nop.w

080035f0 <port_lock.8433.4393>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80035f0:	b082      	sub	sp, #8
 80035f2:	f04f 0320 	mov.w	r3, #32
 80035f6:	9301      	str	r3, [sp, #4]
 80035f8:	9b01      	ldr	r3, [sp, #4]
 80035fa:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80035fe:	b002      	add	sp, #8
 8003600:	4770      	bx	lr
 8003602:	bf00      	nop
 8003604:	f3af 8000 	nop.w
 8003608:	f3af 8000 	nop.w
 800360c:	f3af 8000 	nop.w

08003610 <port_unlock.8436.4391>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003610:	b082      	sub	sp, #8
 8003612:	f04f 0300 	mov.w	r3, #0
 8003616:	9301      	str	r3, [sp, #4]
 8003618:	9b01      	ldr	r3, [sp, #4]
 800361a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800361e:	b002      	add	sp, #8
 8003620:	4770      	bx	lr
 8003622:	bf00      	nop
 8003624:	f3af 8000 	nop.w
 8003628:	f3af 8000 	nop.w
 800362c:	f3af 8000 	nop.w

08003630 <port_lock_from_isr.8438.4389>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8003630:	b508      	push	{r3, lr}

  port_lock();
 8003632:	f7ff ffdd 	bl	80035f0 <port_lock.8433.4393>
}
 8003636:	bd08      	pop	{r3, pc}
 8003638:	f3af 8000 	nop.w
 800363c:	f3af 8000 	nop.w

08003640 <port_unlock_from_isr.8440.4387>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8003640:	b508      	push	{r3, lr}

  port_unlock();
 8003642:	f7ff ffe5 	bl	8003610 <port_unlock.8436.4391>
}
 8003646:	bd08      	pop	{r3, pc}
 8003648:	f3af 8000 	nop.w
 800364c:	f3af 8000 	nop.w

08003650 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8003650:	b510      	push	{r4, lr}
 8003652:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003654:	f3ef 8409 	mrs	r4, PSP
  return(result);
 8003658:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 800365a:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800365c:	9b01      	ldr	r3, [sp, #4]
 800365e:	f103 0320 	add.w	r3, r3, #32
 8003662:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8003664:	9b01      	ldr	r3, [sp, #4]
 8003666:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003668:	9b00      	ldr	r3, [sp, #0]
 800366a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 800366e:	f7ff ffe7 	bl	8003640 <port_unlock_from_isr.8440.4387>
}
 8003672:	b002      	add	sp, #8
 8003674:	bd10      	pop	{r4, pc}
 8003676:	bf00      	nop
 8003678:	f3af 8000 	nop.w
 800367c:	f3af 8000 	nop.w

08003680 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8003680:	b510      	push	{r4, lr}
 8003682:	b082      	sub	sp, #8

  port_lock_from_isr();
 8003684:	f7ff ffd4 	bl	8003630 <port_lock_from_isr.8438.4389>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8003688:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800368c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003690:	685b      	ldr	r3, [r3, #4]
 8003692:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003696:	2b00      	cmp	r3, #0
 8003698:	d023      	beq.n	80036e2 <_port_irq_epilogue+0x62>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800369a:	f3ef 8409 	mrs	r4, PSP
  return(result);
 800369e:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 80036a0:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80036a2:	9b01      	ldr	r3, [sp, #4]
 80036a4:	f1a3 0320 	sub.w	r3, r3, #32
 80036a8:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80036aa:	9b01      	ldr	r3, [sp, #4]
 80036ac:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80036b0:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 80036b2:	9b01      	ldr	r3, [sp, #4]
 80036b4:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80036b6:	9b00      	ldr	r3, [sp, #0]
 80036b8:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80036bc:	f001 fa80 	bl	8004bc0 <chSchIsPreemptionRequired>
 80036c0:	4603      	mov	r3, r0
 80036c2:	2b00      	cmp	r3, #0
 80036c4:	d006      	beq.n	80036d4 <_port_irq_epilogue+0x54>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80036c6:	9a01      	ldr	r2, [sp, #4]
 80036c8:	f240 23b9 	movw	r3, #697	; 0x2b9
 80036cc:	f6c0 0300 	movt	r3, #2048	; 0x800
 80036d0:	6193      	str	r3, [r2, #24]
 80036d2:	e008      	b.n	80036e6 <_port_irq_epilogue+0x66>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80036d4:	9a01      	ldr	r2, [sp, #4]
 80036d6:	f240 23cc 	movw	r3, #716	; 0x2cc
 80036da:	f6c0 0300 	movt	r3, #2048	; 0x800
 80036de:	6193      	str	r3, [r2, #24]
 80036e0:	e001      	b.n	80036e6 <_port_irq_epilogue+0x66>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 80036e2:	f7ff ffad 	bl	8003640 <port_unlock_from_isr.8440.4387>
}
 80036e6:	b002      	add	sp, #8
 80036e8:	bd10      	pop	{r4, pc}
 80036ea:	bf00      	nop
 80036ec:	f3af 8000 	nop.w

080036f0 <osalInit.8489.4378>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 80036f0:	4770      	bx	lr
 80036f2:	bf00      	nop
 80036f4:	f3af 8000 	nop.w
 80036f8:	f3af 8000 	nop.w
 80036fc:	f3af 8000 	nop.w

08003700 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8003700:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8003702:	f7ff fff5 	bl	80036f0 <osalInit.8489.4378>

  /* Platform low level initializations.*/
  hal_lld_init();
 8003706:	f7fe fb7b 	bl	8001e00 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 800370a:	f645 00a0 	movw	r0, #22688	; 0x58a0
 800370e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003712:	f7fe fde5 	bl	80022e0 <_pal_lld_init>
#endif
#if (HAL_USE_CAN == TRUE) || defined(__DOXYGEN__)
  canInit();
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
 8003716:	f000 f88b 	bl	8003830 <dacInit.4349>
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
 800371a:	f000 f8a9 	bl	8003870 <gptInit.4274>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 800371e:	f000 f9ff 	bl	8003b20 <sdInit.4166>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8003722:	f7ff f9f5 	bl	8002b10 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8003726:	f000 f83b 	bl	80037a0 <stInit.4363>
#endif
}
 800372a:	bd08      	pop	{r3, pc}
 800372c:	f3af 8000 	nop.w

08003730 <st_lld_start_alarm.8523.4372>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8003730:	b082      	sub	sp, #8
 8003732:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003734:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003738:	9a01      	ldr	r2, [sp, #4]
 800373a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800373c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003740:	f04f 0200 	mov.w	r2, #0
 8003744:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003746:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800374a:	f04f 0202 	mov.w	r2, #2
 800374e:	60da      	str	r2, [r3, #12]
}
 8003750:	b002      	add	sp, #8
 8003752:	4770      	bx	lr
 8003754:	f3af 8000 	nop.w
 8003758:	f3af 8000 	nop.w
 800375c:	f3af 8000 	nop.w

08003760 <st_lld_stop_alarm.8529.4370>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003760:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003764:	f04f 0200 	mov.w	r2, #0
 8003768:	60da      	str	r2, [r3, #12]
}
 800376a:	4770      	bx	lr
 800376c:	f3af 8000 	nop.w

08003770 <st_lld_set_alarm.8531.4367>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8003770:	b082      	sub	sp, #8
 8003772:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003774:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003778:	9a01      	ldr	r2, [sp, #4]
 800377a:	635a      	str	r2, [r3, #52]	; 0x34
}
 800377c:	b002      	add	sp, #8
 800377e:	4770      	bx	lr

08003780 <st_lld_is_alarm_active.8536.4365>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8003780:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003784:	68db      	ldr	r3, [r3, #12]
 8003786:	f003 0302 	and.w	r3, r3, #2
 800378a:	2b00      	cmp	r3, #0
 800378c:	bf0c      	ite	eq
 800378e:	2300      	moveq	r3, #0
 8003790:	2301      	movne	r3, #1
 8003792:	b2db      	uxtb	r3, r3
}
 8003794:	4618      	mov	r0, r3
 8003796:	4770      	bx	lr
 8003798:	f3af 8000 	nop.w
 800379c:	f3af 8000 	nop.w

080037a0 <stInit.4363>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 80037a0:	b508      	push	{r3, lr}

  st_lld_init();
 80037a2:	f7fe fd0d 	bl	80021c0 <st_lld_init>
}
 80037a6:	bd08      	pop	{r3, pc}
 80037a8:	f3af 8000 	nop.w
 80037ac:	f3af 8000 	nop.w

080037b0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 80037b0:	b500      	push	{lr}
 80037b2:	b083      	sub	sp, #12
 80037b4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80037b6:	f7ff ffe3 	bl	8003780 <st_lld_is_alarm_active.8536.4365>
 80037ba:	4603      	mov	r3, r0
 80037bc:	2b00      	cmp	r3, #0
 80037be:	d005      	beq.n	80037cc <stStartAlarm+0x1c>
 80037c0:	f245 7030 	movw	r0, #22320	; 0x5730
 80037c4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80037c8:	f000 fc6a 	bl	80040a0 <chSysHalt>

  st_lld_start_alarm(abstime);
 80037cc:	9801      	ldr	r0, [sp, #4]
 80037ce:	f7ff ffaf 	bl	8003730 <st_lld_start_alarm.8523.4372>
}
 80037d2:	b003      	add	sp, #12
 80037d4:	bd00      	pop	{pc}
 80037d6:	bf00      	nop
 80037d8:	f3af 8000 	nop.w
 80037dc:	f3af 8000 	nop.w

080037e0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 80037e0:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 80037e2:	f7ff ffbd 	bl	8003760 <st_lld_stop_alarm.8529.4370>
}
 80037e6:	bd08      	pop	{r3, pc}
 80037e8:	f3af 8000 	nop.w
 80037ec:	f3af 8000 	nop.w

080037f0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 80037f0:	b500      	push	{lr}
 80037f2:	b083      	sub	sp, #12
 80037f4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80037f6:	f7ff ffc3 	bl	8003780 <st_lld_is_alarm_active.8536.4365>
 80037fa:	4603      	mov	r3, r0
 80037fc:	f083 0301 	eor.w	r3, r3, #1
 8003800:	b2db      	uxtb	r3, r3
 8003802:	2b00      	cmp	r3, #0
 8003804:	d005      	beq.n	8003812 <stSetAlarm+0x22>
 8003806:	f245 7020 	movw	r0, #22304	; 0x5720
 800380a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800380e:	f000 fc47 	bl	80040a0 <chSysHalt>

  st_lld_set_alarm(abstime);
 8003812:	9801      	ldr	r0, [sp, #4]
 8003814:	f7ff ffac 	bl	8003770 <st_lld_set_alarm.8531.4367>
}
 8003818:	b003      	add	sp, #12
 800381a:	bd00      	pop	{pc}
 800381c:	f3af 8000 	nop.w

08003820 <osalMutexObjectInit.8694.4351>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 8003820:	b500      	push	{lr}
 8003822:	b083      	sub	sp, #12
 8003824:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8003826:	9801      	ldr	r0, [sp, #4]
 8003828:	f7ff fa9a 	bl	8002d60 <chMtxObjectInit.4491>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 800382c:	b003      	add	sp, #12
 800382e:	bd00      	pop	{pc}

08003830 <dacInit.4349>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void dacInit(void) {
 8003830:	b508      	push	{r3, lr}

  dac_lld_init();
 8003832:	f7fe fd0d 	bl	8002250 <dac_lld_init>
}
 8003836:	bd08      	pop	{r3, pc}
 8003838:	f3af 8000 	nop.w
 800383c:	f3af 8000 	nop.w

08003840 <dacObjectInit>:
 *
 * @param[out] dacp     pointer to the @p DACDriver object
 *
 * @init
 */
void dacObjectInit(DACDriver *dacp) {
 8003840:	b500      	push	{lr}
 8003842:	b083      	sub	sp, #12
 8003844:	9001      	str	r0, [sp, #4]

  dacp->state = DAC_STOP;
 8003846:	9b01      	ldr	r3, [sp, #4]
 8003848:	f04f 0201 	mov.w	r2, #1
 800384c:	701a      	strb	r2, [r3, #0]
  dacp->config = NULL;
 800384e:	9b01      	ldr	r3, [sp, #4]
 8003850:	f04f 0200 	mov.w	r2, #0
 8003854:	611a      	str	r2, [r3, #16]
#if DAC_USE_WAIT
  dacp->thread = NULL;
 8003856:	9b01      	ldr	r3, [sp, #4]
 8003858:	f04f 0200 	mov.w	r2, #0
 800385c:	615a      	str	r2, [r3, #20]
#endif
#if DAC_USE_MUTUAL_EXCLUSION
  osalMutexObjectInit(&dacp->mutex);
 800385e:	9b01      	ldr	r3, [sp, #4]
 8003860:	f103 0318 	add.w	r3, r3, #24
 8003864:	4618      	mov	r0, r3
 8003866:	f7ff ffdb 	bl	8003820 <osalMutexObjectInit.8694.4351>
#endif
#if defined(DAC_DRIVER_EXT_INIT_HOOK)
  DAC_DRIVER_EXT_INIT_HOOK(dacp);
#endif
}
 800386a:	b003      	add	sp, #12
 800386c:	bd00      	pop	{pc}
 800386e:	bf00      	nop

08003870 <gptInit.4274>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void gptInit(void) {
 8003870:	b508      	push	{r3, lr}

  gpt_lld_init();
 8003872:	f7fe fe9d 	bl	80025b0 <gpt_lld_init>
}
 8003876:	bd08      	pop	{r3, pc}
 8003878:	f3af 8000 	nop.w
 800387c:	f3af 8000 	nop.w

08003880 <gptObjectInit>:
 *
 * @param[out] gptp     pointer to the @p GPTDriver object
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {
 8003880:	b082      	sub	sp, #8
 8003882:	9001      	str	r0, [sp, #4]

  gptp->state  = GPT_STOP;
 8003884:	9b01      	ldr	r3, [sp, #4]
 8003886:	f04f 0201 	mov.w	r2, #1
 800388a:	701a      	strb	r2, [r3, #0]
  gptp->config = NULL;
 800388c:	9b01      	ldr	r3, [sp, #4]
 800388e:	f04f 0200 	mov.w	r2, #0
 8003892:	605a      	str	r2, [r3, #4]
}
 8003894:	b002      	add	sp, #8
 8003896:	4770      	bx	lr
 8003898:	f3af 8000 	nop.w
 800389c:	f3af 8000 	nop.w

080038a0 <port_lock.9208.4230>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80038a0:	b082      	sub	sp, #8
 80038a2:	f04f 0320 	mov.w	r3, #32
 80038a6:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80038a8:	9b01      	ldr	r3, [sp, #4]
 80038aa:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80038ae:	b002      	add	sp, #8
 80038b0:	4770      	bx	lr
 80038b2:	bf00      	nop
 80038b4:	f3af 8000 	nop.w
 80038b8:	f3af 8000 	nop.w
 80038bc:	f3af 8000 	nop.w

080038c0 <port_unlock.9211.4228>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80038c0:	b082      	sub	sp, #8
 80038c2:	f04f 0300 	mov.w	r3, #0
 80038c6:	9301      	str	r3, [sp, #4]
 80038c8:	9b01      	ldr	r3, [sp, #4]
 80038ca:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80038ce:	b002      	add	sp, #8
 80038d0:	4770      	bx	lr
 80038d2:	bf00      	nop
 80038d4:	f3af 8000 	nop.w
 80038d8:	f3af 8000 	nop.w
 80038dc:	f3af 8000 	nop.w

080038e0 <chSysLock.9372.4226>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 80038e0:	b508      	push	{r3, lr}

  port_lock();
 80038e2:	f7ff ffdd 	bl	80038a0 <port_lock.9208.4230>
  _stats_start_measure_crit_thd();
 80038e6:	f7ff fa0b 	bl	8002d00 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80038ea:	f000 fc51 	bl	8004190 <_dbg_check_lock>
}
 80038ee:	bd08      	pop	{r3, pc}

080038f0 <chSysUnlock.9378.4224>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80038f0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80038f2:	f000 fc6d 	bl	80041d0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80038f6:	f7ff fa0b 	bl	8002d10 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80038fa:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80038fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003902:	681a      	ldr	r2, [r3, #0]
 8003904:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003908:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800390c:	429a      	cmp	r2, r3
 800390e:	d013      	beq.n	8003938 <chSysUnlock.9378.4224+0x48>
 8003910:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003914:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003918:	699b      	ldr	r3, [r3, #24]
 800391a:	689a      	ldr	r2, [r3, #8]
 800391c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003920:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003924:	681b      	ldr	r3, [r3, #0]
 8003926:	689b      	ldr	r3, [r3, #8]
 8003928:	429a      	cmp	r2, r3
 800392a:	d205      	bcs.n	8003938 <chSysUnlock.9378.4224+0x48>
 800392c:	f245 7070 	movw	r0, #22384	; 0x5770
 8003930:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003934:	f000 fbb4 	bl	80040a0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
 8003938:	f7ff ffc2 	bl	80038c0 <port_unlock.9211.4228>
}
 800393c:	bd08      	pop	{r3, pc}
 800393e:	bf00      	nop

08003940 <chEvtObjectInit.9213.4221>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8003940:	b082      	sub	sp, #8
 8003942:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8003944:	9b01      	ldr	r3, [sp, #4]
 8003946:	9a01      	ldr	r2, [sp, #4]
 8003948:	601a      	str	r2, [r3, #0]
}
 800394a:	b002      	add	sp, #8
 800394c:	4770      	bx	lr
 800394e:	bf00      	nop

08003950 <chIQIsEmptyI.9352>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8003950:	b500      	push	{lr}
 8003952:	b083      	sub	sp, #12
 8003954:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003956:	f000 fceb 	bl	8004330 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 800395a:	9b01      	ldr	r3, [sp, #4]
 800395c:	689b      	ldr	r3, [r3, #8]
 800395e:	2b00      	cmp	r3, #0
 8003960:	bf14      	ite	ne
 8003962:	2300      	movne	r3, #0
 8003964:	2301      	moveq	r3, #1
 8003966:	b2db      	uxtb	r3, r3
}
 8003968:	4618      	mov	r0, r3
 800396a:	b003      	add	sp, #12
 800396c:	bd00      	pop	{pc}
 800396e:	bf00      	nop

08003970 <osalSysLock.9374.4215>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8003970:	b508      	push	{r3, lr}

  chSysLock();
 8003972:	f7ff ffb5 	bl	80038e0 <chSysLock.9372.4226>
}
 8003976:	bd08      	pop	{r3, pc}
 8003978:	f3af 8000 	nop.w
 800397c:	f3af 8000 	nop.w

08003980 <osalSysUnlock.9380.4213>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8003980:	b508      	push	{r3, lr}

  chSysUnlock();
 8003982:	f7ff ffb5 	bl	80038f0 <chSysUnlock.9378.4224>
}
 8003986:	bd08      	pop	{r3, pc}
 8003988:	f3af 8000 	nop.w
 800398c:	f3af 8000 	nop.w

08003990 <osalEventObjectInit.9309.4210>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8003990:	b500      	push	{lr}
 8003992:	b083      	sub	sp, #12
 8003994:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8003996:	9801      	ldr	r0, [sp, #4]
 8003998:	f7ff ffd2 	bl	8003940 <chEvtObjectInit.9213.4221>
}
 800399c:	b003      	add	sp, #12
 800399e:	bd00      	pop	{pc}

080039a0 <osalEventBroadcastFlagsI.9368>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80039a0:	b500      	push	{lr}
 80039a2:	b083      	sub	sp, #12
 80039a4:	9001      	str	r0, [sp, #4]
 80039a6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 80039a8:	9801      	ldr	r0, [sp, #4]
 80039aa:	9900      	ldr	r1, [sp, #0]
 80039ac:	f7ff f9f0 	bl	8002d90 <chEvtBroadcastFlagsI>
}
 80039b0:	b003      	add	sp, #12
 80039b2:	bd00      	pop	{pc}
 80039b4:	f3af 8000 	nop.w
 80039b8:	f3af 8000 	nop.w
 80039bc:	f3af 8000 	nop.w

080039c0 <write.9331>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 80039c0:	b500      	push	{lr}
 80039c2:	b085      	sub	sp, #20
 80039c4:	9003      	str	r0, [sp, #12]
 80039c6:	9102      	str	r1, [sp, #8]
 80039c8:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80039ca:	9b03      	ldr	r3, [sp, #12]
 80039cc:	f103 0330 	add.w	r3, r3, #48	; 0x30
 80039d0:	4618      	mov	r0, r3
 80039d2:	9902      	ldr	r1, [sp, #8]
 80039d4:	9a01      	ldr	r2, [sp, #4]
 80039d6:	f04f 33ff 	mov.w	r3, #4294967295
 80039da:	f7ff fcc9 	bl	8003370 <chOQWriteTimeout.4415>
 80039de:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 80039e0:	4618      	mov	r0, r3
 80039e2:	b005      	add	sp, #20
 80039e4:	bd00      	pop	{pc}
 80039e6:	bf00      	nop
 80039e8:	f3af 8000 	nop.w
 80039ec:	f3af 8000 	nop.w

080039f0 <read.9320>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 80039f0:	b500      	push	{lr}
 80039f2:	b085      	sub	sp, #20
 80039f4:	9003      	str	r0, [sp, #12]
 80039f6:	9102      	str	r1, [sp, #8]
 80039f8:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80039fa:	9b03      	ldr	r3, [sp, #12]
 80039fc:	f103 030c 	add.w	r3, r3, #12
 8003a00:	4618      	mov	r0, r3
 8003a02:	9902      	ldr	r1, [sp, #8]
 8003a04:	9a01      	ldr	r2, [sp, #4]
 8003a06:	f04f 33ff 	mov.w	r3, #4294967295
 8003a0a:	f7ff fba1 	bl	8003150 <chIQReadTimeout.4436>
 8003a0e:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 8003a10:	4618      	mov	r0, r3
 8003a12:	b005      	add	sp, #20
 8003a14:	bd00      	pop	{pc}
 8003a16:	bf00      	nop
 8003a18:	f3af 8000 	nop.w
 8003a1c:	f3af 8000 	nop.w

08003a20 <put.9348>:

static msg_t put(void *ip, uint8_t b) {
 8003a20:	b500      	push	{lr}
 8003a22:	b083      	sub	sp, #12
 8003a24:	9001      	str	r0, [sp, #4]
 8003a26:	460b      	mov	r3, r1
 8003a28:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8003a2c:	9b01      	ldr	r3, [sp, #4]
 8003a2e:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8003a32:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8003a36:	4610      	mov	r0, r2
 8003a38:	4619      	mov	r1, r3
 8003a3a:	f04f 32ff 	mov.w	r2, #4294967295
 8003a3e:	f7ff fc17 	bl	8003270 <chOQPutTimeout.4424>
 8003a42:	4603      	mov	r3, r0
}
 8003a44:	4618      	mov	r0, r3
 8003a46:	b003      	add	sp, #12
 8003a48:	bd00      	pop	{pc}
 8003a4a:	bf00      	nop
 8003a4c:	f3af 8000 	nop.w

08003a50 <get.9340>:

static msg_t get(void *ip) {
 8003a50:	b500      	push	{lr}
 8003a52:	b083      	sub	sp, #12
 8003a54:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8003a56:	9b01      	ldr	r3, [sp, #4]
 8003a58:	f103 030c 	add.w	r3, r3, #12
 8003a5c:	4618      	mov	r0, r3
 8003a5e:	f04f 31ff 	mov.w	r1, #4294967295
 8003a62:	f7ff fb2d 	bl	80030c0 <chIQGetTimeout.4442>
 8003a66:	4603      	mov	r3, r0
}
 8003a68:	4618      	mov	r0, r3
 8003a6a:	b003      	add	sp, #12
 8003a6c:	bd00      	pop	{pc}
 8003a6e:	bf00      	nop

08003a70 <putt.9343>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8003a70:	b500      	push	{lr}
 8003a72:	b085      	sub	sp, #20
 8003a74:	9003      	str	r0, [sp, #12]
 8003a76:	460b      	mov	r3, r1
 8003a78:	9201      	str	r2, [sp, #4]
 8003a7a:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8003a7e:	9b03      	ldr	r3, [sp, #12]
 8003a80:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8003a84:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003a88:	4610      	mov	r0, r2
 8003a8a:	4619      	mov	r1, r3
 8003a8c:	9a01      	ldr	r2, [sp, #4]
 8003a8e:	f7ff fbef 	bl	8003270 <chOQPutTimeout.4424>
 8003a92:	4603      	mov	r3, r0
}
 8003a94:	4618      	mov	r0, r3
 8003a96:	b005      	add	sp, #20
 8003a98:	bd00      	pop	{pc}
 8003a9a:	bf00      	nop
 8003a9c:	f3af 8000 	nop.w

08003aa0 <gett.9336>:

static msg_t gett(void *ip, systime_t timeout) {
 8003aa0:	b500      	push	{lr}
 8003aa2:	b083      	sub	sp, #12
 8003aa4:	9001      	str	r0, [sp, #4]
 8003aa6:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8003aa8:	9b01      	ldr	r3, [sp, #4]
 8003aaa:	f103 030c 	add.w	r3, r3, #12
 8003aae:	4618      	mov	r0, r3
 8003ab0:	9900      	ldr	r1, [sp, #0]
 8003ab2:	f7ff fb05 	bl	80030c0 <chIQGetTimeout.4442>
 8003ab6:	4603      	mov	r3, r0
}
 8003ab8:	4618      	mov	r0, r3
 8003aba:	b003      	add	sp, #12
 8003abc:	bd00      	pop	{pc}
 8003abe:	bf00      	nop

08003ac0 <writet.9325>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8003ac0:	b500      	push	{lr}
 8003ac2:	b085      	sub	sp, #20
 8003ac4:	9003      	str	r0, [sp, #12]
 8003ac6:	9102      	str	r1, [sp, #8]
 8003ac8:	9201      	str	r2, [sp, #4]
 8003aca:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8003acc:	9b03      	ldr	r3, [sp, #12]
 8003ace:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8003ad2:	4618      	mov	r0, r3
 8003ad4:	9902      	ldr	r1, [sp, #8]
 8003ad6:	9a01      	ldr	r2, [sp, #4]
 8003ad8:	9b00      	ldr	r3, [sp, #0]
 8003ada:	f7ff fc49 	bl	8003370 <chOQWriteTimeout.4415>
 8003ade:	4603      	mov	r3, r0
}
 8003ae0:	4618      	mov	r0, r3
 8003ae2:	b005      	add	sp, #20
 8003ae4:	bd00      	pop	{pc}
 8003ae6:	bf00      	nop
 8003ae8:	f3af 8000 	nop.w
 8003aec:	f3af 8000 	nop.w

08003af0 <readt.9312>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8003af0:	b500      	push	{lr}
 8003af2:	b085      	sub	sp, #20
 8003af4:	9003      	str	r0, [sp, #12]
 8003af6:	9102      	str	r1, [sp, #8]
 8003af8:	9201      	str	r2, [sp, #4]
 8003afa:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8003afc:	9b03      	ldr	r3, [sp, #12]
 8003afe:	f103 030c 	add.w	r3, r3, #12
 8003b02:	4618      	mov	r0, r3
 8003b04:	9902      	ldr	r1, [sp, #8]
 8003b06:	9a01      	ldr	r2, [sp, #4]
 8003b08:	9b00      	ldr	r3, [sp, #0]
 8003b0a:	f7ff fb21 	bl	8003150 <chIQReadTimeout.4436>
 8003b0e:	4603      	mov	r3, r0
}
 8003b10:	4618      	mov	r0, r3
 8003b12:	b005      	add	sp, #20
 8003b14:	bd00      	pop	{pc}
 8003b16:	bf00      	nop
 8003b18:	f3af 8000 	nop.w
 8003b1c:	f3af 8000 	nop.w

08003b20 <sdInit.4166>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8003b20:	b508      	push	{r3, lr}

  sd_lld_init();
 8003b22:	f7fe ff75 	bl	8002a10 <sd_lld_init>
}
 8003b26:	bd08      	pop	{r3, pc}
 8003b28:	f3af 8000 	nop.w
 8003b2c:	f3af 8000 	nop.w

08003b30 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8003b30:	b500      	push	{lr}
 8003b32:	b087      	sub	sp, #28
 8003b34:	9005      	str	r0, [sp, #20]
 8003b36:	9104      	str	r1, [sp, #16]
 8003b38:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 8003b3a:	9a05      	ldr	r2, [sp, #20]
 8003b3c:	f245 7340 	movw	r3, #22336	; 0x5740
 8003b40:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003b44:	6013      	str	r3, [r2, #0]
  osalEventObjectInit(&sdp->event);
 8003b46:	9b05      	ldr	r3, [sp, #20]
 8003b48:	f103 0304 	add.w	r3, r3, #4
 8003b4c:	4618      	mov	r0, r3
 8003b4e:	f7ff ff1f 	bl	8003990 <osalEventObjectInit.9309.4210>
  sdp->state = SD_STOP;
 8003b52:	9b05      	ldr	r3, [sp, #20]
 8003b54:	f04f 0201 	mov.w	r2, #1
 8003b58:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8003b5a:	9b05      	ldr	r3, [sp, #20]
 8003b5c:	f103 020c 	add.w	r2, r3, #12
 8003b60:	9b05      	ldr	r3, [sp, #20]
 8003b62:	f103 0354 	add.w	r3, r3, #84	; 0x54
 8003b66:	9905      	ldr	r1, [sp, #20]
 8003b68:	9100      	str	r1, [sp, #0]
 8003b6a:	4610      	mov	r0, r2
 8003b6c:	4619      	mov	r1, r3
 8003b6e:	f04f 0210 	mov.w	r2, #16
 8003b72:	9b04      	ldr	r3, [sp, #16]
 8003b74:	f7ff fa44 	bl	8003000 <chIQObjectInit.4450>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8003b78:	9b05      	ldr	r3, [sp, #20]
 8003b7a:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8003b7e:	9b05      	ldr	r3, [sp, #20]
 8003b80:	f103 0364 	add.w	r3, r3, #100	; 0x64
 8003b84:	9905      	ldr	r1, [sp, #20]
 8003b86:	9100      	str	r1, [sp, #0]
 8003b88:	4610      	mov	r0, r2
 8003b8a:	4619      	mov	r1, r3
 8003b8c:	f04f 0210 	mov.w	r2, #16
 8003b90:	9b03      	ldr	r3, [sp, #12]
 8003b92:	f7ff fb45 	bl	8003220 <chOQObjectInit.4429>
}
 8003b96:	b007      	add	sp, #28
 8003b98:	bd00      	pop	{pc}
 8003b9a:	bf00      	nop
 8003b9c:	f3af 8000 	nop.w

08003ba0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8003ba0:	b500      	push	{lr}
 8003ba2:	b083      	sub	sp, #12
 8003ba4:	9001      	str	r0, [sp, #4]
 8003ba6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);
 8003ba8:	9b01      	ldr	r3, [sp, #4]
 8003baa:	2b00      	cmp	r3, #0
 8003bac:	d105      	bne.n	8003bba <sdStart+0x1a>
 8003bae:	f245 7080 	movw	r0, #22400	; 0x5780
 8003bb2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003bb6:	f000 fa73 	bl	80040a0 <chSysHalt>

  osalSysLock();
 8003bba:	f7ff fed9 	bl	8003970 <osalSysLock.9374.4215>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 8003bbe:	9b01      	ldr	r3, [sp, #4]
 8003bc0:	7a1b      	ldrb	r3, [r3, #8]
 8003bc2:	2b01      	cmp	r3, #1
 8003bc4:	d009      	beq.n	8003bda <sdStart+0x3a>
 8003bc6:	9b01      	ldr	r3, [sp, #4]
 8003bc8:	7a1b      	ldrb	r3, [r3, #8]
 8003bca:	2b02      	cmp	r3, #2
 8003bcc:	d005      	beq.n	8003bda <sdStart+0x3a>
 8003bce:	f245 7080 	movw	r0, #22400	; 0x5780
 8003bd2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003bd6:	f000 fa63 	bl	80040a0 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
 8003bda:	9801      	ldr	r0, [sp, #4]
 8003bdc:	9900      	ldr	r1, [sp, #0]
 8003bde:	f7fe ff47 	bl	8002a70 <sd_lld_start>
  sdp->state = SD_READY;
 8003be2:	9b01      	ldr	r3, [sp, #4]
 8003be4:	f04f 0202 	mov.w	r2, #2
 8003be8:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 8003bea:	f7ff fec9 	bl	8003980 <osalSysUnlock.9380.4213>
}
 8003bee:	b003      	add	sp, #12
 8003bf0:	bd00      	pop	{pc}
 8003bf2:	bf00      	nop
 8003bf4:	f3af 8000 	nop.w
 8003bf8:	f3af 8000 	nop.w
 8003bfc:	f3af 8000 	nop.w

08003c00 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8003c00:	4770      	bx	lr
 8003c02:	bf00      	nop
 8003c04:	f3af 8000 	nop.w
 8003c08:	f3af 8000 	nop.w
 8003c0c:	f3af 8000 	nop.w

08003c10 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8003c10:	4770      	bx	lr
 8003c12:	bf00      	nop
 8003c14:	f3af 8000 	nop.w
 8003c18:	f3af 8000 	nop.w
 8003c1c:	f3af 8000 	nop.w

08003c20 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8003c20:	e7fe      	b.n	8003c20 <__default_exit>
 8003c22:	bf00      	nop
 8003c24:	f3af 8000 	nop.w
 8003c28:	f3af 8000 	nop.w
 8003c2c:	f3af 8000 	nop.w

08003c30 <BusFault_Handler.4379>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8003c30:	e7fe      	b.n	8003c30 <BusFault_Handler.4379>
 8003c32:	bf00      	nop
 8003c34:	f3af 8000 	nop.w
 8003c38:	f3af 8000 	nop.w
 8003c3c:	f3af 8000 	nop.w

08003c40 <NVIC_SetPriorityGrouping.4150.4370>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8003c40:	b084      	sub	sp, #16
 8003c42:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
 8003c44:	9b01      	ldr	r3, [sp, #4]
 8003c46:	f003 0307 	and.w	r3, r3, #7
 8003c4a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003c4c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003c50:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003c54:	68db      	ldr	r3, [r3, #12]
 8003c56:	9302      	str	r3, [sp, #8]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 8003c58:	9a02      	ldr	r2, [sp, #8]
 8003c5a:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8003c5e:	4013      	ands	r3, r2
 8003c60:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
 8003c62:	9b03      	ldr	r3, [sp, #12]
 8003c64:	ea4f 2203 	mov.w	r2, r3, lsl #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
 8003c68:	9b02      	ldr	r3, [sp, #8]
 8003c6a:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 8003c6c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8003c70:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003c74:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8003c76:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003c7a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003c7e:	9a02      	ldr	r2, [sp, #8]
 8003c80:	60da      	str	r2, [r3, #12]
}
 8003c82:	b004      	add	sp, #16
 8003c84:	4770      	bx	lr
 8003c86:	bf00      	nop
 8003c88:	f3af 8000 	nop.w
 8003c8c:	f3af 8000 	nop.w

08003c90 <NVIC_SetPriority.4155.4364>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8003c90:	b082      	sub	sp, #8
 8003c92:	4603      	mov	r3, r0
 8003c94:	9100      	str	r1, [sp, #0]
 8003c96:	f88d 3007 	strb.w	r3, [sp, #7]
  if(IRQn < 0) {
 8003c9a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8003c9e:	2b00      	cmp	r3, #0
 8003ca0:	da11      	bge.n	8003cc6 <NVIC_SetPriority.4155.4364+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8003ca2:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003ca6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003caa:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8003cae:	f002 020f 	and.w	r2, r2, #15
 8003cb2:	f1a2 0104 	sub.w	r1, r2, #4
 8003cb6:	9a00      	ldr	r2, [sp, #0]
 8003cb8:	b2d2      	uxtb	r2, r2
 8003cba:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8003cbe:	b2d2      	uxtb	r2, r2
 8003cc0:	185b      	adds	r3, r3, r1
 8003cc2:	761a      	strb	r2, [r3, #24]
 8003cc4:	e00d      	b.n	8003ce2 <NVIC_SetPriority.4155.4364+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8003cc6:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8003cca:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003cce:	f99d 1007 	ldrsb.w	r1, [sp, #7]
 8003cd2:	9a00      	ldr	r2, [sp, #0]
 8003cd4:	b2d2      	uxtb	r2, r2
 8003cd6:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8003cda:	b2d2      	uxtb	r2, r2
 8003cdc:	185b      	adds	r3, r3, r1
 8003cde:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8003ce2:	b002      	add	sp, #8
 8003ce4:	4770      	bx	lr
 8003ce6:	bf00      	nop
 8003ce8:	f3af 8000 	nop.w
 8003cec:	f3af 8000 	nop.w

08003cf0 <port_init.4161.4362>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8003cf0:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8003cf2:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8003cf6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003cfa:	f04f 0200 	mov.w	r2, #0
 8003cfe:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8003d00:	f04f 0003 	mov.w	r0, #3
 8003d04:	f7ff ff9c 	bl	8003c40 <NVIC_SetPriorityGrouping.4150.4370>

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8003d08:	f64e 53f0 	movw	r3, #60912	; 0xedf0
 8003d0c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003d10:	f64e 52f0 	movw	r2, #60912	; 0xedf0
 8003d14:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8003d18:	68d2      	ldr	r2, [r2, #12]
 8003d1a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8003d1e:	60da      	str	r2, [r3, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8003d20:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003d24:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8003d28:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8003d2c:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8003d30:	6812      	ldr	r2, [r2, #0]
 8003d32:	f042 0201 	orr.w	r2, r2, #1
 8003d36:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8003d38:	f06f 0004 	mvn.w	r0, #4
 8003d3c:	f04f 0101 	mov.w	r1, #1
 8003d40:	f7ff ffa6 	bl	8003c90 <NVIC_SetPriority.4155.4364>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8003d44:	f06f 0001 	mvn.w	r0, #1
 8003d48:	f04f 0102 	mov.w	r1, #2
 8003d4c:	f7ff ffa0 	bl	8003c90 <NVIC_SetPriority.4155.4364>
}
 8003d50:	bd08      	pop	{r3, pc}
 8003d52:	bf00      	nop
 8003d54:	f3af 8000 	nop.w
 8003d58:	f3af 8000 	nop.w
 8003d5c:	f3af 8000 	nop.w

08003d60 <port_lock.4172.4360>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003d60:	b082      	sub	sp, #8
 8003d62:	f04f 0320 	mov.w	r3, #32
 8003d66:	9301      	str	r3, [sp, #4]
 8003d68:	9b01      	ldr	r3, [sp, #4]
 8003d6a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003d6e:	b002      	add	sp, #8
 8003d70:	4770      	bx	lr
 8003d72:	bf00      	nop
 8003d74:	f3af 8000 	nop.w
 8003d78:	f3af 8000 	nop.w
 8003d7c:	f3af 8000 	nop.w

08003d80 <port_unlock.4174.4358>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003d80:	b082      	sub	sp, #8
 8003d82:	f04f 0300 	mov.w	r3, #0
 8003d86:	9301      	str	r3, [sp, #4]
 8003d88:	9b01      	ldr	r3, [sp, #4]
 8003d8a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003d8e:	b002      	add	sp, #8
 8003d90:	4770      	bx	lr
 8003d92:	bf00      	nop
 8003d94:	f3af 8000 	nop.w
 8003d98:	f3af 8000 	nop.w
 8003d9c:	f3af 8000 	nop.w

08003da0 <port_lock_from_isr.4176.4356>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8003da0:	b508      	push	{r3, lr}

  port_lock();
 8003da2:	f7ff ffdd 	bl	8003d60 <port_lock.4172.4360>
}
 8003da6:	bd08      	pop	{r3, pc}
 8003da8:	f3af 8000 	nop.w
 8003dac:	f3af 8000 	nop.w

08003db0 <port_unlock_from_isr.4178.4354>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8003db0:	b508      	push	{r3, lr}

  port_unlock();
 8003db2:	f7ff ffe5 	bl	8003d80 <port_unlock.4174.4358>
}
 8003db6:	bd08      	pop	{r3, pc}
 8003db8:	f3af 8000 	nop.w
 8003dbc:	f3af 8000 	nop.w

08003dc0 <port_disable.4180.4352>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003dc0:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8003dc2:	4770      	bx	lr
 8003dc4:	f3af 8000 	nop.w
 8003dc8:	f3af 8000 	nop.w
 8003dcc:	f3af 8000 	nop.w

08003dd0 <port_enable.4182.4350>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8003dd0:	b082      	sub	sp, #8
 8003dd2:	f04f 0300 	mov.w	r3, #0
 8003dd6:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003dd8:	9b01      	ldr	r3, [sp, #4]
 8003dda:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003dde:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 8003de0:	b002      	add	sp, #8
 8003de2:	4770      	bx	lr
 8003de4:	f3af 8000 	nop.w
 8003de8:	f3af 8000 	nop.w
 8003dec:	f3af 8000 	nop.w

08003df0 <port_wait_for_interrupt.4184.4348>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8003df0:	4770      	bx	lr
 8003df2:	bf00      	nop
 8003df4:	f3af 8000 	nop.w
 8003df8:	f3af 8000 	nop.w
 8003dfc:	f3af 8000 	nop.w

08003e00 <st_lld_get_counter.4189.4346>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003e00:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003e04:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8003e06:	4618      	mov	r0, r3
 8003e08:	4770      	bx	lr
 8003e0a:	bf00      	nop
 8003e0c:	f3af 8000 	nop.w

08003e10 <port_timer_stop_alarm.4292.4344>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8003e10:	b508      	push	{r3, lr}

  stStopAlarm();
 8003e12:	f7ff fce5 	bl	80037e0 <stStopAlarm>
}
 8003e16:	bd08      	pop	{r3, pc}
 8003e18:	f3af 8000 	nop.w
 8003e1c:	f3af 8000 	nop.w

08003e20 <port_timer_set_alarm.4294.4341>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8003e20:	b500      	push	{lr}
 8003e22:	b083      	sub	sp, #12
 8003e24:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8003e26:	9801      	ldr	r0, [sp, #4]
 8003e28:	f7ff fce2 	bl	80037f0 <stSetAlarm>
}
 8003e2c:	b003      	add	sp, #12
 8003e2e:	bd00      	pop	{pc}

08003e30 <port_timer_get_time.4192.4339>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8003e30:	b508      	push	{r3, lr}

  return stGetCounter();
 8003e32:	f7ff ffe5 	bl	8003e00 <st_lld_get_counter.4189.4346>
 8003e36:	4603      	mov	r3, r0
}
 8003e38:	4618      	mov	r0, r3
 8003e3a:	bd08      	pop	{r3, pc}
 8003e3c:	f3af 8000 	nop.w

08003e40 <chSysEnable.4297.4337>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8003e40:	b508      	push	{r3, lr}

  _dbg_check_enable();
 8003e42:	f000 f98d 	bl	8004160 <_dbg_check_enable.4296>
  port_enable();
 8003e46:	f7ff ffc3 	bl	8003dd0 <port_enable.4182.4350>
}
 8003e4a:	bd08      	pop	{r3, pc}
 8003e4c:	f3af 8000 	nop.w

08003e50 <chSysLockFromISR.4288.4335>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8003e50:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8003e52:	f7ff ffa5 	bl	8003da0 <port_lock_from_isr.4176.4356>
  _stats_start_measure_crit_isr();
 8003e56:	f7fe ff63 	bl	8002d20 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8003e5a:	f000 f9d9 	bl	8004210 <_dbg_check_lock_from_isr>
}
 8003e5e:	bd08      	pop	{r3, pc}

08003e60 <chSysUnlockFromISR.4286.4333>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8003e60:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8003e62:	f000 f9f5 	bl	8004250 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8003e66:	f7fe ff63 	bl	8002d30 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 8003e6a:	f7ff ffa1 	bl	8003db0 <port_unlock_from_isr.4178.4354>
}
 8003e6e:	bd08      	pop	{r3, pc}

08003e70 <chVTGetSystemTimeX.4194.4331>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8003e70:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8003e72:	f7ff ffdd 	bl	8003e30 <port_timer_get_time.4192.4339>
 8003e76:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003e78:	4618      	mov	r0, r3
 8003e7a:	bd08      	pop	{r3, pc}
 8003e7c:	f3af 8000 	nop.w

08003e80 <chVTDoTickI.4306.4329>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8003e80:	b500      	push	{lr}
 8003e82:	b085      	sub	sp, #20

  chDbgCheckClassI();
 8003e84:	f000 fa54 	bl	8004330 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8003e88:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003e8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003e90:	69db      	ldr	r3, [r3, #28]
 8003e92:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 8003e94:	f7ff ffec 	bl	8003e70 <chVTGetSystemTimeX.4194.4331>
 8003e98:	9002      	str	r0, [sp, #8]
 8003e9a:	e03a      	b.n	8003f12 <chVTDoTickI.4306.4329+0x92>
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8003e9c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003ea0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ea4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003ea6:	9b03      	ldr	r3, [sp, #12]
 8003ea8:	689b      	ldr	r3, [r3, #8]
 8003eaa:	18d2      	adds	r2, r2, r3
 8003eac:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003eb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003eb4:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8003eb6:	9b03      	ldr	r3, [sp, #12]
 8003eb8:	681b      	ldr	r3, [r3, #0]
 8003eba:	4a39      	ldr	r2, [pc, #228]	; (8003fa0 <chVTDoTickI.4306.4329+0x120>)
 8003ebc:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8003ebe:	9b03      	ldr	r3, [sp, #12]
 8003ec0:	681a      	ldr	r2, [r3, #0]
 8003ec2:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003ec6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003eca:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
 8003ecc:	9b03      	ldr	r3, [sp, #12]
 8003ece:	68db      	ldr	r3, [r3, #12]
 8003ed0:	9300      	str	r3, [sp, #0]
    vtp->vt_func = NULL;
 8003ed2:	9b03      	ldr	r3, [sp, #12]
 8003ed4:	f04f 0200 	mov.w	r2, #0
 8003ed8:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8003eda:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003ede:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ee2:	69da      	ldr	r2, [r3, #28]
 8003ee4:	4b2e      	ldr	r3, [pc, #184]	; (8003fa0 <chVTDoTickI.4306.4329+0x120>)
 8003ee6:	429a      	cmp	r2, r3
 8003ee8:	d101      	bne.n	8003eee <chVTDoTickI.4306.4329+0x6e>
      port_timer_stop_alarm();
 8003eea:	f7ff ff91 	bl	8003e10 <port_timer_stop_alarm.4292.4344>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 8003eee:	f7ff ffb7 	bl	8003e60 <chSysUnlockFromISR.4286.4333>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8003ef2:	9b03      	ldr	r3, [sp, #12]
 8003ef4:	691a      	ldr	r2, [r3, #16]
 8003ef6:	9b00      	ldr	r3, [sp, #0]
 8003ef8:	4610      	mov	r0, r2
 8003efa:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 8003efc:	f7ff ffa8 	bl	8003e50 <chSysLockFromISR.4288.4335>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 8003f00:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003f04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f08:	69db      	ldr	r3, [r3, #28]
 8003f0a:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 8003f0c:	f7ff ffb0 	bl	8003e70 <chVTGetSystemTimeX.4194.4331>
 8003f10:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8003f12:	9b03      	ldr	r3, [sp, #12]
 8003f14:	689a      	ldr	r2, [r3, #8]
 8003f16:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003f1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003f20:	9902      	ldr	r1, [sp, #8]
 8003f22:	1acb      	subs	r3, r1, r3
 8003f24:	429a      	cmp	r2, r3
 8003f26:	d9b9      	bls.n	8003e9c <chVTDoTickI.4306.4329+0x1c>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8003f28:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003f2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f30:	69da      	ldr	r2, [r3, #28]
 8003f32:	4b1b      	ldr	r3, [pc, #108]	; (8003fa0 <chVTDoTickI.4306.4329+0x120>)
 8003f34:	429a      	cmp	r2, r3
 8003f36:	d030      	beq.n	8003f9a <chVTDoTickI.4306.4329+0x11a>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8003f38:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003f3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f40:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003f42:	9b03      	ldr	r3, [sp, #12]
 8003f44:	689b      	ldr	r3, [r3, #8]
 8003f46:	18d2      	adds	r2, r2, r3
 8003f48:	9b02      	ldr	r3, [sp, #8]
 8003f4a:	1ad3      	subs	r3, r2, r3
 8003f4c:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8003f4e:	9b01      	ldr	r3, [sp, #4]
 8003f50:	2b01      	cmp	r3, #1
 8003f52:	d802      	bhi.n	8003f5a <chVTDoTickI.4306.4329+0xda>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8003f54:	f04f 0302 	mov.w	r3, #2
 8003f58:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
 8003f5a:	9a02      	ldr	r2, [sp, #8]
 8003f5c:	9b01      	ldr	r3, [sp, #4]
 8003f5e:	18d3      	adds	r3, r2, r3
 8003f60:	4618      	mov	r0, r3
 8003f62:	f7ff ff5d 	bl	8003e20 <port_timer_set_alarm.4294.4341>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
 8003f66:	f7ff ff83 	bl	8003e70 <chVTGetSystemTimeX.4194.4331>
 8003f6a:	4602      	mov	r2, r0
 8003f6c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003f70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003f76:	1ad2      	subs	r2, r2, r3
 8003f78:	9902      	ldr	r1, [sp, #8]
 8003f7a:	9b01      	ldr	r3, [sp, #4]
 8003f7c:	18c9      	adds	r1, r1, r3
 8003f7e:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003f82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f86:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003f88:	1acb      	subs	r3, r1, r3
 8003f8a:	429a      	cmp	r2, r3
 8003f8c:	d905      	bls.n	8003f9a <chVTDoTickI.4306.4329+0x11a>
 8003f8e:	f245 50d0 	movw	r0, #21968	; 0x55d0
 8003f92:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003f96:	f000 f883 	bl	80040a0 <chSysHalt>
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003f9a:	b005      	add	sp, #20
 8003f9c:	bd00      	pop	{pc}
 8003f9e:	bf00      	nop
 8003fa0:	200036cc 	.word	0x200036cc
 8003fa4:	f3af 8000 	nop.w
 8003fa8:	f3af 8000 	nop.w
 8003fac:	f3af 8000 	nop.w

08003fb0 <chRegSetThreadName.4196.4326>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8003fb0:	b082      	sub	sp, #8
 8003fb2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8003fb4:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8003fb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fbc:	699b      	ldr	r3, [r3, #24]
 8003fbe:	9a01      	ldr	r2, [sp, #4]
 8003fc0:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8003fc2:	b002      	add	sp, #8
 8003fc4:	4770      	bx	lr
 8003fc6:	bf00      	nop
 8003fc8:	f3af 8000 	nop.w
 8003fcc:	f3af 8000 	nop.w

08003fd0 <chRegSetThreadNameX.4200.4322>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8003fd0:	b082      	sub	sp, #8
 8003fd2:	9001      	str	r0, [sp, #4]
 8003fd4:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8003fd6:	9b01      	ldr	r3, [sp, #4]
 8003fd8:	9a00      	ldr	r2, [sp, #0]
 8003fda:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 8003fdc:	b002      	add	sp, #8
 8003fde:	4770      	bx	lr

08003fe0 <_idle_thread.4283.4319>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8003fe0:	b500      	push	{lr}
 8003fe2:	b083      	sub	sp, #12
 8003fe4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8003fe6:	f7ff ff03 	bl	8003df0 <port_wait_for_interrupt.4184.4348>
 8003fea:	e7fc      	b.n	8003fe6 <_idle_thread.4283.4319+0x6>
 8003fec:	f3af 8000 	nop.w

08003ff0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8003ff0:	b500      	push	{lr}
 8003ff2:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8003ff4:	f7ff fe7c 	bl	8003cf0 <port_init.4161.4362>
  _scheduler_init();
 8003ff8:	f000 fc52 	bl	80048a0 <_scheduler_init.4209>
  _vt_init();
 8003ffc:	f000 fa50 	bl	80044a0 <_vt_init.4258>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 8004000:	f001 f946 	bl	8005290 <_tm_init.4021>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8004004:	f7ff fa6c 	bl	80034e0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8004008:	f7ff fad2 	bl	80035b0 <_heap_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  _stats_init();
 800400c:	f7fe fe28 	bl	8002c60 <_stats_init>
#endif
#if CH_DBG_ENABLE_TRACE == TRUE
  _dbg_trace_init();
 8004010:	f000 f9be 	bl	8004390 <_dbg_trace_init.4278>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8004014:	481e      	ldr	r0, [pc, #120]	; (8004090 <chSysInit+0xa0>)
 8004016:	f04f 0140 	mov.w	r1, #64	; 0x40
 800401a:	f000 ff71 	bl	8004f00 <_thread_init.4142>
 800401e:	4602      	mov	r2, r0
 8004020:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004024:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004028:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800402a:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800402e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004032:	699b      	ldr	r3, [r3, #24]
 8004034:	f04f 0201 	mov.w	r2, #1
 8004038:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 800403c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004040:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004044:	699a      	ldr	r2, [r3, #24]
 8004046:	f641 3358 	movw	r3, #7000	; 0x1b58
 800404a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800404e:	61d3      	str	r3, [r2, #28]
#endif
  chSysEnable();
 8004050:	f7ff fef6 	bl	8003e40 <chSysEnable.4297.4337>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 8004054:	f245 6070 	movw	r0, #22128	; 0x5670
 8004058:	f6c0 0000 	movt	r0, #2048	; 0x800
 800405c:	f7ff ffa8 	bl	8003fb0 <chRegSetThreadName.4196.4326>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8004060:	f04f 0300 	mov.w	r3, #0
 8004064:	9300      	str	r3, [sp, #0]
 8004066:	480b      	ldr	r0, [pc, #44]	; (8004094 <chSysInit+0xa4>)
 8004068:	f04f 01f8 	mov.w	r1, #248	; 0xf8
 800406c:	f04f 0201 	mov.w	r2, #1
 8004070:	f643 73e1 	movw	r3, #16353	; 0x3fe1
 8004074:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004078:	f000 fffa 	bl	8005070 <chThdCreateStatic.4120>
 800407c:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 800407e:	9803      	ldr	r0, [sp, #12]
 8004080:	f245 5170 	movw	r1, #21872	; 0x5570
 8004084:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004088:	f7ff ffa2 	bl	8003fd0 <chRegSetThreadNameX.4200.4322>
  }
#endif
}
 800408c:	b005      	add	sp, #20
 800408e:	bd00      	pop	{pc}
 8004090:	20003af0 	.word	0x20003af0
 8004094:	20003b90 	.word	0x20003b90
 8004098:	f3af 8000 	nop.w
 800409c:	f3af 8000 	nop.w

080040a0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 80040a0:	b500      	push	{lr}
 80040a2:	b083      	sub	sp, #12
 80040a4:	9001      	str	r0, [sp, #4]

  port_disable();
 80040a6:	f7ff fe8b 	bl	8003dc0 <port_disable.4180.4352>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 80040aa:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80040ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040b2:	9a01      	ldr	r2, [sp, #4]
 80040b4:	62da      	str	r2, [r3, #44]	; 0x2c
 80040b6:	e7fe      	b.n	80040b6 <chSysHalt+0x16>
 80040b8:	f3af 8000 	nop.w
 80040bc:	f3af 8000 	nop.w

080040c0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80040c0:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 80040c2:	f000 f935 	bl	8004330 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 80040c6:	f7ff fedb 	bl	8003e80 <chVTDoTickI.4306.4329>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 80040ca:	bd08      	pop	{r3, pc}
 80040cc:	f3af 8000 	nop.w

080040d0 <port_lock.4537.4310>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80040d0:	b082      	sub	sp, #8
 80040d2:	f04f 0320 	mov.w	r3, #32
 80040d6:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80040d8:	9b01      	ldr	r3, [sp, #4]
 80040da:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80040de:	b002      	add	sp, #8
 80040e0:	4770      	bx	lr
 80040e2:	bf00      	nop
 80040e4:	f3af 8000 	nop.w
 80040e8:	f3af 8000 	nop.w
 80040ec:	f3af 8000 	nop.w

080040f0 <port_unlock.4540.4308>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80040f0:	b082      	sub	sp, #8
 80040f2:	f04f 0300 	mov.w	r3, #0
 80040f6:	9301      	str	r3, [sp, #4]
 80040f8:	9b01      	ldr	r3, [sp, #4]
 80040fa:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80040fe:	b002      	add	sp, #8
 8004100:	4770      	bx	lr
 8004102:	bf00      	nop
 8004104:	f3af 8000 	nop.w
 8004108:	f3af 8000 	nop.w
 800410c:	f3af 8000 	nop.w

08004110 <port_lock_from_isr.4542.4306>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8004110:	b508      	push	{r3, lr}

  port_lock();
 8004112:	f7ff ffdd 	bl	80040d0 <port_lock.4537.4310>
}
 8004116:	bd08      	pop	{r3, pc}
 8004118:	f3af 8000 	nop.w
 800411c:	f3af 8000 	nop.w

08004120 <port_unlock_from_isr.4544.4304>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8004120:	b508      	push	{r3, lr}

  port_unlock();
 8004122:	f7ff ffe5 	bl	80040f0 <port_unlock.4540.4308>
}
 8004126:	bd08      	pop	{r3, pc}
 8004128:	f3af 8000 	nop.w
 800412c:	f3af 8000 	nop.w

08004130 <st_lld_get_counter.4546.4302>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8004130:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004134:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8004136:	4618      	mov	r0, r3
 8004138:	4770      	bx	lr
 800413a:	bf00      	nop
 800413c:	f3af 8000 	nop.w

08004140 <port_timer_get_time.4550.4300>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8004140:	b508      	push	{r3, lr}

  return stGetCounter();
 8004142:	f7ff fff5 	bl	8004130 <st_lld_get_counter.4546.4302>
 8004146:	4603      	mov	r3, r0
}
 8004148:	4618      	mov	r0, r3
 800414a:	bd08      	pop	{r3, pc}
 800414c:	f3af 8000 	nop.w

08004150 <chVTGetSystemTimeX.4552.4298>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8004150:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8004152:	f7ff fff5 	bl	8004140 <port_timer_get_time.4550.4300>
 8004156:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8004158:	4618      	mov	r0, r3
 800415a:	bd08      	pop	{r3, pc}
 800415c:	f3af 8000 	nop.w

08004160 <_dbg_check_enable.4296>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 8004160:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004162:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004166:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800416a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800416c:	2b00      	cmp	r3, #0
 800416e:	d106      	bne.n	800417e <_dbg_check_enable.4296+0x1e>
 8004170:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004174:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004178:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800417a:	2b00      	cmp	r3, #0
 800417c:	d005      	beq.n	800418a <_dbg_check_enable.4296+0x2a>
    chSysHalt("SV#3");
 800417e:	f245 5078 	movw	r0, #21880	; 0x5578
 8004182:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004186:	f7ff ff8b 	bl	80040a0 <chSysHalt>
  }
}
 800418a:	bd08      	pop	{r3, pc}
 800418c:	f3af 8000 	nop.w

08004190 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 8004190:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004192:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004196:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800419a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800419c:	2b00      	cmp	r3, #0
 800419e:	d106      	bne.n	80041ae <_dbg_check_lock+0x1e>
 80041a0:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80041a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80041a8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80041aa:	2b00      	cmp	r3, #0
 80041ac:	d005      	beq.n	80041ba <_dbg_check_lock+0x2a>
    chSysHalt("SV#4");
 80041ae:	f245 5080 	movw	r0, #21888	; 0x5580
 80041b2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80041b6:	f7ff ff73 	bl	80040a0 <chSysHalt>
  }
  _dbg_enter_lock();
 80041ba:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80041be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80041c2:	f04f 0201 	mov.w	r2, #1
 80041c6:	635a      	str	r2, [r3, #52]	; 0x34
}
 80041c8:	bd08      	pop	{r3, pc}
 80041ca:	bf00      	nop
 80041cc:	f3af 8000 	nop.w

080041d0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 80041d0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80041d2:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80041d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80041da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80041dc:	2b00      	cmp	r3, #0
 80041de:	d106      	bne.n	80041ee <_dbg_check_unlock+0x1e>
 80041e0:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80041e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80041e8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80041ea:	2b00      	cmp	r3, #0
 80041ec:	dc05      	bgt.n	80041fa <_dbg_check_unlock+0x2a>
    chSysHalt("SV#5");
 80041ee:	f245 5088 	movw	r0, #21896	; 0x5588
 80041f2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80041f6:	f7ff ff53 	bl	80040a0 <chSysHalt>
  }
  _dbg_leave_lock();
 80041fa:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80041fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004202:	f04f 0200 	mov.w	r2, #0
 8004206:	635a      	str	r2, [r3, #52]	; 0x34
}
 8004208:	bd08      	pop	{r3, pc}
 800420a:	bf00      	nop
 800420c:	f3af 8000 	nop.w

08004210 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 8004210:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004212:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004216:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800421a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800421c:	2b00      	cmp	r3, #0
 800421e:	dd06      	ble.n	800422e <_dbg_check_lock_from_isr+0x1e>
 8004220:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004224:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004228:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800422a:	2b00      	cmp	r3, #0
 800422c:	d005      	beq.n	800423a <_dbg_check_lock_from_isr+0x2a>
    chSysHalt("SV#6");
 800422e:	f245 5090 	movw	r0, #21904	; 0x5590
 8004232:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004236:	f7ff ff33 	bl	80040a0 <chSysHalt>
  }
  _dbg_enter_lock();
 800423a:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800423e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004242:	f04f 0201 	mov.w	r2, #1
 8004246:	635a      	str	r2, [r3, #52]	; 0x34
}
 8004248:	bd08      	pop	{r3, pc}
 800424a:	bf00      	nop
 800424c:	f3af 8000 	nop.w

08004250 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 8004250:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8004252:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004256:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800425a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800425c:	2b00      	cmp	r3, #0
 800425e:	dd06      	ble.n	800426e <_dbg_check_unlock_from_isr+0x1e>
 8004260:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004264:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004268:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800426a:	2b00      	cmp	r3, #0
 800426c:	dc05      	bgt.n	800427a <_dbg_check_unlock_from_isr+0x2a>
    chSysHalt("SV#7");
 800426e:	f245 5098 	movw	r0, #21912	; 0x5598
 8004272:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004276:	f7ff ff13 	bl	80040a0 <chSysHalt>
  }
  _dbg_leave_lock();
 800427a:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800427e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004282:	f04f 0200 	mov.w	r2, #0
 8004286:	635a      	str	r2, [r3, #52]	; 0x34
}
 8004288:	bd08      	pop	{r3, pc}
 800428a:	bf00      	nop
 800428c:	f3af 8000 	nop.w

08004290 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 8004290:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8004292:	f7ff ff3d 	bl	8004110 <port_lock_from_isr.4542.4306>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004296:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800429a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800429e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80042a0:	2b00      	cmp	r3, #0
 80042a2:	db06      	blt.n	80042b2 <_dbg_check_enter_isr+0x22>
 80042a4:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80042a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80042ac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80042ae:	2b00      	cmp	r3, #0
 80042b0:	d005      	beq.n	80042be <_dbg_check_enter_isr+0x2e>
    chSysHalt("SV#8");
 80042b2:	f245 50a0 	movw	r0, #21920	; 0x55a0
 80042b6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80042ba:	f7ff fef1 	bl	80040a0 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 80042be:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80042c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80042c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80042c8:	f103 0201 	add.w	r2, r3, #1
 80042cc:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80042d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80042d4:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 80042d6:	f7ff ff23 	bl	8004120 <port_unlock_from_isr.4544.4304>
}
 80042da:	bd08      	pop	{r3, pc}
 80042dc:	f3af 8000 	nop.w

080042e0 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 80042e0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80042e2:	f7ff ff15 	bl	8004110 <port_lock_from_isr.4542.4306>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80042e6:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80042ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80042ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80042f0:	2b00      	cmp	r3, #0
 80042f2:	dd06      	ble.n	8004302 <_dbg_check_leave_isr+0x22>
 80042f4:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80042f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80042fc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80042fe:	2b00      	cmp	r3, #0
 8004300:	d005      	beq.n	800430e <_dbg_check_leave_isr+0x2e>
    chSysHalt("SV#9");
 8004302:	f245 50a8 	movw	r0, #21928	; 0x55a8
 8004306:	f6c0 0000 	movt	r0, #2048	; 0x800
 800430a:	f7ff fec9 	bl	80040a0 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800430e:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004312:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004316:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004318:	f103 32ff 	add.w	r2, r3, #4294967295
 800431c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004320:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004324:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 8004326:	f7ff fefb 	bl	8004120 <port_unlock_from_isr.4544.4304>
}
 800432a:	bd08      	pop	{r3, pc}
 800432c:	f3af 8000 	nop.w

08004330 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8004330:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8004332:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004336:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800433a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800433c:	2b00      	cmp	r3, #0
 800433e:	db06      	blt.n	800434e <chDbgCheckClassI+0x1e>
 8004340:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004344:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004348:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800434a:	2b00      	cmp	r3, #0
 800434c:	dc05      	bgt.n	800435a <chDbgCheckClassI+0x2a>
    chSysHalt("SV#10");
 800434e:	f245 50b0 	movw	r0, #21936	; 0x55b0
 8004352:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004356:	f7ff fea3 	bl	80040a0 <chSysHalt>
  }
}
 800435a:	bd08      	pop	{r3, pc}
 800435c:	f3af 8000 	nop.w

08004360 <chDbgCheckClassS.4280>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8004360:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8004362:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004366:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800436a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800436c:	2b00      	cmp	r3, #0
 800436e:	d106      	bne.n	800437e <chDbgCheckClassS.4280+0x1e>
 8004370:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004374:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004378:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800437a:	2b00      	cmp	r3, #0
 800437c:	dc05      	bgt.n	800438a <chDbgCheckClassS.4280+0x2a>
    chSysHalt("SV#11");
 800437e:	f245 50b8 	movw	r0, #21944	; 0x55b8
 8004382:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004386:	f7ff fe8b 	bl	80040a0 <chSysHalt>
  }
}
 800438a:	bd08      	pop	{r3, pc}
 800438c:	f3af 8000 	nop.w

08004390 <_dbg_trace_init.4278>:
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 8004390:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004394:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004398:	f04f 0240 	mov.w	r2, #64	; 0x40
 800439c:	639a      	str	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 800439e:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80043a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043a6:	4a01      	ldr	r2, [pc, #4]	; (80043ac <_dbg_trace_init.4278+0x1c>)
 80043a8:	63da      	str	r2, [r3, #60]	; 0x3c
}
 80043aa:	4770      	bx	lr
 80043ac:	200036f0 	.word	0x200036f0

080043b0 <_dbg_trace.4274>:
 *
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {
 80043b0:	b510      	push	{r4, lr}
 80043b2:	b082      	sub	sp, #8
 80043b4:	9001      	str	r0, [sp, #4]

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 80043b6:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80043ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043be:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 80043c0:	f7ff fec6 	bl	8004150 <chVTGetSystemTimeX.4552.4298>
 80043c4:	4603      	mov	r3, r0
 80043c6:	6023      	str	r3, [r4, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
 80043c8:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80043cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043d0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80043d2:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80043d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043da:	699b      	ldr	r3, [r3, #24]
 80043dc:	6053      	str	r3, [r2, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 80043de:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80043e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80043e8:	9a01      	ldr	r2, [sp, #4]
 80043ea:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80043ec:	609a      	str	r2, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 80043ee:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80043f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80043f8:	9a01      	ldr	r2, [sp, #4]
 80043fa:	f892 2020 	ldrb.w	r2, [r2, #32]
 80043fe:	731a      	strb	r2, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 8004400:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004404:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004408:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800440a:	f103 0210 	add.w	r2, r3, #16
 800440e:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004412:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004416:	63da      	str	r2, [r3, #60]	; 0x3c
 8004418:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800441c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004420:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8004422:	4b05      	ldr	r3, [pc, #20]	; (8004438 <_dbg_trace.4274+0x88>)
 8004424:	429a      	cmp	r2, r3
 8004426:	d305      	bcc.n	8004434 <_dbg_trace.4274+0x84>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 8004428:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800442c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004430:	4a02      	ldr	r2, [pc, #8]	; (800443c <_dbg_trace.4274+0x8c>)
 8004432:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 8004434:	b002      	add	sp, #8
 8004436:	bd10      	pop	{r4, pc}
 8004438:	20003af0 	.word	0x20003af0
 800443c:	200036f0 	.word	0x200036f0

08004440 <st_lld_get_counter.4746.4272>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8004440:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004444:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8004446:	4618      	mov	r0, r3
 8004448:	4770      	bx	lr
 800444a:	bf00      	nop
 800444c:	f3af 8000 	nop.w

08004450 <port_timer_start_alarm.4760.4269>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8004450:	b500      	push	{lr}
 8004452:	b083      	sub	sp, #12
 8004454:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 8004456:	9801      	ldr	r0, [sp, #4]
 8004458:	f7ff f9aa 	bl	80037b0 <stStartAlarm>
}
 800445c:	b003      	add	sp, #12
 800445e:	bd00      	pop	{pc}

08004460 <port_timer_stop_alarm.4755.4267>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8004460:	b508      	push	{r3, lr}

  stStopAlarm();
 8004462:	f7ff f9bd 	bl	80037e0 <stStopAlarm>
}
 8004466:	bd08      	pop	{r3, pc}
 8004468:	f3af 8000 	nop.w
 800446c:	f3af 8000 	nop.w

08004470 <port_timer_set_alarm.4757.4264>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8004470:	b500      	push	{lr}
 8004472:	b083      	sub	sp, #12
 8004474:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8004476:	9801      	ldr	r0, [sp, #4]
 8004478:	f7ff f9ba 	bl	80037f0 <stSetAlarm>
}
 800447c:	b003      	add	sp, #12
 800447e:	bd00      	pop	{pc}

08004480 <port_timer_get_time.4751.4262>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8004480:	b508      	push	{r3, lr}

  return stGetCounter();
 8004482:	f7ff ffdd 	bl	8004440 <st_lld_get_counter.4746.4272>
 8004486:	4603      	mov	r3, r0
}
 8004488:	4618      	mov	r0, r3
 800448a:	bd08      	pop	{r3, pc}
 800448c:	f3af 8000 	nop.w

08004490 <chVTGetSystemTimeX.4753.4260>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8004490:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8004492:	f7ff fff5 	bl	8004480 <port_timer_get_time.4751.4262>
 8004496:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8004498:	4618      	mov	r0, r3
 800449a:	bd08      	pop	{r3, pc}
 800449c:	f3af 8000 	nop.w

080044a0 <_vt_init.4258>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80044a0:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80044a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80044a8:	4a0b      	ldr	r2, [pc, #44]	; (80044d8 <_vt_init.4258+0x38>)
 80044aa:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 80044ac:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80044b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80044b4:	4a08      	ldr	r2, [pc, #32]	; (80044d8 <_vt_init.4258+0x38>)
 80044b6:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 80044b8:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80044bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80044c0:	f04f 32ff 	mov.w	r2, #4294967295
 80044c4:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 80044c6:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80044ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80044ce:	f04f 0200 	mov.w	r2, #0
 80044d2:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80044d4:	4770      	bx	lr
 80044d6:	bf00      	nop
 80044d8:	200036cc 	.word	0x200036cc
 80044dc:	f3af 8000 	nop.w

080044e0 <chVTDoSetI.4252>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 80044e0:	b500      	push	{lr}
 80044e2:	b089      	sub	sp, #36	; 0x24
 80044e4:	9003      	str	r0, [sp, #12]
 80044e6:	9102      	str	r1, [sp, #8]
 80044e8:	9201      	str	r2, [sp, #4]
 80044ea:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 80044ec:	f7ff ff20 	bl	8004330 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 80044f0:	9b03      	ldr	r3, [sp, #12]
 80044f2:	2b00      	cmp	r3, #0
 80044f4:	d005      	beq.n	8004502 <chVTDoSetI.4252+0x22>
 80044f6:	9b01      	ldr	r3, [sp, #4]
 80044f8:	2b00      	cmp	r3, #0
 80044fa:	d002      	beq.n	8004502 <chVTDoSetI.4252+0x22>
 80044fc:	9b02      	ldr	r3, [sp, #8]
 80044fe:	2b00      	cmp	r3, #0
 8004500:	d105      	bne.n	800450e <chVTDoSetI.4252+0x2e>
 8004502:	f245 50f0 	movw	r0, #22000	; 0x55f0
 8004506:	f6c0 0000 	movt	r0, #2048	; 0x800
 800450a:	f7ff fdc9 	bl	80040a0 <chSysHalt>

  vtp->vt_par = par;
 800450e:	9b03      	ldr	r3, [sp, #12]
 8004510:	9a00      	ldr	r2, [sp, #0]
 8004512:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 8004514:	9b03      	ldr	r3, [sp, #12]
 8004516:	9a01      	ldr	r2, [sp, #4]
 8004518:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 800451a:	f7ff ffb9 	bl	8004490 <chVTGetSystemTimeX.4753.4260>
 800451e:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8004520:	9b02      	ldr	r3, [sp, #8]
 8004522:	2b01      	cmp	r3, #1
 8004524:	d802      	bhi.n	800452c <chVTDoSetI.4252+0x4c>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8004526:	f04f 0302 	mov.w	r3, #2
 800452a:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800452c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004530:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004534:	69da      	ldr	r2, [r3, #28]
 8004536:	4b3d      	ldr	r3, [pc, #244]	; (800462c <chVTDoSetI.4252+0x14c>)
 8004538:	429a      	cmp	r2, r3
 800453a:	d125      	bne.n	8004588 <chVTDoSetI.4252+0xa8>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 800453c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004540:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004544:	9a05      	ldr	r2, [sp, #20]
 8004546:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
 8004548:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800454c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004550:	9a03      	ldr	r2, [sp, #12]
 8004552:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
 8004554:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004558:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800455c:	9a03      	ldr	r2, [sp, #12]
 800455e:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8004560:	9b03      	ldr	r3, [sp, #12]
 8004562:	4a32      	ldr	r2, [pc, #200]	; (800462c <chVTDoSetI.4252+0x14c>)
 8004564:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8004566:	9b03      	ldr	r3, [sp, #12]
 8004568:	4a30      	ldr	r2, [pc, #192]	; (800462c <chVTDoSetI.4252+0x14c>)
 800456a:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
 800456c:	9b03      	ldr	r3, [sp, #12]
 800456e:	9a02      	ldr	r2, [sp, #8]
 8004570:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8004572:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004576:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800457a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800457c:	9b02      	ldr	r3, [sp, #8]
 800457e:	18d3      	adds	r3, r2, r3
 8004580:	4618      	mov	r0, r3
 8004582:	f7ff ff65 	bl	8004450 <port_timer_start_alarm.4760.4269>
 8004586:	e04f      	b.n	8004628 <chVTDoSetI.4252+0x148>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8004588:	9a05      	ldr	r2, [sp, #20]
 800458a:	9b02      	ldr	r3, [sp, #8]
 800458c:	18d2      	adds	r2, r2, r3
 800458e:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004592:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004596:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004598:	1ad3      	subs	r3, r2, r3
 800459a:	9306      	str	r3, [sp, #24]
    if (delta < ch.vtlist.vt_next->vt_delta) {
 800459c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80045a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045a4:	69db      	ldr	r3, [r3, #28]
 80045a6:	689a      	ldr	r2, [r3, #8]
 80045a8:	9b06      	ldr	r3, [sp, #24]
 80045aa:	429a      	cmp	r2, r3
 80045ac:	d909      	bls.n	80045c2 <chVTDoSetI.4252+0xe2>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 80045ae:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80045b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045b6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80045b8:	9b06      	ldr	r3, [sp, #24]
 80045ba:	18d3      	adds	r3, r2, r3
 80045bc:	4618      	mov	r0, r3
 80045be:	f7ff ff57 	bl	8004470 <port_timer_set_alarm.4757.4264>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 80045c2:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80045c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045ca:	69db      	ldr	r3, [r3, #28]
 80045cc:	9307      	str	r3, [sp, #28]
 80045ce:	e007      	b.n	80045e0 <chVTDoSetI.4252+0x100>
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 80045d0:	9b07      	ldr	r3, [sp, #28]
 80045d2:	689b      	ldr	r3, [r3, #8]
 80045d4:	9a06      	ldr	r2, [sp, #24]
 80045d6:	1ad3      	subs	r3, r2, r3
 80045d8:	9306      	str	r3, [sp, #24]
    p = p->vt_next;
 80045da:	9b07      	ldr	r3, [sp, #28]
 80045dc:	681b      	ldr	r3, [r3, #0]
 80045de:	9307      	str	r3, [sp, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 80045e0:	9b07      	ldr	r3, [sp, #28]
 80045e2:	689a      	ldr	r2, [r3, #8]
 80045e4:	9b06      	ldr	r3, [sp, #24]
 80045e6:	429a      	cmp	r2, r3
 80045e8:	d3f2      	bcc.n	80045d0 <chVTDoSetI.4252+0xf0>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80045ea:	9b03      	ldr	r3, [sp, #12]
 80045ec:	9a07      	ldr	r2, [sp, #28]
 80045ee:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80045f0:	9b03      	ldr	r3, [sp, #12]
 80045f2:	681b      	ldr	r3, [r3, #0]
 80045f4:	685a      	ldr	r2, [r3, #4]
 80045f6:	9b03      	ldr	r3, [sp, #12]
 80045f8:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 80045fa:	9b03      	ldr	r3, [sp, #12]
 80045fc:	685b      	ldr	r3, [r3, #4]
 80045fe:	9a03      	ldr	r2, [sp, #12]
 8004600:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 8004602:	9b07      	ldr	r3, [sp, #28]
 8004604:	9a03      	ldr	r2, [sp, #12]
 8004606:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 8004608:	9b03      	ldr	r3, [sp, #12]
 800460a:	9a06      	ldr	r2, [sp, #24]
 800460c:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800460e:	9b07      	ldr	r3, [sp, #28]
 8004610:	689a      	ldr	r2, [r3, #8]
 8004612:	9b06      	ldr	r3, [sp, #24]
 8004614:	1ad2      	subs	r2, r2, r3
 8004616:	9b07      	ldr	r3, [sp, #28]
 8004618:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800461a:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800461e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004622:	f04f 32ff 	mov.w	r2, #4294967295
 8004626:	625a      	str	r2, [r3, #36]	; 0x24
}
 8004628:	b009      	add	sp, #36	; 0x24
 800462a:	bd00      	pop	{pc}
 800462c:	200036cc 	.word	0x200036cc

08004630 <chVTDoResetI.4248>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8004630:	b500      	push	{lr}
 8004632:	b085      	sub	sp, #20
 8004634:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8004636:	f7ff fe7b 	bl	8004330 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 800463a:	9b01      	ldr	r3, [sp, #4]
 800463c:	2b00      	cmp	r3, #0
 800463e:	d105      	bne.n	800464c <chVTDoResetI.4248+0x1c>
 8004640:	f245 50e0 	movw	r0, #21984	; 0x55e0
 8004644:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004648:	f7ff fd2a 	bl	80040a0 <chSysHalt>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
 800464c:	9b01      	ldr	r3, [sp, #4]
 800464e:	68db      	ldr	r3, [r3, #12]
 8004650:	2b00      	cmp	r3, #0
 8004652:	d105      	bne.n	8004660 <chVTDoResetI.4248+0x30>
 8004654:	f245 50e0 	movw	r0, #21984	; 0x55e0
 8004658:	f6c0 0000 	movt	r0, #2048	; 0x800
 800465c:	f7ff fd20 	bl	80040a0 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8004660:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004664:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004668:	69da      	ldr	r2, [r3, #28]
 800466a:	9b01      	ldr	r3, [sp, #4]
 800466c:	429a      	cmp	r2, r3
 800466e:	d01c      	beq.n	80046aa <chVTDoResetI.4248+0x7a>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8004670:	9b01      	ldr	r3, [sp, #4]
 8004672:	685b      	ldr	r3, [r3, #4]
 8004674:	9a01      	ldr	r2, [sp, #4]
 8004676:	6812      	ldr	r2, [r2, #0]
 8004678:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 800467a:	9b01      	ldr	r3, [sp, #4]
 800467c:	681b      	ldr	r3, [r3, #0]
 800467e:	9a01      	ldr	r2, [sp, #4]
 8004680:	6852      	ldr	r2, [r2, #4]
 8004682:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 8004684:	9b01      	ldr	r3, [sp, #4]
 8004686:	f04f 0200 	mov.w	r2, #0
 800468a:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800468c:	9b01      	ldr	r3, [sp, #4]
 800468e:	681a      	ldr	r2, [r3, #0]
 8004690:	4b34      	ldr	r3, [pc, #208]	; (8004764 <chVTDoResetI.4248+0x134>)
 8004692:	429a      	cmp	r2, r3
 8004694:	d063      	beq.n	800475e <chVTDoResetI.4248+0x12e>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8004696:	9b01      	ldr	r3, [sp, #4]
 8004698:	681b      	ldr	r3, [r3, #0]
 800469a:	9a01      	ldr	r2, [sp, #4]
 800469c:	6812      	ldr	r2, [r2, #0]
 800469e:	6891      	ldr	r1, [r2, #8]
 80046a0:	9a01      	ldr	r2, [sp, #4]
 80046a2:	6892      	ldr	r2, [r2, #8]
 80046a4:	188a      	adds	r2, r1, r2
 80046a6:	609a      	str	r2, [r3, #8]
 80046a8:	e059      	b.n	800475e <chVTDoResetI.4248+0x12e>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80046aa:	9b01      	ldr	r3, [sp, #4]
 80046ac:	681a      	ldr	r2, [r3, #0]
 80046ae:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80046b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046b6:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80046b8:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80046bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046c0:	69db      	ldr	r3, [r3, #28]
 80046c2:	4a28      	ldr	r2, [pc, #160]	; (8004764 <chVTDoResetI.4248+0x134>)
 80046c4:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 80046c6:	9b01      	ldr	r3, [sp, #4]
 80046c8:	f04f 0200 	mov.w	r2, #0
 80046cc:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80046ce:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80046d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046d6:	69da      	ldr	r2, [r3, #28]
 80046d8:	4b22      	ldr	r3, [pc, #136]	; (8004764 <chVTDoResetI.4248+0x134>)
 80046da:	429a      	cmp	r2, r3
 80046dc:	d102      	bne.n	80046e4 <chVTDoResetI.4248+0xb4>
    port_timer_stop_alarm();
 80046de:	f7ff febf 	bl	8004460 <port_timer_stop_alarm.4755.4267>
 80046e2:	e03c      	b.n	800475e <chVTDoResetI.4248+0x12e>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80046e4:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80046e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046ec:	69da      	ldr	r2, [r3, #28]
 80046ee:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80046f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80046f6:	69db      	ldr	r3, [r3, #28]
 80046f8:	6899      	ldr	r1, [r3, #8]
 80046fa:	9b01      	ldr	r3, [sp, #4]
 80046fc:	689b      	ldr	r3, [r3, #8]
 80046fe:	18cb      	adds	r3, r1, r3
 8004700:	6093      	str	r3, [r2, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8004702:	f7ff fec5 	bl	8004490 <chVTGetSystemTimeX.4753.4260>
 8004706:	4602      	mov	r2, r0
 8004708:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800470c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004710:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004712:	1ad3      	subs	r3, r2, r3
 8004714:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8004716:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800471a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800471e:	69db      	ldr	r3, [r3, #28]
 8004720:	689a      	ldr	r2, [r3, #8]
 8004722:	9b02      	ldr	r3, [sp, #8]
 8004724:	429a      	cmp	r2, r3
 8004726:	d91a      	bls.n	800475e <chVTDoResetI.4248+0x12e>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 8004728:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800472c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004730:	69db      	ldr	r3, [r3, #28]
 8004732:	689a      	ldr	r2, [r3, #8]
 8004734:	9b02      	ldr	r3, [sp, #8]
 8004736:	1ad3      	subs	r3, r2, r3
 8004738:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800473a:	9b03      	ldr	r3, [sp, #12]
 800473c:	2b01      	cmp	r3, #1
 800473e:	d802      	bhi.n	8004746 <chVTDoResetI.4248+0x116>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8004740:	f04f 0302 	mov.w	r3, #2
 8004744:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8004746:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800474a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800474e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8004750:	9b02      	ldr	r3, [sp, #8]
 8004752:	18d2      	adds	r2, r2, r3
 8004754:	9b03      	ldr	r3, [sp, #12]
 8004756:	18d3      	adds	r3, r2, r3
 8004758:	4618      	mov	r0, r3
 800475a:	f7ff fe89 	bl	8004470 <port_timer_set_alarm.4757.4264>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800475e:	b005      	add	sp, #20
 8004760:	bd00      	pop	{pc}
 8004762:	bf00      	nop
 8004764:	200036cc 	.word	0x200036cc
 8004768:	f3af 8000 	nop.w
 800476c:	f3af 8000 	nop.w

08004770 <port_lock.4947.4246>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004770:	b082      	sub	sp, #8
 8004772:	f04f 0320 	mov.w	r3, #32
 8004776:	9301      	str	r3, [sp, #4]
 8004778:	9b01      	ldr	r3, [sp, #4]
 800477a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800477e:	b002      	add	sp, #8
 8004780:	4770      	bx	lr
 8004782:	bf00      	nop
 8004784:	f3af 8000 	nop.w
 8004788:	f3af 8000 	nop.w
 800478c:	f3af 8000 	nop.w

08004790 <port_unlock.4950.4244>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004790:	b082      	sub	sp, #8
 8004792:	f04f 0300 	mov.w	r3, #0
 8004796:	9301      	str	r3, [sp, #4]
 8004798:	9b01      	ldr	r3, [sp, #4]
 800479a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800479e:	b002      	add	sp, #8
 80047a0:	4770      	bx	lr
 80047a2:	bf00      	nop
 80047a4:	f3af 8000 	nop.w
 80047a8:	f3af 8000 	nop.w
 80047ac:	f3af 8000 	nop.w

080047b0 <port_lock_from_isr.4952.4242>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80047b0:	b508      	push	{r3, lr}

  port_lock();
 80047b2:	f7ff ffdd 	bl	8004770 <port_lock.4947.4246>
}
 80047b6:	bd08      	pop	{r3, pc}
 80047b8:	f3af 8000 	nop.w
 80047bc:	f3af 8000 	nop.w

080047c0 <port_unlock_from_isr.4954.4240>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80047c0:	b508      	push	{r3, lr}

  port_unlock();
 80047c2:	f7ff ffe5 	bl	8004790 <port_unlock.4950.4244>
}
 80047c6:	bd08      	pop	{r3, pc}
 80047c8:	f3af 8000 	nop.w
 80047cc:	f3af 8000 	nop.w

080047d0 <queue_init.4956.4237>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80047d0:	b082      	sub	sp, #8
 80047d2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80047d4:	9b01      	ldr	r3, [sp, #4]
 80047d6:	9a01      	ldr	r2, [sp, #4]
 80047d8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80047da:	9b01      	ldr	r3, [sp, #4]
 80047dc:	9a01      	ldr	r2, [sp, #4]
 80047de:	605a      	str	r2, [r3, #4]
}
 80047e0:	b002      	add	sp, #8
 80047e2:	4770      	bx	lr
 80047e4:	f3af 8000 	nop.w
 80047e8:	f3af 8000 	nop.w
 80047ec:	f3af 8000 	nop.w

080047f0 <queue_fifo_remove.5041.4234>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80047f0:	b084      	sub	sp, #16
 80047f2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 80047f4:	9b01      	ldr	r3, [sp, #4]
 80047f6:	681b      	ldr	r3, [r3, #0]
 80047f8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 80047fa:	9b03      	ldr	r3, [sp, #12]
 80047fc:	681a      	ldr	r2, [r3, #0]
 80047fe:	9b01      	ldr	r3, [sp, #4]
 8004800:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8004802:	9b01      	ldr	r3, [sp, #4]
 8004804:	681b      	ldr	r3, [r3, #0]
 8004806:	9a01      	ldr	r2, [sp, #4]
 8004808:	605a      	str	r2, [r3, #4]

  return tp;
 800480a:	9b03      	ldr	r3, [sp, #12]
}
 800480c:	4618      	mov	r0, r3
 800480e:	b004      	add	sp, #16
 8004810:	4770      	bx	lr
 8004812:	bf00      	nop
 8004814:	f3af 8000 	nop.w
 8004818:	f3af 8000 	nop.w
 800481c:	f3af 8000 	nop.w

08004820 <queue_dequeue.5044.4231>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8004820:	b082      	sub	sp, #8
 8004822:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8004824:	9b01      	ldr	r3, [sp, #4]
 8004826:	685b      	ldr	r3, [r3, #4]
 8004828:	9a01      	ldr	r2, [sp, #4]
 800482a:	6812      	ldr	r2, [r2, #0]
 800482c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800482e:	9b01      	ldr	r3, [sp, #4]
 8004830:	681b      	ldr	r3, [r3, #0]
 8004832:	9a01      	ldr	r2, [sp, #4]
 8004834:	6852      	ldr	r2, [r2, #4]
 8004836:	605a      	str	r2, [r3, #4]

  return tp;
 8004838:	9b01      	ldr	r3, [sp, #4]
}
 800483a:	4618      	mov	r0, r3
 800483c:	b002      	add	sp, #8
 800483e:	4770      	bx	lr

08004840 <chSysLockFromISR.5066.4229>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8004840:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8004842:	f7ff ffb5 	bl	80047b0 <port_lock_from_isr.4952.4242>
  _stats_start_measure_crit_isr();
 8004846:	f7fe fa6b 	bl	8002d20 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800484a:	f7ff fce1 	bl	8004210 <_dbg_check_lock_from_isr>
}
 800484e:	bd08      	pop	{r3, pc}

08004850 <chSysUnlockFromISR.5068.4227>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8004850:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8004852:	f7ff fcfd 	bl	8004250 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8004856:	f7fe fa6b 	bl	8002d30 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800485a:	f7ff ffb1 	bl	80047c0 <port_unlock_from_isr.4954.4240>
}
 800485e:	bd08      	pop	{r3, pc}

08004860 <chVTIsArmedI.5050.4216>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8004860:	b500      	push	{lr}
 8004862:	b083      	sub	sp, #12
 8004864:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8004866:	f7ff fd63 	bl	8004330 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
 800486a:	9b01      	ldr	r3, [sp, #4]
 800486c:	68db      	ldr	r3, [r3, #12]
 800486e:	2b00      	cmp	r3, #0
 8004870:	bf0c      	ite	eq
 8004872:	2300      	moveq	r3, #0
 8004874:	2301      	movne	r3, #1
 8004876:	b2db      	uxtb	r3, r3
}
 8004878:	4618      	mov	r0, r3
 800487a:	b003      	add	sp, #12
 800487c:	bd00      	pop	{pc}
 800487e:	bf00      	nop

08004880 <chSemFastSignalI.5062.4211>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8004880:	b500      	push	{lr}
 8004882:	b083      	sub	sp, #12
 8004884:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8004886:	f7ff fd53 	bl	8004330 <chDbgCheckClassI>

  sp->s_cnt++;
 800488a:	9b01      	ldr	r3, [sp, #4]
 800488c:	689b      	ldr	r3, [r3, #8]
 800488e:	f103 0201 	add.w	r2, r3, #1
 8004892:	9b01      	ldr	r3, [sp, #4]
 8004894:	609a      	str	r2, [r3, #8]
}
 8004896:	b003      	add	sp, #12
 8004898:	bd00      	pop	{pc}
 800489a:	bf00      	nop
 800489c:	f3af 8000 	nop.w

080048a0 <_scheduler_init.4209>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 80048a0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 80048a2:	f243 60b0 	movw	r0, #14000	; 0x36b0
 80048a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80048aa:	f7ff ff91 	bl	80047d0 <queue_init.4956.4237>
  ch.rlist.r_prio = NOPRIO;
 80048ae:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80048b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048b6:	f04f 0200 	mov.w	r2, #0
 80048ba:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 80048bc:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80048c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048c4:	f243 62b0 	movw	r2, #14000	; 0x36b0
 80048c8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80048cc:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 80048ce:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80048d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80048d6:	f243 62b0 	movw	r2, #14000	; 0x36b0
 80048da:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80048de:	615a      	str	r2, [r3, #20]
#endif
}
 80048e0:	bd08      	pop	{r3, pc}
 80048e2:	bf00      	nop
 80048e4:	f3af 8000 	nop.w
 80048e8:	f3af 8000 	nop.w
 80048ec:	f3af 8000 	nop.w

080048f0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80048f0:	b500      	push	{lr}
 80048f2:	b085      	sub	sp, #20
 80048f4:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 80048f6:	f7ff fd1b 	bl	8004330 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 80048fa:	9b01      	ldr	r3, [sp, #4]
 80048fc:	2b00      	cmp	r3, #0
 80048fe:	d105      	bne.n	800490c <chSchReadyI+0x1c>
 8004900:	f245 6000 	movw	r0, #22016	; 0x5600
 8004904:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004908:	f7ff fbca 	bl	80040a0 <chSysHalt>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 800490c:	9b01      	ldr	r3, [sp, #4]
 800490e:	f893 3020 	ldrb.w	r3, [r3, #32]
 8004912:	2b00      	cmp	r3, #0
 8004914:	d004      	beq.n	8004920 <chSchReadyI+0x30>
 8004916:	9b01      	ldr	r3, [sp, #4]
 8004918:	f893 3020 	ldrb.w	r3, [r3, #32]
 800491c:	2b0f      	cmp	r3, #15
 800491e:	d105      	bne.n	800492c <chSchReadyI+0x3c>
 8004920:	f245 6000 	movw	r0, #22016	; 0x5600
 8004924:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004928:	f7ff fbba 	bl	80040a0 <chSysHalt>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800492c:	9b01      	ldr	r3, [sp, #4]
 800492e:	f04f 0200 	mov.w	r2, #0
 8004932:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 8004936:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800493a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800493e:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8004940:	9b03      	ldr	r3, [sp, #12]
 8004942:	681b      	ldr	r3, [r3, #0]
 8004944:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8004946:	9b03      	ldr	r3, [sp, #12]
 8004948:	689a      	ldr	r2, [r3, #8]
 800494a:	9b01      	ldr	r3, [sp, #4]
 800494c:	689b      	ldr	r3, [r3, #8]
 800494e:	429a      	cmp	r2, r3
 8004950:	d2f6      	bcs.n	8004940 <chSchReadyI+0x50>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8004952:	9b01      	ldr	r3, [sp, #4]
 8004954:	9a03      	ldr	r2, [sp, #12]
 8004956:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8004958:	9b03      	ldr	r3, [sp, #12]
 800495a:	685a      	ldr	r2, [r3, #4]
 800495c:	9b01      	ldr	r3, [sp, #4]
 800495e:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8004960:	9b01      	ldr	r3, [sp, #4]
 8004962:	685b      	ldr	r3, [r3, #4]
 8004964:	9a01      	ldr	r2, [sp, #4]
 8004966:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8004968:	9b03      	ldr	r3, [sp, #12]
 800496a:	9a01      	ldr	r2, [sp, #4]
 800496c:	605a      	str	r2, [r3, #4]

  return tp;
 800496e:	9b01      	ldr	r3, [sp, #4]
}
 8004970:	4618      	mov	r0, r3
 8004972:	b005      	add	sp, #20
 8004974:	bd00      	pop	{pc}
 8004976:	bf00      	nop
 8004978:	f3af 8000 	nop.w
 800497c:	f3af 8000 	nop.w

08004980 <chSchGoSleepS.4203>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8004980:	b510      	push	{r4, lr}
 8004982:	b084      	sub	sp, #16
 8004984:	4603      	mov	r3, r0
 8004986:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();
 800498a:	f7ff fce9 	bl	8004360 <chDbgCheckClassS.4280>

  otp = currp;
 800498e:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004992:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004996:	699b      	ldr	r3, [r3, #24]
 8004998:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 800499a:	9b03      	ldr	r3, [sp, #12]
 800499c:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80049a0:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80049a4:	f243 60b0 	movw	r0, #14000	; 0x36b0
 80049a8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80049ac:	f7ff ff20 	bl	80047f0 <queue_fifo_remove.5041.4234>
 80049b0:	4602      	mov	r2, r0
 80049b2:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80049b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049ba:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80049bc:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80049c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049c4:	699b      	ldr	r3, [r3, #24]
 80049c6:	f04f 0201 	mov.w	r2, #1
 80049ca:	f883 2020 	strb.w	r2, [r3, #32]
  chSysSwitch(currp, otp);
 80049ce:	9803      	ldr	r0, [sp, #12]
 80049d0:	f7ff fcee 	bl	80043b0 <_dbg_trace.4274>
 80049d4:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80049d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80049dc:	699b      	ldr	r3, [r3, #24]
 80049de:	4618      	mov	r0, r3
 80049e0:	9903      	ldr	r1, [sp, #12]
 80049e2:	f7fe f96d 	bl	8002cc0 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80049e6:	f3ef 8409 	mrs	r4, PSP
  return(result);
 80049ea:	4623      	mov	r3, r4
 80049ec:	9302      	str	r3, [sp, #8]
 80049ee:	9b02      	ldr	r3, [sp, #8]
 80049f0:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 80049f4:	9b03      	ldr	r3, [sp, #12]
 80049f6:	69db      	ldr	r3, [r3, #28]
 80049f8:	429a      	cmp	r2, r3
 80049fa:	d205      	bcs.n	8004a08 <chSchGoSleepS.4203+0x88>
 80049fc:	f245 50c0 	movw	r0, #21952	; 0x55c0
 8004a00:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004a04:	f7ff fb4c 	bl	80040a0 <chSysHalt>
 8004a08:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004a0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004a10:	699b      	ldr	r3, [r3, #24]
 8004a12:	4618      	mov	r0, r3
 8004a14:	9903      	ldr	r1, [sp, #12]
 8004a16:	f7fb fc3b 	bl	8000290 <_port_switch>
}
 8004a1a:	b004      	add	sp, #16
 8004a1c:	bd10      	pop	{r4, pc}
 8004a1e:	bf00      	nop

08004a20 <wakeup.5075.4200>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8004a20:	b500      	push	{lr}
 8004a22:	b085      	sub	sp, #20
 8004a24:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8004a26:	9b01      	ldr	r3, [sp, #4]
 8004a28:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8004a2a:	f7ff ff09 	bl	8004840 <chSysLockFromISR.5066.4229>
  switch (tp->p_state) {
 8004a2e:	9b03      	ldr	r3, [sp, #12]
 8004a30:	f893 3020 	ldrb.w	r3, [r3, #32]
 8004a34:	2b07      	cmp	r3, #7
 8004a36:	d824      	bhi.n	8004a82 <wakeup.5075.4200+0x62>
 8004a38:	a201      	add	r2, pc, #4	; (adr r2, 8004a40 <wakeup.5075.4200+0x20>)
 8004a3a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004a3e:	bf00      	nop
 8004a40:	08004a61 	.word	0x08004a61
 8004a44:	08004a83 	.word	0x08004a83
 8004a48:	08004a83 	.word	0x08004a83
 8004a4c:	08004a67 	.word	0x08004a67
 8004a50:	08004a7d 	.word	0x08004a7d
 8004a54:	08004a73 	.word	0x08004a73
 8004a58:	08004a83 	.word	0x08004a83
 8004a5c:	08004a7d 	.word	0x08004a7d
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8004a60:	f7ff fef6 	bl	8004850 <chSysUnlockFromISR.5068.4227>
 8004a64:	e016      	b.n	8004a94 <wakeup.5075.4200+0x74>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8004a66:	9b03      	ldr	r3, [sp, #12]
 8004a68:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004a6a:	f04f 0200 	mov.w	r2, #0
 8004a6e:	601a      	str	r2, [r3, #0]
 8004a70:	e007      	b.n	8004a82 <wakeup.5075.4200+0x62>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8004a72:	9b03      	ldr	r3, [sp, #12]
 8004a74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004a76:	4618      	mov	r0, r3
 8004a78:	f7ff ff02 	bl	8004880 <chSemFastSignalI.5062.4211>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8004a7c:	9803      	ldr	r0, [sp, #12]
 8004a7e:	f7ff fecf 	bl	8004820 <queue_dequeue.5044.4231>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8004a82:	9b03      	ldr	r3, [sp, #12]
 8004a84:	f04f 32ff 	mov.w	r2, #4294967295
 8004a88:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8004a8a:	9803      	ldr	r0, [sp, #12]
 8004a8c:	f7ff ff30 	bl	80048f0 <chSchReadyI>
  chSysUnlockFromISR();
 8004a90:	f7ff fede 	bl	8004850 <chSysUnlockFromISR.5068.4227>
}
 8004a94:	b005      	add	sp, #20
 8004a96:	bd00      	pop	{pc}
 8004a98:	f3af 8000 	nop.w
 8004a9c:	f3af 8000 	nop.w

08004aa0 <chSchGoSleepTimeoutS.4196>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8004aa0:	b500      	push	{lr}
 8004aa2:	b089      	sub	sp, #36	; 0x24
 8004aa4:	4603      	mov	r3, r0
 8004aa6:	9100      	str	r1, [sp, #0]
 8004aa8:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
 8004aac:	f7ff fc58 	bl	8004360 <chDbgCheckClassS.4280>

  if (TIME_INFINITE != time) {
 8004ab0:	9b00      	ldr	r3, [sp, #0]
 8004ab2:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004ab6:	d01e      	beq.n	8004af6 <chSchGoSleepTimeoutS.4196+0x56>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8004ab8:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004abc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ac0:	699b      	ldr	r3, [r3, #24]
 8004ac2:	aa03      	add	r2, sp, #12
 8004ac4:	4610      	mov	r0, r2
 8004ac6:	9900      	ldr	r1, [sp, #0]
 8004ac8:	f644 2221 	movw	r2, #18977	; 0x4a21
 8004acc:	f6c0 0200 	movt	r2, #2048	; 0x800
 8004ad0:	f7ff fd06 	bl	80044e0 <chVTDoSetI.4252>
    chSchGoSleepS(newstate);
 8004ad4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004ad8:	4618      	mov	r0, r3
 8004ada:	f7ff ff51 	bl	8004980 <chSchGoSleepS.4203>
    if (chVTIsArmedI(&vt)) {
 8004ade:	ab03      	add	r3, sp, #12
 8004ae0:	4618      	mov	r0, r3
 8004ae2:	f7ff febd 	bl	8004860 <chVTIsArmedI.5050.4216>
 8004ae6:	4603      	mov	r3, r0
 8004ae8:	2b00      	cmp	r3, #0
 8004aea:	d009      	beq.n	8004b00 <chSchGoSleepTimeoutS.4196+0x60>
      chVTDoResetI(&vt);
 8004aec:	ab03      	add	r3, sp, #12
 8004aee:	4618      	mov	r0, r3
 8004af0:	f7ff fd9e 	bl	8004630 <chVTDoResetI.4248>
 8004af4:	e004      	b.n	8004b00 <chSchGoSleepTimeoutS.4196+0x60>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8004af6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8004afa:	4618      	mov	r0, r3
 8004afc:	f7ff ff40 	bl	8004980 <chSchGoSleepS.4203>
  }

  return currp->p_u.rdymsg;
 8004b00:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004b04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b08:	699b      	ldr	r3, [r3, #24]
 8004b0a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8004b0c:	4618      	mov	r0, r3
 8004b0e:	b009      	add	sp, #36	; 0x24
 8004b10:	bd00      	pop	{pc}
 8004b12:	bf00      	nop
 8004b14:	f3af 8000 	nop.w
 8004b18:	f3af 8000 	nop.w
 8004b1c:	f3af 8000 	nop.w

08004b20 <chSchWakeupS.4192>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8004b20:	b510      	push	{r4, lr}
 8004b22:	b084      	sub	sp, #16
 8004b24:	9001      	str	r0, [sp, #4]
 8004b26:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
 8004b28:	f7ff fc1a 	bl	8004360 <chDbgCheckClassS.4280>

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8004b2c:	9b01      	ldr	r3, [sp, #4]
 8004b2e:	9a00      	ldr	r2, [sp, #0]
 8004b30:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8004b32:	9b01      	ldr	r3, [sp, #4]
 8004b34:	689a      	ldr	r2, [r3, #8]
 8004b36:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004b3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b3e:	699b      	ldr	r3, [r3, #24]
 8004b40:	689b      	ldr	r3, [r3, #8]
 8004b42:	429a      	cmp	r2, r3
 8004b44:	d803      	bhi.n	8004b4e <chSchWakeupS.4192+0x2e>
    (void) chSchReadyI(ntp);
 8004b46:	9801      	ldr	r0, [sp, #4]
 8004b48:	f7ff fed2 	bl	80048f0 <chSchReadyI>
 8004b4c:	e02f      	b.n	8004bae <chSchWakeupS.4192+0x8e>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8004b4e:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004b52:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b56:	699b      	ldr	r3, [r3, #24]
 8004b58:	4618      	mov	r0, r3
 8004b5a:	f7ff fec9 	bl	80048f0 <chSchReadyI>
 8004b5e:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 8004b60:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004b64:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b68:	9a01      	ldr	r2, [sp, #4]
 8004b6a:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8004b6c:	9b01      	ldr	r3, [sp, #4]
 8004b6e:	f04f 0201 	mov.w	r2, #1
 8004b72:	f883 2020 	strb.w	r2, [r3, #32]
    chSysSwitch(ntp, otp);
 8004b76:	9803      	ldr	r0, [sp, #12]
 8004b78:	f7ff fc1a 	bl	80043b0 <_dbg_trace.4274>
 8004b7c:	9801      	ldr	r0, [sp, #4]
 8004b7e:	9903      	ldr	r1, [sp, #12]
 8004b80:	f7fe f89e 	bl	8002cc0 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8004b84:	f3ef 8409 	mrs	r4, PSP
  return(result);
 8004b88:	4623      	mov	r3, r4
 8004b8a:	9302      	str	r3, [sp, #8]
 8004b8c:	9b02      	ldr	r3, [sp, #8]
 8004b8e:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8004b92:	9b03      	ldr	r3, [sp, #12]
 8004b94:	69db      	ldr	r3, [r3, #28]
 8004b96:	429a      	cmp	r2, r3
 8004b98:	d205      	bcs.n	8004ba6 <chSchWakeupS.4192+0x86>
 8004b9a:	f245 50c0 	movw	r0, #21952	; 0x55c0
 8004b9e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004ba2:	f7ff fa7d 	bl	80040a0 <chSysHalt>
 8004ba6:	9801      	ldr	r0, [sp, #4]
 8004ba8:	9903      	ldr	r1, [sp, #12]
 8004baa:	f7fb fb71 	bl	8000290 <_port_switch>
  }
}
 8004bae:	b004      	add	sp, #16
 8004bb0:	bd10      	pop	{r4, pc}
 8004bb2:	bf00      	nop
 8004bb4:	f3af 8000 	nop.w
 8004bb8:	f3af 8000 	nop.w
 8004bbc:	f3af 8000 	nop.w

08004bc0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8004bc0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8004bc2:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004bc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004bca:	681b      	ldr	r3, [r3, #0]
 8004bcc:	689b      	ldr	r3, [r3, #8]
 8004bce:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 8004bd0:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004bd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004bd8:	699b      	ldr	r3, [r3, #24]
 8004bda:	689b      	ldr	r3, [r3, #8]
 8004bdc:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8004bde:	9a01      	ldr	r2, [sp, #4]
 8004be0:	9b00      	ldr	r3, [sp, #0]
 8004be2:	429a      	cmp	r2, r3
 8004be4:	bf94      	ite	ls
 8004be6:	2300      	movls	r3, #0
 8004be8:	2301      	movhi	r3, #1
 8004bea:	b2db      	uxtb	r3, r3
#endif
}
 8004bec:	4618      	mov	r0, r3
 8004bee:	b002      	add	sp, #8
 8004bf0:	4770      	bx	lr
 8004bf2:	bf00      	nop
 8004bf4:	f3af 8000 	nop.w
 8004bf8:	f3af 8000 	nop.w
 8004bfc:	f3af 8000 	nop.w

08004c00 <chSchDoRescheduleAhead.4188>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8004c00:	b510      	push	{r4, lr}
 8004c02:	b084      	sub	sp, #16
  thread_t *otp, *cp;

  otp = currp;
 8004c04:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004c08:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c0c:	699b      	ldr	r3, [r3, #24]
 8004c0e:	9302      	str	r3, [sp, #8]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8004c10:	f243 60b0 	movw	r0, #14000	; 0x36b0
 8004c14:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004c18:	f7ff fdea 	bl	80047f0 <queue_fifo_remove.5041.4234>
 8004c1c:	4602      	mov	r2, r0
 8004c1e:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004c22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c26:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8004c28:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004c2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c30:	699b      	ldr	r3, [r3, #24]
 8004c32:	f04f 0201 	mov.w	r2, #1
 8004c36:	f883 2020 	strb.w	r2, [r3, #32]

  otp->p_state = CH_STATE_READY;
 8004c3a:	9b02      	ldr	r3, [sp, #8]
 8004c3c:	f04f 0200 	mov.w	r2, #0
 8004c40:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 8004c44:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004c48:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c4c:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8004c4e:	9b03      	ldr	r3, [sp, #12]
 8004c50:	681b      	ldr	r3, [r3, #0]
 8004c52:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio > otp->p_prio);
 8004c54:	9b03      	ldr	r3, [sp, #12]
 8004c56:	689a      	ldr	r2, [r3, #8]
 8004c58:	9b02      	ldr	r3, [sp, #8]
 8004c5a:	689b      	ldr	r3, [r3, #8]
 8004c5c:	429a      	cmp	r2, r3
 8004c5e:	d8f6      	bhi.n	8004c4e <chSchDoRescheduleAhead.4188+0x4e>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8004c60:	9b02      	ldr	r3, [sp, #8]
 8004c62:	9a03      	ldr	r2, [sp, #12]
 8004c64:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8004c66:	9b03      	ldr	r3, [sp, #12]
 8004c68:	685a      	ldr	r2, [r3, #4]
 8004c6a:	9b02      	ldr	r3, [sp, #8]
 8004c6c:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 8004c6e:	9b02      	ldr	r3, [sp, #8]
 8004c70:	685b      	ldr	r3, [r3, #4]
 8004c72:	9a02      	ldr	r2, [sp, #8]
 8004c74:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 8004c76:	9b03      	ldr	r3, [sp, #12]
 8004c78:	9a02      	ldr	r2, [sp, #8]
 8004c7a:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 8004c7c:	9802      	ldr	r0, [sp, #8]
 8004c7e:	f7ff fb97 	bl	80043b0 <_dbg_trace.4274>
 8004c82:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004c86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c8a:	699b      	ldr	r3, [r3, #24]
 8004c8c:	4618      	mov	r0, r3
 8004c8e:	9902      	ldr	r1, [sp, #8]
 8004c90:	f7fe f816 	bl	8002cc0 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8004c94:	f3ef 8409 	mrs	r4, PSP
  return(result);
 8004c98:	4623      	mov	r3, r4
 8004c9a:	9301      	str	r3, [sp, #4]
 8004c9c:	9b01      	ldr	r3, [sp, #4]
 8004c9e:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8004ca2:	9b02      	ldr	r3, [sp, #8]
 8004ca4:	69db      	ldr	r3, [r3, #28]
 8004ca6:	429a      	cmp	r2, r3
 8004ca8:	d205      	bcs.n	8004cb6 <chSchDoRescheduleAhead.4188+0xb6>
 8004caa:	f245 50c0 	movw	r0, #21952	; 0x55c0
 8004cae:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004cb2:	f7ff f9f5 	bl	80040a0 <chSysHalt>
 8004cb6:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004cbe:	699b      	ldr	r3, [r3, #24]
 8004cc0:	4618      	mov	r0, r3
 8004cc2:	9902      	ldr	r1, [sp, #8]
 8004cc4:	f7fb fae4 	bl	8000290 <_port_switch>
}
 8004cc8:	b004      	add	sp, #16
 8004cca:	bd10      	pop	{r4, pc}
 8004ccc:	f3af 8000 	nop.w

08004cd0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8004cd0:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8004cd2:	f7ff ff95 	bl	8004c00 <chSchDoRescheduleAhead.4188>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8004cd6:	bd08      	pop	{r3, pc}
 8004cd8:	f3af 8000 	nop.w
 8004cdc:	f3af 8000 	nop.w

08004ce0 <port_lock.5179.4183>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004ce0:	b082      	sub	sp, #8
 8004ce2:	f04f 0320 	mov.w	r3, #32
 8004ce6:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8004ce8:	9b01      	ldr	r3, [sp, #4]
 8004cea:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004cee:	b002      	add	sp, #8
 8004cf0:	4770      	bx	lr
 8004cf2:	bf00      	nop
 8004cf4:	f3af 8000 	nop.w
 8004cf8:	f3af 8000 	nop.w
 8004cfc:	f3af 8000 	nop.w

08004d00 <port_unlock.5182.4181>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004d00:	b082      	sub	sp, #8
 8004d02:	f04f 0300 	mov.w	r3, #0
 8004d06:	9301      	str	r3, [sp, #4]
 8004d08:	9b01      	ldr	r3, [sp, #4]
 8004d0a:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004d0e:	b002      	add	sp, #8
 8004d10:	4770      	bx	lr
 8004d12:	bf00      	nop
 8004d14:	f3af 8000 	nop.w
 8004d18:	f3af 8000 	nop.w
 8004d1c:	f3af 8000 	nop.w

08004d20 <list_init.5190.4178>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8004d20:	b082      	sub	sp, #8
 8004d22:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8004d24:	9b01      	ldr	r3, [sp, #4]
 8004d26:	9a01      	ldr	r2, [sp, #4]
 8004d28:	601a      	str	r2, [r3, #0]
}
 8004d2a:	b002      	add	sp, #8
 8004d2c:	4770      	bx	lr
 8004d2e:	bf00      	nop

08004d30 <list_notempty.5274.4175>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8004d30:	b082      	sub	sp, #8
 8004d32:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8004d34:	9b01      	ldr	r3, [sp, #4]
 8004d36:	681a      	ldr	r2, [r3, #0]
 8004d38:	9b01      	ldr	r3, [sp, #4]
 8004d3a:	429a      	cmp	r2, r3
 8004d3c:	bf0c      	ite	eq
 8004d3e:	2300      	moveq	r3, #0
 8004d40:	2301      	movne	r3, #1
 8004d42:	b2db      	uxtb	r3, r3
}
 8004d44:	4618      	mov	r0, r3
 8004d46:	b002      	add	sp, #8
 8004d48:	4770      	bx	lr
 8004d4a:	bf00      	nop
 8004d4c:	f3af 8000 	nop.w

08004d50 <queue_init.5278.4172>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8004d50:	b082      	sub	sp, #8
 8004d52:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8004d54:	9b01      	ldr	r3, [sp, #4]
 8004d56:	9a01      	ldr	r2, [sp, #4]
 8004d58:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8004d5a:	9b01      	ldr	r3, [sp, #4]
 8004d5c:	9a01      	ldr	r2, [sp, #4]
 8004d5e:	605a      	str	r2, [r3, #4]
}
 8004d60:	b002      	add	sp, #8
 8004d62:	4770      	bx	lr
 8004d64:	f3af 8000 	nop.w
 8004d68:	f3af 8000 	nop.w
 8004d6c:	f3af 8000 	nop.w

08004d70 <queue_notempty.5281.4167>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8004d70:	b082      	sub	sp, #8
 8004d72:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8004d74:	9b01      	ldr	r3, [sp, #4]
 8004d76:	681a      	ldr	r2, [r3, #0]
 8004d78:	9b01      	ldr	r3, [sp, #4]
 8004d7a:	429a      	cmp	r2, r3
 8004d7c:	bf0c      	ite	eq
 8004d7e:	2300      	moveq	r3, #0
 8004d80:	2301      	movne	r3, #1
 8004d82:	b2db      	uxtb	r3, r3
}
 8004d84:	4618      	mov	r0, r3
 8004d86:	b002      	add	sp, #8
 8004d88:	4770      	bx	lr
 8004d8a:	bf00      	nop
 8004d8c:	f3af 8000 	nop.w

08004d90 <list_remove.5288.4164>:

  tp->p_next = tlp->p_next;
  tlp->p_next = tp;
}

static inline thread_t *list_remove(threads_list_t *tlp) {
 8004d90:	b084      	sub	sp, #16
 8004d92:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8004d94:	9b01      	ldr	r3, [sp, #4]
 8004d96:	681b      	ldr	r3, [r3, #0]
 8004d98:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 8004d9a:	9b03      	ldr	r3, [sp, #12]
 8004d9c:	681a      	ldr	r2, [r3, #0]
 8004d9e:	9b01      	ldr	r3, [sp, #4]
 8004da0:	601a      	str	r2, [r3, #0]

  return tp;
 8004da2:	9b03      	ldr	r3, [sp, #12]
}
 8004da4:	4618      	mov	r0, r3
 8004da6:	b004      	add	sp, #16
 8004da8:	4770      	bx	lr
 8004daa:	bf00      	nop
 8004dac:	f3af 8000 	nop.w

08004db0 <queue_insert.5291.4160>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8004db0:	b082      	sub	sp, #8
 8004db2:	9001      	str	r0, [sp, #4]
 8004db4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8004db6:	9b01      	ldr	r3, [sp, #4]
 8004db8:	9a00      	ldr	r2, [sp, #0]
 8004dba:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8004dbc:	9b00      	ldr	r3, [sp, #0]
 8004dbe:	685a      	ldr	r2, [r3, #4]
 8004dc0:	9b01      	ldr	r3, [sp, #4]
 8004dc2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8004dc4:	9b01      	ldr	r3, [sp, #4]
 8004dc6:	685b      	ldr	r3, [r3, #4]
 8004dc8:	9a01      	ldr	r2, [sp, #4]
 8004dca:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8004dcc:	9b00      	ldr	r3, [sp, #0]
 8004dce:	9a01      	ldr	r2, [sp, #4]
 8004dd0:	605a      	str	r2, [r3, #4]
}
 8004dd2:	b002      	add	sp, #8
 8004dd4:	4770      	bx	lr
 8004dd6:	bf00      	nop
 8004dd8:	f3af 8000 	nop.w
 8004ddc:	f3af 8000 	nop.w

08004de0 <queue_fifo_remove.5295.4157>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8004de0:	b084      	sub	sp, #16
 8004de2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8004de4:	9b01      	ldr	r3, [sp, #4]
 8004de6:	681b      	ldr	r3, [r3, #0]
 8004de8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8004dea:	9b03      	ldr	r3, [sp, #12]
 8004dec:	681a      	ldr	r2, [r3, #0]
 8004dee:	9b01      	ldr	r3, [sp, #4]
 8004df0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8004df2:	9b01      	ldr	r3, [sp, #4]
 8004df4:	681b      	ldr	r3, [r3, #0]
 8004df6:	9a01      	ldr	r2, [sp, #4]
 8004df8:	605a      	str	r2, [r3, #4]

  return tp;
 8004dfa:	9b03      	ldr	r3, [sp, #12]
}
 8004dfc:	4618      	mov	r0, r3
 8004dfe:	b004      	add	sp, #16
 8004e00:	4770      	bx	lr
 8004e02:	bf00      	nop
 8004e04:	f3af 8000 	nop.w
 8004e08:	f3af 8000 	nop.w
 8004e0c:	f3af 8000 	nop.w

08004e10 <chSysLock.5317.4155>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8004e10:	b508      	push	{r3, lr}

  port_lock();
 8004e12:	f7ff ff65 	bl	8004ce0 <port_lock.5179.4183>
  _stats_start_measure_crit_thd();
 8004e16:	f7fd ff73 	bl	8002d00 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8004e1a:	f7ff f9b9 	bl	8004190 <_dbg_check_lock>
}
 8004e1e:	bd08      	pop	{r3, pc}

08004e20 <chSysUnlock.5319.4153>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8004e20:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8004e22:	f7ff f9d5 	bl	80041d0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8004e26:	f7fd ff73 	bl	8002d10 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8004e2a:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004e2e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e32:	681a      	ldr	r2, [r3, #0]
 8004e34:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004e38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e3c:	429a      	cmp	r2, r3
 8004e3e:	d013      	beq.n	8004e68 <chSysUnlock.5319.4153+0x48>
 8004e40:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004e44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e48:	699b      	ldr	r3, [r3, #24]
 8004e4a:	689a      	ldr	r2, [r3, #8]
 8004e4c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004e50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e54:	681b      	ldr	r3, [r3, #0]
 8004e56:	689b      	ldr	r3, [r3, #8]
 8004e58:	429a      	cmp	r2, r3
 8004e5a:	d205      	bcs.n	8004e68 <chSysUnlock.5319.4153+0x48>
 8004e5c:	f245 6030 	movw	r0, #22064	; 0x5630
 8004e60:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004e64:	f7ff f91c 	bl	80040a0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority violation, missing reschedule");

  port_unlock();
 8004e68:	f7ff ff4a 	bl	8004d00 <port_unlock.5182.4181>
}
 8004e6c:	bd08      	pop	{r3, pc}
 8004e6e:	bf00      	nop

08004e70 <chThdSleepS.5314.4150>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 8004e70:	b500      	push	{lr}
 8004e72:	b083      	sub	sp, #12
 8004e74:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
 8004e76:	9b01      	ldr	r3, [sp, #4]
 8004e78:	2b00      	cmp	r3, #0
 8004e7a:	d105      	bne.n	8004e88 <chThdSleepS.5314.4150+0x18>
 8004e7c:	f245 6050 	movw	r0, #22096	; 0x5650
 8004e80:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004e84:	f7ff f90c 	bl	80040a0 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8004e88:	f04f 0008 	mov.w	r0, #8
 8004e8c:	9901      	ldr	r1, [sp, #4]
 8004e8e:	f7ff fe07 	bl	8004aa0 <chSchGoSleepTimeoutS.4196>
}
 8004e92:	b003      	add	sp, #12
 8004e94:	bd00      	pop	{pc}
 8004e96:	bf00      	nop
 8004e98:	f3af 8000 	nop.w
 8004e9c:	f3af 8000 	nop.w

08004ea0 <chThdDoDequeueNextI.5307.4146>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8004ea0:	b500      	push	{lr}
 8004ea2:	b085      	sub	sp, #20
 8004ea4:	9001      	str	r0, [sp, #4]
 8004ea6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 8004ea8:	9801      	ldr	r0, [sp, #4]
 8004eaa:	f7ff ff61 	bl	8004d70 <queue_notempty.5281.4167>
 8004eae:	4603      	mov	r3, r0
 8004eb0:	f083 0301 	eor.w	r3, r3, #1
 8004eb4:	b2db      	uxtb	r3, r3
 8004eb6:	2b00      	cmp	r3, #0
 8004eb8:	d005      	beq.n	8004ec6 <chThdDoDequeueNextI.5307.4146+0x26>
 8004eba:	f245 6010 	movw	r0, #22032	; 0x5610
 8004ebe:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004ec2:	f7ff f8ed 	bl	80040a0 <chSysHalt>

  tp = queue_fifo_remove(tqp);
 8004ec6:	9801      	ldr	r0, [sp, #4]
 8004ec8:	f7ff ff8a 	bl	8004de0 <queue_fifo_remove.5295.4157>
 8004ecc:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 8004ece:	9b03      	ldr	r3, [sp, #12]
 8004ed0:	f893 3020 	ldrb.w	r3, [r3, #32]
 8004ed4:	2b04      	cmp	r3, #4
 8004ed6:	d005      	beq.n	8004ee4 <chThdDoDequeueNextI.5307.4146+0x44>
 8004ed8:	f245 6010 	movw	r0, #22032	; 0x5610
 8004edc:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004ee0:	f7ff f8de 	bl	80040a0 <chSysHalt>

  tp->p_u.rdymsg = msg;
 8004ee4:	9b03      	ldr	r3, [sp, #12]
 8004ee6:	9a00      	ldr	r2, [sp, #0]
 8004ee8:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8004eea:	9803      	ldr	r0, [sp, #12]
 8004eec:	f7ff fd00 	bl	80048f0 <chSchReadyI>
}
 8004ef0:	b005      	add	sp, #20
 8004ef2:	bd00      	pop	{pc}
 8004ef4:	f3af 8000 	nop.w
 8004ef8:	f3af 8000 	nop.w
 8004efc:	f3af 8000 	nop.w

08004f00 <_thread_init.4142>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8004f00:	b500      	push	{lr}
 8004f02:	b083      	sub	sp, #12
 8004f04:	9001      	str	r0, [sp, #4]
 8004f06:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8004f08:	9b01      	ldr	r3, [sp, #4]
 8004f0a:	9a00      	ldr	r2, [sp, #0]
 8004f0c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 8004f0e:	9b01      	ldr	r3, [sp, #4]
 8004f10:	f04f 0202 	mov.w	r2, #2
 8004f14:	f883 2020 	strb.w	r2, [r3, #32]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8004f18:	9b01      	ldr	r3, [sp, #4]
 8004f1a:	f04f 0200 	mov.w	r2, #0
 8004f1e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8004f22:	9b01      	ldr	r3, [sp, #4]
 8004f24:	9a00      	ldr	r2, [sp, #0]
 8004f26:	641a      	str	r2, [r3, #64]	; 0x40
  tp->p_mtxlist = NULL;
 8004f28:	9b01      	ldr	r3, [sp, #4]
 8004f2a:	f04f 0200 	mov.w	r2, #0
 8004f2e:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8004f30:	9b01      	ldr	r3, [sp, #4]
 8004f32:	f04f 0200 	mov.w	r2, #0
 8004f36:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8004f38:	9b01      	ldr	r3, [sp, #4]
 8004f3a:	f04f 0201 	mov.w	r2, #1
 8004f3e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8004f42:	9b01      	ldr	r3, [sp, #4]
 8004f44:	f04f 0200 	mov.w	r2, #0
 8004f48:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8004f4a:	9a01      	ldr	r2, [sp, #4]
 8004f4c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004f50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f54:	6113      	str	r3, [r2, #16]
 8004f56:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004f5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f5e:	695a      	ldr	r2, [r3, #20]
 8004f60:	9b01      	ldr	r3, [sp, #4]
 8004f62:	615a      	str	r2, [r3, #20]
 8004f64:	9b01      	ldr	r3, [sp, #4]
 8004f66:	695b      	ldr	r3, [r3, #20]
 8004f68:	9a01      	ldr	r2, [sp, #4]
 8004f6a:	611a      	str	r2, [r3, #16]
 8004f6c:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8004f70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004f74:	9a01      	ldr	r2, [sp, #4]
 8004f76:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8004f78:	9b01      	ldr	r3, [sp, #4]
 8004f7a:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8004f7e:	4618      	mov	r0, r3
 8004f80:	f7ff fece 	bl	8004d20 <list_init.5190.4178>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8004f84:	9b01      	ldr	r3, [sp, #4]
 8004f86:	f103 032c 	add.w	r3, r3, #44	; 0x2c
 8004f8a:	4618      	mov	r0, r3
 8004f8c:	f7ff fee0 	bl	8004d50 <queue_init.5278.4172>
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 8004f90:	9b01      	ldr	r3, [sp, #4]
 8004f92:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8004f96:	9b01      	ldr	r3, [sp, #4]
 8004f98:	61da      	str	r2, [r3, #28]
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->p_stats);
 8004f9a:	9b01      	ldr	r3, [sp, #4]
 8004f9c:	f103 0348 	add.w	r3, r3, #72	; 0x48
 8004fa0:	4618      	mov	r0, r3
 8004fa2:	f000 f995 	bl	80052d0 <chTMObjectInit>
  chTMStartMeasurementX(&tp->p_stats);
 8004fa6:	9b01      	ldr	r3, [sp, #4]
 8004fa8:	f103 0348 	add.w	r3, r3, #72	; 0x48
 8004fac:	4618      	mov	r0, r3
 8004fae:	f7fd fe17 	bl	8002be0 <chTMStartMeasurementX>
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 8004fb2:	9b01      	ldr	r3, [sp, #4]
}
 8004fb4:	4618      	mov	r0, r3
 8004fb6:	b003      	add	sp, #12
 8004fb8:	bd00      	pop	{pc}
 8004fba:	bf00      	nop
 8004fbc:	f3af 8000 	nop.w

08004fc0 <_thread_memfill.4137>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 8004fc0:	b084      	sub	sp, #16
 8004fc2:	9003      	str	r0, [sp, #12]
 8004fc4:	9102      	str	r1, [sp, #8]
 8004fc6:	4613      	mov	r3, r2
 8004fc8:	f88d 3007 	strb.w	r3, [sp, #7]
 8004fcc:	e007      	b.n	8004fde <_thread_memfill.4137+0x1e>

  while (startp < endp) {
    *startp++ = v;
 8004fce:	9b03      	ldr	r3, [sp, #12]
 8004fd0:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8004fd4:	701a      	strb	r2, [r3, #0]
 8004fd6:	9b03      	ldr	r3, [sp, #12]
 8004fd8:	f103 0301 	add.w	r3, r3, #1
 8004fdc:	9303      	str	r3, [sp, #12]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8004fde:	9a03      	ldr	r2, [sp, #12]
 8004fe0:	9b02      	ldr	r3, [sp, #8]
 8004fe2:	429a      	cmp	r2, r3
 8004fe4:	d3f3      	bcc.n	8004fce <_thread_memfill.4137+0xe>
    *startp++ = v;
  }
}
 8004fe6:	b004      	add	sp, #16
 8004fe8:	4770      	bx	lr
 8004fea:	bf00      	nop
 8004fec:	f3af 8000 	nop.w

08004ff0 <chThdCreateI.4129>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8004ff0:	b500      	push	{lr}
 8004ff2:	b087      	sub	sp, #28
 8004ff4:	9003      	str	r0, [sp, #12]
 8004ff6:	9102      	str	r1, [sp, #8]
 8004ff8:	9201      	str	r2, [sp, #4]
 8004ffa:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 8004ffc:	9b03      	ldr	r3, [sp, #12]
 8004ffe:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8005000:	f7ff f996 	bl	8004330 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 8005004:	9b03      	ldr	r3, [sp, #12]
 8005006:	2b00      	cmp	r3, #0
 8005008:	d008      	beq.n	800501c <chThdCreateI.4129+0x2c>
 800500a:	9b02      	ldr	r3, [sp, #8]
 800500c:	2be7      	cmp	r3, #231	; 0xe7
 800500e:	d905      	bls.n	800501c <chThdCreateI.4129+0x2c>
 8005010:	9b01      	ldr	r3, [sp, #4]
 8005012:	2b7f      	cmp	r3, #127	; 0x7f
 8005014:	d802      	bhi.n	800501c <chThdCreateI.4129+0x2c>
 8005016:	9b00      	ldr	r3, [sp, #0]
 8005018:	2b00      	cmp	r3, #0
 800501a:	d105      	bne.n	8005028 <chThdCreateI.4129+0x38>
 800501c:	f245 6060 	movw	r0, #22112	; 0x5660
 8005020:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005024:	f7ff f83c 	bl	80040a0 <chSysHalt>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8005028:	9b02      	ldr	r3, [sp, #8]
 800502a:	f1a3 0324 	sub.w	r3, r3, #36	; 0x24
 800502e:	9a03      	ldr	r2, [sp, #12]
 8005030:	18d2      	adds	r2, r2, r3
 8005032:	9b05      	ldr	r3, [sp, #20]
 8005034:	60da      	str	r2, [r3, #12]
 8005036:	9b05      	ldr	r3, [sp, #20]
 8005038:	68db      	ldr	r3, [r3, #12]
 800503a:	9a00      	ldr	r2, [sp, #0]
 800503c:	601a      	str	r2, [r3, #0]
 800503e:	9b05      	ldr	r3, [sp, #20]
 8005040:	68db      	ldr	r3, [r3, #12]
 8005042:	9a08      	ldr	r2, [sp, #32]
 8005044:	605a      	str	r2, [r3, #4]
 8005046:	9b05      	ldr	r3, [sp, #20]
 8005048:	68da      	ldr	r2, [r3, #12]
 800504a:	f240 23a1 	movw	r3, #673	; 0x2a1
 800504e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005052:	6213      	str	r3, [r2, #32]

  return _thread_init(tp, prio);
 8005054:	9805      	ldr	r0, [sp, #20]
 8005056:	9901      	ldr	r1, [sp, #4]
 8005058:	f7ff ff52 	bl	8004f00 <_thread_init.4142>
 800505c:	4603      	mov	r3, r0
}
 800505e:	4618      	mov	r0, r3
 8005060:	b007      	add	sp, #28
 8005062:	bd00      	pop	{pc}
 8005064:	f3af 8000 	nop.w
 8005068:	f3af 8000 	nop.w
 800506c:	f3af 8000 	nop.w

08005070 <chThdCreateStatic.4120>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8005070:	b500      	push	{lr}
 8005072:	b089      	sub	sp, #36	; 0x24
 8005074:	9005      	str	r0, [sp, #20]
 8005076:	9104      	str	r1, [sp, #16]
 8005078:	9203      	str	r2, [sp, #12]
 800507a:	9302      	str	r3, [sp, #8]
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 800507c:	9b05      	ldr	r3, [sp, #20]
 800507e:	f103 0360 	add.w	r3, r3, #96	; 0x60
 8005082:	9805      	ldr	r0, [sp, #20]
 8005084:	4619      	mov	r1, r3
 8005086:	f04f 02ff 	mov.w	r2, #255	; 0xff
 800508a:	f7ff ff99 	bl	8004fc0 <_thread_memfill.4137>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 800508e:	9b05      	ldr	r3, [sp, #20]
 8005090:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8005094:	9905      	ldr	r1, [sp, #20]
 8005096:	9b04      	ldr	r3, [sp, #16]
 8005098:	18cb      	adds	r3, r1, r3
 800509a:	4610      	mov	r0, r2
 800509c:	4619      	mov	r1, r3
 800509e:	f04f 0255 	mov.w	r2, #85	; 0x55
 80050a2:	f7ff ff8d 	bl	8004fc0 <_thread_memfill.4137>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80050a6:	f7ff feb3 	bl	8004e10 <chSysLock.5317.4155>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80050aa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80050ac:	9300      	str	r3, [sp, #0]
 80050ae:	9805      	ldr	r0, [sp, #20]
 80050b0:	9904      	ldr	r1, [sp, #16]
 80050b2:	9a03      	ldr	r2, [sp, #12]
 80050b4:	9b02      	ldr	r3, [sp, #8]
 80050b6:	f7ff ff9b 	bl	8004ff0 <chThdCreateI.4129>
 80050ba:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 80050bc:	9807      	ldr	r0, [sp, #28]
 80050be:	f04f 0100 	mov.w	r1, #0
 80050c2:	f7ff fd2d 	bl	8004b20 <chSchWakeupS.4192>
  chSysUnlock();
 80050c6:	f7ff feab 	bl	8004e20 <chSysUnlock.5319.4153>

  return tp;
 80050ca:	9b07      	ldr	r3, [sp, #28]
}
 80050cc:	4618      	mov	r0, r3
 80050ce:	b009      	add	sp, #36	; 0x24
 80050d0:	bd00      	pop	{pc}
 80050d2:	bf00      	nop
 80050d4:	f3af 8000 	nop.w
 80050d8:	f3af 8000 	nop.w
 80050dc:	f3af 8000 	nop.w

080050e0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80050e0:	b500      	push	{lr}
 80050e2:	b083      	sub	sp, #12
 80050e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80050e6:	f7ff fe93 	bl	8004e10 <chSysLock.5317.4155>
  chThdSleepS(time);
 80050ea:	9801      	ldr	r0, [sp, #4]
 80050ec:	f7ff fec0 	bl	8004e70 <chThdSleepS.5314.4150>
  chSysUnlock();
 80050f0:	f7ff fe96 	bl	8004e20 <chSysUnlock.5319.4153>
}
 80050f4:	b003      	add	sp, #12
 80050f6:	bd00      	pop	{pc}
 80050f8:	f3af 8000 	nop.w
 80050fc:	f3af 8000 	nop.w

08005100 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8005100:	b500      	push	{lr}
 8005102:	b083      	sub	sp, #12
 8005104:	9001      	str	r0, [sp, #4]

  chSysLock();
 8005106:	f7ff fe83 	bl	8004e10 <chSysLock.5317.4155>
  chThdExitS(msg);
 800510a:	9801      	ldr	r0, [sp, #4]
 800510c:	f000 f808 	bl	8005120 <chThdExitS.4111>
  /* The thread never returns here.*/
}
 8005110:	b003      	add	sp, #12
 8005112:	bd00      	pop	{pc}
 8005114:	f3af 8000 	nop.w
 8005118:	f3af 8000 	nop.w
 800511c:	f3af 8000 	nop.w

08005120 <chThdExitS.4111>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8005120:	b500      	push	{lr}
 8005122:	b085      	sub	sp, #20
 8005124:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8005126:	f243 63b0 	movw	r3, #14000	; 0x36b0
 800512a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800512e:	699b      	ldr	r3, [r3, #24]
 8005130:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 8005132:	9b03      	ldr	r3, [sp, #12]
 8005134:	9a01      	ldr	r2, [sp, #4]
 8005136:	625a      	str	r2, [r3, #36]	; 0x24
 8005138:	e009      	b.n	800514e <chThdExitS.4111+0x2e>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 800513a:	9b03      	ldr	r3, [sp, #12]
 800513c:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8005140:	4618      	mov	r0, r3
 8005142:	f7ff fe25 	bl	8004d90 <list_remove.5288.4164>
 8005146:	4603      	mov	r3, r0
 8005148:	4618      	mov	r0, r3
 800514a:	f7ff fbd1 	bl	80048f0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800514e:	9b03      	ldr	r3, [sp, #12]
 8005150:	f103 0328 	add.w	r3, r3, #40	; 0x28
 8005154:	4618      	mov	r0, r3
 8005156:	f7ff fdeb 	bl	8004d30 <list_notempty.5274.4175>
 800515a:	4603      	mov	r3, r0
 800515c:	2b00      	cmp	r3, #0
 800515e:	d1ec      	bne.n	800513a <chThdExitS.4111+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8005160:	9b03      	ldr	r3, [sp, #12]
 8005162:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8005166:	f003 0303 	and.w	r3, r3, #3
 800516a:	2b00      	cmp	r3, #0
 800516c:	d109      	bne.n	8005182 <chThdExitS.4111+0x62>
    REG_REMOVE(tp);
 800516e:	9b03      	ldr	r3, [sp, #12]
 8005170:	695b      	ldr	r3, [r3, #20]
 8005172:	9a03      	ldr	r2, [sp, #12]
 8005174:	6912      	ldr	r2, [r2, #16]
 8005176:	611a      	str	r2, [r3, #16]
 8005178:	9b03      	ldr	r3, [sp, #12]
 800517a:	691b      	ldr	r3, [r3, #16]
 800517c:	9a03      	ldr	r2, [sp, #12]
 800517e:	6952      	ldr	r2, [r2, #20]
 8005180:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8005182:	f04f 000f 	mov.w	r0, #15
 8005186:	f7ff fbfb 	bl	8004980 <chSchGoSleepS.4203>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800518a:	f245 6040 	movw	r0, #22080	; 0x5640
 800518e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005192:	f7fe ff85 	bl	80040a0 <chSysHalt>
}
 8005196:	b005      	add	sp, #20
 8005198:	bd00      	pop	{pc}
 800519a:	bf00      	nop
 800519c:	f3af 8000 	nop.w

080051a0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80051a0:	b500      	push	{lr}
 80051a2:	b083      	sub	sp, #12
 80051a4:	9001      	str	r0, [sp, #4]
 80051a6:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 80051a8:	9b00      	ldr	r3, [sp, #0]
 80051aa:	2b00      	cmp	r3, #0
 80051ac:	d102      	bne.n	80051b4 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 80051ae:	f04f 33ff 	mov.w	r3, #4294967295
 80051b2:	e00e      	b.n	80051d2 <chThdEnqueueTimeoutS+0x32>
  }

  queue_insert(currp, tqp);
 80051b4:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80051b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80051bc:	699b      	ldr	r3, [r3, #24]
 80051be:	4618      	mov	r0, r3
 80051c0:	9901      	ldr	r1, [sp, #4]
 80051c2:	f7ff fdf5 	bl	8004db0 <queue_insert.5291.4160>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80051c6:	f04f 0004 	mov.w	r0, #4
 80051ca:	9900      	ldr	r1, [sp, #0]
 80051cc:	f7ff fc68 	bl	8004aa0 <chSchGoSleepTimeoutS.4196>
 80051d0:	4603      	mov	r3, r0
}
 80051d2:	4618      	mov	r0, r3
 80051d4:	b003      	add	sp, #12
 80051d6:	bd00      	pop	{pc}
 80051d8:	f3af 8000 	nop.w
 80051dc:	f3af 8000 	nop.w

080051e0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80051e0:	b500      	push	{lr}
 80051e2:	b083      	sub	sp, #12
 80051e4:	9001      	str	r0, [sp, #4]
 80051e6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 80051e8:	9801      	ldr	r0, [sp, #4]
 80051ea:	f7ff fdc1 	bl	8004d70 <queue_notempty.5281.4167>
 80051ee:	4603      	mov	r3, r0
 80051f0:	2b00      	cmp	r3, #0
 80051f2:	d003      	beq.n	80051fc <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 80051f4:	9801      	ldr	r0, [sp, #4]
 80051f6:	9900      	ldr	r1, [sp, #0]
 80051f8:	f7ff fe52 	bl	8004ea0 <chThdDoDequeueNextI.5307.4146>
  }
}
 80051fc:	b003      	add	sp, #12
 80051fe:	bd00      	pop	{pc}

08005200 <port_rt_get_counter_value.5541>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8005200:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8005204:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8005208:	685b      	ldr	r3, [r3, #4]
}
 800520a:	4618      	mov	r0, r3
 800520c:	4770      	bx	lr
 800520e:	bf00      	nop

08005210 <tm_stop.5546>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8005210:	b410      	push	{r4}
 8005212:	b085      	sub	sp, #20
 8005214:	9003      	str	r0, [sp, #12]
 8005216:	9102      	str	r1, [sp, #8]
 8005218:	9201      	str	r2, [sp, #4]

  tmp->n++;
 800521a:	9b03      	ldr	r3, [sp, #12]
 800521c:	68db      	ldr	r3, [r3, #12]
 800521e:	f103 0201 	add.w	r2, r3, #1
 8005222:	9b03      	ldr	r3, [sp, #12]
 8005224:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8005226:	9b03      	ldr	r3, [sp, #12]
 8005228:	689b      	ldr	r3, [r3, #8]
 800522a:	9a02      	ldr	r2, [sp, #8]
 800522c:	1ad2      	subs	r2, r2, r3
 800522e:	9b01      	ldr	r3, [sp, #4]
 8005230:	1ad2      	subs	r2, r2, r3
 8005232:	9b03      	ldr	r3, [sp, #12]
 8005234:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8005236:	9b03      	ldr	r3, [sp, #12]
 8005238:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800523c:	9b03      	ldr	r3, [sp, #12]
 800523e:	689c      	ldr	r4, [r3, #8]
 8005240:	4622      	mov	r2, r4
 8005242:	f04f 0300 	mov.w	r3, #0
 8005246:	1812      	adds	r2, r2, r0
 8005248:	eb43 0301 	adc.w	r3, r3, r1
 800524c:	9903      	ldr	r1, [sp, #12]
 800524e:	e9c1 2304 	strd	r2, r3, [r1, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8005252:	9b03      	ldr	r3, [sp, #12]
 8005254:	689a      	ldr	r2, [r3, #8]
 8005256:	9b03      	ldr	r3, [sp, #12]
 8005258:	685b      	ldr	r3, [r3, #4]
 800525a:	429a      	cmp	r2, r3
 800525c:	d904      	bls.n	8005268 <tm_stop.5546+0x58>
    tmp->worst = tmp->last;
 800525e:	9b03      	ldr	r3, [sp, #12]
 8005260:	689a      	ldr	r2, [r3, #8]
 8005262:	9b03      	ldr	r3, [sp, #12]
 8005264:	605a      	str	r2, [r3, #4]
 8005266:	e009      	b.n	800527c <tm_stop.5546+0x6c>
  }
  else if (tmp->last < tmp->best) {
 8005268:	9b03      	ldr	r3, [sp, #12]
 800526a:	689a      	ldr	r2, [r3, #8]
 800526c:	9b03      	ldr	r3, [sp, #12]
 800526e:	681b      	ldr	r3, [r3, #0]
 8005270:	429a      	cmp	r2, r3
 8005272:	d203      	bcs.n	800527c <tm_stop.5546+0x6c>
    tmp->best = tmp->last;
 8005274:	9b03      	ldr	r3, [sp, #12]
 8005276:	689a      	ldr	r2, [r3, #8]
 8005278:	9b03      	ldr	r3, [sp, #12]
 800527a:	601a      	str	r2, [r3, #0]
  }
  /*lint -restore*/
}
 800527c:	b005      	add	sp, #20
 800527e:	bc10      	pop	{r4}
 8005280:	4770      	bx	lr
 8005282:	bf00      	nop
 8005284:	f3af 8000 	nop.w
 8005288:	f3af 8000 	nop.w
 800528c:	f3af 8000 	nop.w

08005290 <_tm_init.4021>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8005290:	b500      	push	{lr}
 8005292:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8005294:	f243 63b0 	movw	r3, #14000	; 0x36b0
 8005298:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800529c:	f04f 0200 	mov.w	r2, #0
 80052a0:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
  chTMObjectInit(&tm);
 80052a4:	466b      	mov	r3, sp
 80052a6:	4618      	mov	r0, r3
 80052a8:	f000 f812 	bl	80052d0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 80052ac:	466b      	mov	r3, sp
 80052ae:	4618      	mov	r0, r3
 80052b0:	f7fd fc96 	bl	8002be0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 80052b4:	466b      	mov	r3, sp
 80052b6:	4618      	mov	r0, r3
 80052b8:	f7fd fca2 	bl	8002c00 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 80052bc:	9a02      	ldr	r2, [sp, #8]
 80052be:	f243 63b0 	movw	r3, #14000	; 0x36b0
 80052c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80052c6:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
}
 80052ca:	b007      	add	sp, #28
 80052cc:	bd00      	pop	{pc}
 80052ce:	bf00      	nop

080052d0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 80052d0:	b082      	sub	sp, #8
 80052d2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 80052d4:	9b01      	ldr	r3, [sp, #4]
 80052d6:	f04f 32ff 	mov.w	r2, #4294967295
 80052da:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 80052dc:	9b01      	ldr	r3, [sp, #4]
 80052de:	f04f 0200 	mov.w	r2, #0
 80052e2:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 80052e4:	9b01      	ldr	r3, [sp, #4]
 80052e6:	f04f 0200 	mov.w	r2, #0
 80052ea:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 80052ec:	9b01      	ldr	r3, [sp, #4]
 80052ee:	f04f 0200 	mov.w	r2, #0
 80052f2:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 80052f4:	9901      	ldr	r1, [sp, #4]
 80052f6:	f04f 0200 	mov.w	r2, #0
 80052fa:	f04f 0300 	mov.w	r3, #0
 80052fe:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 8005302:	b002      	add	sp, #8
 8005304:	4770      	bx	lr
 8005306:	bf00      	nop
 8005308:	f3af 8000 	nop.w
 800530c:	f3af 8000 	nop.w
 8005310:	6c756e28 	.word	0x6c756e28
 8005314:	0000296c 	.word	0x0000296c
 8005318:	2d2d2d2d 	.word	0x2d2d2d2d
 800531c:	2d2d2d2d 	.word	0x2d2d2d2d
 8005320:	2d2d2d2d 	.word	0x2d2d2d2d
 8005324:	2d2d2d2d 	.word	0x2d2d2d2d
 8005328:	2d2d2d2d 	.word	0x2d2d2d2d
 800532c:	2d2d2d2d 	.word	0x2d2d2d2d
 8005330:	2d2d2d2d 	.word	0x2d2d2d2d
 8005334:	0a2d2d2d 	.word	0x0a2d2d2d
 8005338:	00000000 	.word	0x00000000
 800533c:	6f532020 	.word	0x6f532020
 8005340:	65637275 	.word	0x65637275
 8005344:	25203a20 	.word	0x25203a20
 8005348:	00000a73 	.word	0x00000a73
 800534c:	65442020 	.word	0x65442020
 8005350:	6e697473 	.word	0x6e697473
 8005354:	6f697461 	.word	0x6f697461
 8005358:	203a206e 	.word	0x203a206e
 800535c:	000a7325 	.word	0x000a7325
 8005360:	72452020 	.word	0x72452020
 8005364:	20726f72 	.word	0x20726f72
 8005368:	72206e69 	.word	0x72206e69
 800536c:	69727465 	.word	0x69727465
 8005370:	6e697665 	.word	0x6e697665
 8005374:	69642067 	.word	0x69642067
 8005378:	65706967 	.word	0x65706967
 800537c:	72657461 	.word	0x72657461
 8005380:	74616420 	.word	0x74616420
 8005384:	65202c61 	.word	0x65202c61
 8005388:	74746978 	.word	0x74746978
 800538c:	20676e69 	.word	0x20676e69
 8005390:	70736964 	.word	0x70736964
 8005394:	5f79616c 	.word	0x5f79616c
 8005398:	6b636170 	.word	0x6b636170
 800539c:	2e2e7465 	.word	0x2e2e7465
 80053a0:	000a2e2e 	.word	0x000a2e2e
 80053a4:	00534559 	.word	0x00534559
 80053a8:	00004f4e 	.word	0x00004f4e
 80053ac:	69442020 	.word	0x69442020
 80053b0:	65706967 	.word	0x65706967
 80053b4:	72657461 	.word	0x72657461
 80053b8:	20642520 	.word	0x20642520
 80053bc:	7325203a 	.word	0x7325203a
 80053c0:	614c2820 	.word	0x614c2820
 80053c4:	44207473 	.word	0x44207473
 80053c8:	70696769 	.word	0x70696769
 80053cc:	65746165 	.word	0x65746165
 80053d0:	203a2072 	.word	0x203a2072
 80053d4:	0a297325 	.word	0x0a297325
 80053d8:	00000000 	.word	0x00000000
 80053dc:	6f432020 	.word	0x6f432020
 80053e0:	6f72746e 	.word	0x6f72746e
 80053e4:	6946206c 	.word	0x6946206c
 80053e8:	20646c65 	.word	0x20646c65
 80053ec:	7830203a 	.word	0x7830203a
 80053f0:	000a7825 	.word	0x000a7825
 80053f4:	49502020 	.word	0x49502020
 80053f8:	203a2044 	.word	0x203a2044
 80053fc:	78257830 	.word	0x78257830
 8005400:	0000000a 	.word	0x0000000a
 8005404:	61502020 	.word	0x61502020
 8005408:	616f6c79 	.word	0x616f6c79
 800540c:	203a2064 	.word	0x203a2064
 8005410:	000a7325 	.word	0x000a7325
 8005414:	61502020 	.word	0x61502020
 8005418:	616f6c79 	.word	0x616f6c79
 800541c:	654c2064 	.word	0x654c2064
 8005420:	6874676e 	.word	0x6874676e
 8005424:	25203a20 	.word	0x25203a20
 8005428:	00000a64 	.word	0x00000a64
 800542c:	6b636150 	.word	0x6b636150
 8005430:	71207465 	.word	0x71207465
 8005434:	65756575 	.word	0x65756575
 8005438:	706d6520 	.word	0x706d6520
 800543c:	2e2e7974 	.word	0x2e2e7974
 8005440:	00000a2e 	.word	0x00000a2e
 8005444:	45335556 	.word	0x45335556
 8005448:	0000004d 	.word	0x0000004d
 800544c:	00005143 	.word	0x00005143
 8005450:	5f646461 	.word	0x5f646461
 8005454:	6b636170 	.word	0x6b636170
 8005458:	645f7465 	.word	0x645f7465
 800545c:	70696769 	.word	0x70696769
 8005460:	65746165 	.word	0x65746165
 8005464:	65722072 	.word	0x65722072
 8005468:	6e727574 	.word	0x6e727574
 800546c:	25206465 	.word	0x25206465
 8005470:	6f662064 	.word	0x6f662064
 8005474:	69642072 	.word	0x69642072
 8005478:	25206967 	.word	0x25206967
 800547c:	00000a64 	.word	0x00000a64
 8005480:	53494854 	.word	0x53494854
 8005484:	20534920 	.word	0x20534920
 8005488:	4b434150 	.word	0x4b434150
 800548c:	00205445 	.word	0x00205445
 8005490:	6b636150 	.word	0x6b636150
 8005494:	25207465 	.word	0x25207465
 8005498:	00000a64 	.word	0x00000a64
 800549c:	68737570 	.word	0x68737570
 80054a0:	6361705f 	.word	0x6361705f
 80054a4:	5f74656b 	.word	0x5f74656b
 80054a8:	715f6f74 	.word	0x715f6f74
 80054ac:	65756575 	.word	0x65756575
 80054b0:	74657220 	.word	0x74657220
 80054b4:	656e7275 	.word	0x656e7275
 80054b8:	64252064 	.word	0x64252064
 80054bc:	726f6620 	.word	0x726f6620
 80054c0:	746b7020 	.word	0x746b7020
 80054c4:	0a642520 	.word	0x0a642520
 80054c8:	00000000 	.word	0x00000000
 80054cc:	70736944 	.word	0x70736944
 80054d0:	6979616c 	.word	0x6979616c
 80054d4:	5020676e 	.word	0x5020676e
 80054d8:	656b6361 	.word	0x656b6361
 80054dc:	75512074 	.word	0x75512074
 80054e0:	2e657565 	.word	0x2e657565
 80054e4:	000a2e2e 	.word	0x000a2e2e
 80054e8:	70706f50 	.word	0x70706f50
 80054ec:	50206465 	.word	0x50206465
 80054f0:	656b6361 	.word	0x656b6361
 80054f4:	2e2e2e74 	.word	0x2e2e2e74
 80054f8:	0000000a 	.word	0x0000000a
 80054fc:	20706f50 	.word	0x20706f50
 8005500:	6b636170 	.word	0x6b636170
 8005504:	71207465 	.word	0x71207465
 8005508:	65756575 	.word	0x65756575
 800550c:	6d6f6320 	.word	0x6d6f6320
 8005510:	74656c70 	.word	0x74656c70
 8005514:	2e2e2e65 	.word	0x2e2e2e65
 8005518:	00000a2e 	.word	0x00000a2e
 800551c:	70736944 	.word	0x70736944
 8005520:	6979616c 	.word	0x6979616c
 8005524:	5120676e 	.word	0x5120676e
 8005528:	65756575 	.word	0x65756575
 800552c:	74666120 	.word	0x74666120
 8005530:	70207265 	.word	0x70207265
 8005534:	2e687375 	.word	0x2e687375
 8005538:	000a2e2e 	.word	0x000a2e2e
 800553c:	75657551 	.word	0x75657551
 8005540:	74532065 	.word	0x74532065
 8005544:	73757461 	.word	0x73757461
 8005548:	6425203a 	.word	0x6425203a
 800554c:	6425202c 	.word	0x6425202c
 8005550:	0000000a 	.word	0x0000000a
 8005554:	74696157 	.word	0x74696157
 8005558:	2e676e69 	.word	0x2e676e69
 800555c:	0a2e2e2e 	.word	0x0a2e2e2e
	...
 8005570:	656c6469 	.word	0x656c6469
 8005574:	00000000 	.word	0x00000000
 8005578:	33235653 	.word	0x33235653
 800557c:	00000000 	.word	0x00000000
 8005580:	34235653 	.word	0x34235653
 8005584:	00000000 	.word	0x00000000
 8005588:	35235653 	.word	0x35235653
 800558c:	00000000 	.word	0x00000000
 8005590:	36235653 	.word	0x36235653
 8005594:	00000000 	.word	0x00000000
 8005598:	37235653 	.word	0x37235653
 800559c:	00000000 	.word	0x00000000
 80055a0:	38235653 	.word	0x38235653
 80055a4:	00000000 	.word	0x00000000
 80055a8:	39235653 	.word	0x39235653
 80055ac:	00000000 	.word	0x00000000
 80055b0:	31235653 	.word	0x31235653
 80055b4:	00000030 	.word	0x00000030
 80055b8:	31235653 	.word	0x31235653
 80055bc:	00000031 	.word	0x00000031
 80055c0:	63617473 	.word	0x63617473
 80055c4:	766f206b 	.word	0x766f206b
 80055c8:	6c667265 	.word	0x6c667265
 80055cc:	0000776f 	.word	0x0000776f

080055d0 <__func__.5921.4432.4716>:
 80055d0:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

080055e0 <__func__.6546.4919.4672>:
 80055e0:	54566863 65526f44 49746573 00000000     chVTDoResetI....

080055f0 <__func__.6538.4918.4673>:
 80055f0:	54566863 65536f44 00004974 00000000     chVTDoSetI......

08005600 <__func__.6535.5161.4671>:
 8005600:	63536863 61655268 00497964 00000000     chSchReadyI.....

08005610 <__func__.6018.5486.4668>:
 8005610:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
 8005620:	00497478 00000000 00000000 00000000     xtI.............

08005630 <__func__.5835.5489.4670>:
 8005630:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08005640 <__func__.6591.5492.4666>:
 8005640:	68546863 69784564 00005374 00000000     chThdExitS......

08005650 <__func__.6006.5488.4669>:
 8005650:	68546863 656c5364 00537065 00000000     chThdSleepS.....

08005660 <__func__.6547.5490.4667>:
 8005660:	68546863 65724364 49657461 00000000     chThdCreateI....

08005670 <ch_debug.4675>:
 8005670:	6e69616d 18011600 08600404 1814100c     main......`.....
 8005680:	2221201c 00000000 00000000 00000000     . !"............

08005690 <__func__.6530.6739>:
 8005690:	744d6863 6a624f78 49746365 0074696e     chMtxObjectInit.

080056a0 <__func__.6572.7222>:
 80056a0:	76456863 67695374 496c616e 00000000     chEvtSignalI....

080056b0 <__func__.6555.7224>:
 80056b0:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
 80056c0:	49736761 00000000 00000000 00000000     agsI............

080056d0 <__func__.6594.7919>:
 80056d0:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

080056f0 <__func__.5835.7917>:
 80056f0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08005700 <__func__.6558.7918>:
 8005700:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.

08005710 <__func__.5835.8097>:
 8005710:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08005720 <__func__.7136.8555>:
 8005720:	65537473 616c4174 00006d72 00000000     stSetAlarm......

08005730 <__func__.7129.8554>:
 8005730:	74537473 41747261 6d72616c 00000000     stStartAlarm....

08005740 <vmt.9521>:
 8005740:	080039c1 080039f1 08003a21 08003a51     .9...9..!:..Q:..
 8005750:	08003a71 08003aa1 08003ac1 08003af1     q:...:...:...:..

08005760 <__func__.7183.9524>:
 8005760:	6e496473 696d6f63 6144676e 00496174     sdIncomingDataI.

08005770 <__func__.5835.9520>:
 8005770:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08005780 <__func__.7174.9522>:
 8005780:	74536473 00747261 00000000 00000000     sdStart.........

08005790 <_stm32_dma_streams>:
 8005790:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
 80057a0:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
 80057b0:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
 80057c0:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
 80057d0:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
 80057e0:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
 80057f0:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
 8005800:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
 8005810:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
 8005820:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
 8005830:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
 8005840:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

08005850 <dma1_ch1_params.10073>:
 8005850:	40007400 00000000 00000000 ffff0000     .t.@............
 8005860:	080057cc 0e02055e 0000000a 00000000     .W..^...........

08005870 <dma1_ch2_params.10076>:
 8005870:	40007400 00000003 00000010 0000ffff     .t.@............
 8005880:	080057d8 0e02055e 0000000a 00000000     .W..^...........

08005890 <default_config.10542>:
 8005890:	00009600 40000000 00000000 00000000     .......@........

080058a0 <pal_default_config>:
 80058a0:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
 80058b0:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
 80058c0:	00000240 ffffffff 55514515 0000ffff     @........EQU....
 80058d0:	04000000 00000040 02208001 00000000     ....@..... .....
 80058e0:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
 80058f0:	00060600 55000100 00000000 ffffffff     .......U........
 8005900:	00555055 00000fff 00000000 00000000     UPU.............
 8005910:	00000040 00000000 ffffffff 00000000     @...............
 8005920:	0000ffff 00000000 00000000 00000000     ................
 8005930:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8005950:	ffffffff 00000000 0000ffff 00000000     ................
	...
 800596c:	ffffffff 00000000 0000ffff 00000000     ................
	...
 8005988:	ffffffff 00000000 0000ffff 00000000     ................
 8005998:	00000000                                ....
